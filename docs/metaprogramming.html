
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第九章：元编程 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="module-and-pack.html" />
    
    
    <link rel="prev" href="classes-and-objects.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="data-structures-and-algorithms.html">
            
                <a href="data-structures-and-algorithms.html">
            
                    
                    第一章：数据结构和算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="string-and-text.html">
            
                <a href="string-and-text.html">
            
                    
                    第二章：字符串和文本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="digital-date-and-time.html">
            
                <a href="digital-date-and-time.html">
            
                    
                    第三章：数字日期和时间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="iterators-and-generators.html">
            
                <a href="iterators-and-generators.html">
            
                    
                    第四章：迭代器与生成器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="files-and-io.html">
            
                <a href="files-and-io.html">
            
                    
                    第五章：文件与 IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="coding-and-processing-data.html">
            
                <a href="coding-and-processing-data.html">
            
                    
                    第六章：数据编码和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    第七章：函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="classes-and-objects.html">
            
                <a href="classes-and-objects.html">
            
                    
                    第八章：类与对象
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.10" data-path="metaprogramming.html">
            
                <a href="metaprogramming.html">
            
                    
                    第九章：元编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="module-and-pack.html">
            
                <a href="module-and-pack.html">
            
                    
                    第十章：模块与包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="network-and-web-programming.html">
            
                <a href="network-and-web-programming.html">
            
                    
                    第十一章：网络与 Web 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="concurrent-programming.html">
            
                <a href="concurrent-programming.html">
            
                    
                    第十二章：并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="scripting-and-systems-management.html">
            
                <a href="scripting-and-systems-management.html">
            
                    
                    第十三章：脚本编程与系统管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="testing-debugging-and-exception.html">
            
                <a href="testing-debugging-and-exception.html">
            
                    
                    第十四章：测试、调试和异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="c-language-extensions.html">
            
                <a href="c-language-extensions.html">
            
                    
                    第十五章：C 语言扩展
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第九章：元编程</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第九章：元编程">第九章：元编程</h1>
<p>软件开发领域中最经典的口头禅就是“don’t repeat yourself”。 也就是说，任何时候当你的程序中存在高度重复(或者是通过剪切复制)的代码时，都应该想想是否有更好的解决方案。 在 Python 当中，通常都可以通过元编程来解决这类问题。 简而言之，元编程就是关于创建操作源代码(比如修改、生成或包装原来的代码)的函数和类。 主要技术是使用装饰器、类装饰器和元类。不过还有一些其他技术， 包括签名对象、使用 <code>exec()</code> 执行代码以及对内部函数和类的反射技术等。 本章的主要目的是向大家介绍这些元编程技术，并且给出实例来演示它们是怎样定制化你的源代码行为的。</p>
<h1 id="91-在函数上添加包装器">9.1 在函数上添加包装器</h1>
<h2 id="问题">问题</h2>
<p>你想在函数上添加一个包装器，增加额外的操作处理(比如日志、计时等)。</p>
<h2 id="解决方案">解决方案</h2>
<p>如果你想使用额外的代码包装一个函数，可以定义一个装饰器函数，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-keyword">def</span> <span class="hljs-title function_">timethis</span>(<span class="hljs-params">func</span>):
    <span class="hljs-string">'''
    Decorator that reports the execution time.
    '''</span>
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        <span class="hljs-built_in">print</span>(func.__name__, end-start)
        <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">return</span> wrapper
</code></pre>
<p>下面是使用装饰器的例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@timethis
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
<span class="hljs-meta">... </span>    <span class="hljs-string">'''
<span class="hljs-meta">... </span>    Counts down
<span class="hljs-meta">... </span>    '''</span>
<span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
<span class="hljs-meta">... </span>        n -= <span class="hljs-number">1</span>
...
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown(<span class="hljs-number">100000</span>)
countdown <span class="hljs-number">0.008917808532714844</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown(<span class="hljs-number">10000000</span>)
countdown <span class="hljs-number">0.87188299392912</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>一个装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数。 当你像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-meta">@timethis</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>跟像下面这样写其实效果是一样的：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">pass</span>
countdown = timethis(countdown)
</code></pre>
<p>顺便说一下，内置的装饰器比如 <code>@staticmethod, @classmethod,@property</code>原理也是一样的。 例如，下面这两个代码片段是等价的：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">cls</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:
    <span class="hljs-comment"># Equivalent definition of a class method</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">cls</span>):
        <span class="hljs-keyword">pass</span>
    method = <span class="hljs-built_in">classmethod</span>(method)
</code></pre>
<p>在上面的 <code>wrapper()</code> 函数中， 装饰器内部定义了一个使用 <code>*args</code>和 <code>**kwargs</code>来接受任意参数的函数。 在这个函数里面调用了原始函数并将其结果返回，不过你还可以添加其他额外的代码(比如计时)。 然后这个新的函数包装器被作为结果返回来代替原始函数。</p>
<p>需要强调的是装饰器并不会修改原始函数的参数签名以及返回值。 使用<code>*args</code> 和 <code>**kwargs</code>目的就是确保任何参数都能适用。 而返回结果值基本都是调用原始函数 <code>func(*args, **kwargs)</code> 的返回结果，其中 func 就是原始函数。</p>
<p>刚开始学习装饰器的时候，会使用一些简单的例子来说明，比如上面演示的这个。 不过实际场景使用时，还是有一些细节问题要注意的。 比如上面使用 <code>@wraps(func)</code> 注解是很重要的， 它能保留原始函数的元数据(下一小节会讲到)，新手经常会忽略这个细节。 接下来的几个小节我们会更加深入的讲解装饰器函数的细节问题，如果你想构造你自己的装饰器函数，需要认真看一下。</p>
<h1 id="92-创建装饰器时保留函数元信息">9.2 创建装饰器时保留函数元信息</h1>
<h2 id="问题">问题</h2>
<p>你写了一个装饰器作用在某个函数上，但是这个函数的重要的元信息比如名字、文档字符串、注解和参数签名都丢失了。</p>
<h2 id="解决方案">解决方案</h2>
<p>任何时候你定义装饰器的时候，都应该使用 <code>functools</code> 库中的 <code>@wraps</code>装饰器来注解底层包装函数。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps
<span class="hljs-keyword">def</span> <span class="hljs-title function_">timethis</span>(<span class="hljs-params">func</span>):
    <span class="hljs-string">'''
    Decorator that reports the execution time.
    '''</span>
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        <span class="hljs-built_in">print</span>(func.__name__, end-start)
        <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">return</span> wrapper
</code></pre>
<p>下面我们使用这个被包装后的函数并检查它的元信息：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@timethis
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n:<span class="hljs-built_in">int</span></span>):
<span class="hljs-meta">... </span>    <span class="hljs-string">'''
<span class="hljs-meta">... </span>    Counts down
<span class="hljs-meta">... </span>    '''</span>
<span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
<span class="hljs-meta">... </span>        n -= <span class="hljs-number">1</span>
...
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown(<span class="hljs-number">100000</span>)
countdown <span class="hljs-number">0.008917808532714844</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__name__
<span class="hljs-string">'countdown'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__doc__
<span class="hljs-string">'\n\tCounts down\n\t'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__annotations__
{<span class="hljs-string">'n'</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;}
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>在编写装饰器的时候复制元信息是一个非常重要的部分。如果你忘记了使用 <code>@wrap</code> ， 那么你会发现被装饰函数丢失了所有有用的信息。比如如果忽略 <code>@wrap</code> 后的效果是下面这样的：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__name__
<span class="hljs-string">'wrapper'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__doc__
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__annotations__
{}
&gt;&gt;&gt;
</code></pre>
<p><code>@wraps</code> 有一个重要特征是它能让你通过属性<code>__wrapped__</code> 直接访问被包装函数。例如:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__wrapped__(<span class="hljs-number">100000</span>)
&gt;&gt;&gt;
</code></pre>
<p><code>__wrapped__</code> 属性还能让被装饰函数正确暴露底层的参数签名信息。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> signature
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(signature(countdown))
(n:<span class="hljs-built_in">int</span>)
&gt;&gt;&gt;
</code></pre>
<p>一个很普遍的问题是怎样让装饰器去直接复制原始函数的参数签名信息， 如果想自己手动实现的话需要做大量的工作，最好就简单的使用 <code>__wrapped__</code>装饰器。 通过底层的 <code>__wrapped__</code>属性访问到函数签名信息。更多关于签名的内容可以参考9.16小节。</p>
<h1 id="93-解除一个装饰器">9.3 解除一个装饰器</h1>
<h2 id="问题">问题</h2>
<p>一个装饰器已经作用在一个函数上，你想撤销它，直接访问原始的未包装的那个函数。</p>
<h2 id="解决方案">解决方案</h2>
<p>假设装饰器是通过 <code>@wraps</code> (参考9.2小节)来实现的，那么你可以通过访问 <code>__wrapped__</code>属性来访问原始函数：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@somedecorator
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x + y
...
<span class="hljs-meta">&gt;&gt;&gt; </span>orig_add = add.__wrapped__
<span class="hljs-meta">&gt;&gt;&gt; </span>orig_add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-number">7</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>直接访问未包装的原始函数在调试、内省和其他函数操作时是很有用的。 但是我们这里的方案仅仅适用于在包装器中正确使用了<code>@wraps</code> 或者直接设置了 <code>__wrapped__</code> 属性的情况。</p>
<p>如果有多个包装器，那么访问 <code>__wrapped__</code> 属性的行为是不可预知的，应该避免这样做。 在 Python3.3 中，它会略过所有的包装层，比如，假如你有如下的代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator1</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Decorator 1'</span>)
        <span class="hljs-keyword">return</span> func(*args, **kwargs)
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator2</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Decorator 2'</span>)
        <span class="hljs-keyword">return</span> func(*args, **kwargs)
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-meta">@decorator1</span>
<span class="hljs-meta">@decorator2</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y
</code></pre>
<p>下面我们在 Python3.3 下测试：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
Decorator <span class="hljs-number">1</span>
Decorator <span class="hljs-number">2</span>
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add.__wrapped__(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-number">5</span>
&gt;&gt;&gt;
</code></pre>
<p>下面我们在 Python3.4 下测试：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
Decorator <span class="hljs-number">1</span>
Decorator <span class="hljs-number">2</span>
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add.__wrapped__(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
Decorator <span class="hljs-number">2</span>
<span class="hljs-number">5</span>
&gt;&gt;&gt;
</code></pre>
<p>最后要说的是，并不是所有的装饰器都使用了<code>@wraps</code> ，因此这里的方案并不全部适用。 特别的，内置的装饰器<code>@staticmethod</code> 和 <code>@classmethod</code>就没有遵循这个约定 (它们把原始函数存储在属性 <code>__func__</code>中)。</p>
<h1 id="94-定义一个带参数的装饰器">9.4 定义一个带参数的装饰器</h1>
<h2 id="问题">问题</h2>
<p>你想定义一个可以接受参数的装饰器</p>
<h2 id="解决方案">解决方案</h2>
<p>我们用一个例子详细阐述下接受参数的处理过程。 假设你想写一个装饰器，给函数添加日志功能，当时允许用户指定日志的级别和其他的选项。 下面是这个装饰器的定义和使用示例：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps
<span class="hljs-keyword">import</span> logging

<span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">level, name=<span class="hljs-literal">None</span>, message=<span class="hljs-literal">None</span></span>):
    <span class="hljs-string">"""
    Add logging to a function. level is the logging
    level, name is the logger name, and message is the
    log message. If name and message aren't specified,
    they default to the function's module and name.
    """</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):
        logname = name <span class="hljs-keyword">if</span> name <span class="hljs-keyword">else</span> func.__module__
        log = logging.getLogger(logname)
        logmsg = message <span class="hljs-keyword">if</span> message <span class="hljs-keyword">else</span> func.__name__

<span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
            log.log(level, logmsg)
            <span class="hljs-keyword">return</span> func(*args, **kwargs)
        <span class="hljs-keyword">return</span> wrapper
    <span class="hljs-keyword">return</span> decorate

<span class="hljs-comment"># Example use</span>
<span class="hljs-meta">@logged(<span class="hljs-params">logging.DEBUG</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y

<span class="hljs-meta">@logged(<span class="hljs-params">logging.CRITICAL, <span class="hljs-string">'example'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Spam!'</span>)
</code></pre>
<p>初看起来，这种实现看上去很复杂，但是核心思想很简单。 最外层的函数<code>logged()</code> 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数 <code>decorate()</code> 接受一个函数作为参数，然后在函数上面放置一个包装器。 这里的关键点是包装器是可以使用传递给 <code>logged()</code> 的参数的。</p>
<h2 id="讨论">讨论</h2>
<p>定义一个接受参数的包装器看上去比较复杂主要是因为底层的调用序列。特别的，如果你有下面这个代码：</p>
<pre><code class="lang-python"><span class="hljs-meta">@decorator(<span class="hljs-params">x, y, z</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>装饰器处理过程跟下面的调用是等效的;</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b</span>):
    <span class="hljs-keyword">pass</span>
func = decorator(x, y, z)(func)
</code></pre>
<p><code>decorator(x, y, z)</code>的返回结果必须是一个可调用对象，它接受一个函数作为参数并包装它， 可以参考9.7小节中另外一个可接受参数的包装器例子。</p>
<h1 id="95-可自定义属性的装饰器">9.5 可自定义属性的装饰器</h1>
<h2 id="问题">问题</h2>
<p>你想写一个装饰器来包装一个函数，并且允许用户提供参数在运行时控制装饰器行为。</p>
<h2 id="解决方案">解决方案</h2>
<p>引入一个访问函数，使用 <code>nolocal</code> 来修改内部变量。 然后这个访问函数被作为一个属性赋值给包装函数。</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps, partial
<span class="hljs-keyword">import</span> logging
<span class="hljs-comment"># Utility decorator to attach a function as an attribute of obj</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">attach_wrapper</span>(<span class="hljs-params">obj, func=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> func <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> partial(attach_wrapper, obj)
    <span class="hljs-built_in">setattr</span>(obj, func.__name__, func)
    <span class="hljs-keyword">return</span> func

<span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">level, name=<span class="hljs-literal">None</span>, message=<span class="hljs-literal">None</span></span>):
    <span class="hljs-string">'''
    Add logging to a function. level is the logging
    level, name is the logger name, and message is the
    log message. If name and message aren't specified,
    they default to the function's module and name.
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):
        logname = name <span class="hljs-keyword">if</span> name <span class="hljs-keyword">else</span> func.__module__
        log = logging.getLogger(logname)
        logmsg = message <span class="hljs-keyword">if</span> message <span class="hljs-keyword">else</span> func.__name__

<span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
            log.log(level, logmsg)
            <span class="hljs-keyword">return</span> func(*args, **kwargs)

        <span class="hljs-comment"># Attach setter functions</span>
<span class="hljs-meta">        @attach_wrapper(<span class="hljs-params">wrapper</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_level</span>(<span class="hljs-params">newlevel</span>):
            <span class="hljs-keyword">nonlocal</span> level
            level = newlevel

<span class="hljs-meta">        @attach_wrapper(<span class="hljs-params">wrapper</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_message</span>(<span class="hljs-params">newmsg</span>):
            <span class="hljs-keyword">nonlocal</span> logmsg
            logmsg = newmsg

        <span class="hljs-keyword">return</span> wrapper

    <span class="hljs-keyword">return</span> decorate

<span class="hljs-comment"># Example use</span>
<span class="hljs-meta">@logged(<span class="hljs-params">logging.DEBUG</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y

<span class="hljs-meta">@logged(<span class="hljs-params">logging.CRITICAL, <span class="hljs-string">'example'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Spam!'</span>)
</code></pre>
<p>下面是交互环境下的使用例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> logging
<span class="hljs-meta">&gt;&gt;&gt; </span>logging.basicConfig(level=logging.DEBUG)
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
DEBUG:__main__:add
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Change the log message</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add.set_message(<span class="hljs-string">'Add called'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
DEBUG:__main__:Add called
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Change the log level</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add.set_level(logging.WARNING)
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
WARNING:__main__:Add called
<span class="hljs-number">5</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>这一小节的关键点在于访问函数(如 <code>set_message()</code> 和 <code>set_level()</code> )，它们被作为属性赋给包装器。 每个访问函数允许使用 <code>nonlocal</code> 来修改函数内部的变量。</p>
<p>还有一个令人吃惊的地方是访问函数会在多层装饰器间传播(如果你的装饰器都使用了 <code>@functools.wraps</code> 注解)。 例如，假设你引入另外一个装饰器，比如9.2小节中的 <code>@timethis</code>，像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">@timethis</span>
<span class="hljs-meta">@logged(<span class="hljs-params">logging.DEBUG</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        n -= <span class="hljs-number">1</span>
</code></pre>
<p>你会发现访问函数依旧有效：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>countdown(<span class="hljs-number">10000000</span>)
DEBUG:__main__:countdown
countdown <span class="hljs-number">0.8198461532592773</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown.set_level(logging.WARNING)
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown.set_message(<span class="hljs-string">"Counting down to zero"</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>countdown(<span class="hljs-number">10000000</span>)
WARNING:__main__:Counting down to zero
countdown <span class="hljs-number">0.8225970268249512</span>
&gt;&gt;&gt;
</code></pre>
<p>你还会发现即使装饰器像下面这样以相反的方向排放，效果也是一样的：</p>
<pre><code class="lang-python"><span class="hljs-meta">@logged(<span class="hljs-params">logging.DEBUG</span>)</span>
<span class="hljs-meta">@timethis</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        n -= <span class="hljs-number">1</span>
</code></pre>
<p>还能通过使用 lambda 表达式代码来让访问函数的返回不同的设定值：</p>
<pre><code class="lang-python"><span class="hljs-meta">@attach_wrapper(<span class="hljs-params">wrapper</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_level</span>():
    <span class="hljs-keyword">return</span> level

<span class="hljs-comment"># Alternative</span>
wrapper.get_level = <span class="hljs-keyword">lambda</span>: level
</code></pre>
<p>一个比较难理解的地方就是对于访问函数的首次使用。例如，你可能会考虑另外一个方法直接访问函数的属性，如下：</p>
<pre><code class="lang-python"><span class="hljs-meta">@wraps(<span class="hljs-params">func</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
    wrapper.log.log(wrapper.level, wrapper.logmsg)
    <span class="hljs-keyword">return</span> func(*args, **kwargs)

<span class="hljs-comment"># Attach adjustable attributes</span>
wrapper.level = level
wrapper.logmsg = logmsg
wrapper.log = log
</code></pre>
<p>这个方法也可能正常工作，但前提是它必须是最外层的装饰器才行。 如果它的上面还有另外的装饰器(比如上面提到的 <code>@timethis</code> 例子)，那么它会隐藏底层属性，使得修改它们没有任何作用。 而通过使用访问函数就能避免这样的局限性。</p>
<p>最后提一点，这一小节的方案也可以作为9.9小节中装饰器类的另一种实现方法。</p>
<h1 id="96-带可选参数的装饰器">9.6 带可选参数的装饰器</h1>
<h2 id="问题">问题</h2>
<p>你想写一个装饰器，既可以不传参数给它，比如 <code>@decorator</code> ， 也可以传递可选参数给它，比如<code>@decorator(x,y,z)</code> 。</p>
<h2 id="解决方案">解决方案</h2>
<p>下面是9.5小节中日志装饰器的一个修改版本：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps, partial
<span class="hljs-keyword">import</span> logging

<span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">func=<span class="hljs-literal">None</span>, *, level=logging.DEBUG, name=<span class="hljs-literal">None</span>, message=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> func <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> partial(logged, level=level, name=name, message=message)

    logname = name <span class="hljs-keyword">if</span> name <span class="hljs-keyword">else</span> func.__module__
    log = logging.getLogger(logname)
    logmsg = message <span class="hljs-keyword">if</span> message <span class="hljs-keyword">else</span> func.__name__

<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        log.log(level, logmsg)
        <span class="hljs-keyword">return</span> func(*args, **kwargs)

    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-comment"># Example use</span>
<span class="hljs-meta">@logged</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y

<span class="hljs-meta">@logged(<span class="hljs-params">level=logging.CRITICAL, name=<span class="hljs-string">'example'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Spam!'</span>)
</code></pre>
<p>可以看到，<code>@logged</code>装饰器可以同时不带参数或带参数。</p>
<h2 id="讨论">讨论</h2>
<p>这里提到的这个问题就是通常所说的编程一致性问题。 当我们使用装饰器的时候，大部分程序员习惯了要么不给它们传递任何参数，要么给它们传递确切参数。 其实从技术上来讲，我们可以定义一个所有参数都是可选的装饰器，就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">@logged()</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x+y
</code></pre>
<p>但是，这种写法并不符合我们的习惯，有时候程序员忘记加上后面的括号会导致错误。 这里我们向你展示了如何以一致的编程风格来同时满足没有括号和有括号两种情况。</p>
<p>为了理解代码是如何工作的，你需要非常熟悉装饰器是如何作用到函数上以及它们的调用规则。 对于一个像下面这样的简单装饰器：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example use</span>
<span class="hljs-meta">@logged</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y
</code></pre>
<p>这个调用序列跟下面等价：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y

add = logged(add)
</code></pre>
<p>这时候，被装饰函数会被当做第一个参数直接传递给 <code>logged</code>装饰器。 因此，<code>logged()</code> 中的第一个参数就是被包装函数本身。所有其他参数都必须有默认值。</p>
<p>而对于一个下面这样有参数的装饰器：</p>
<pre><code class="lang-python"><span class="hljs-meta">@logged(<span class="hljs-params">level=logging.CRITICAL, name=<span class="hljs-string">'example'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Spam!'</span>)
</code></pre>
<p>调用序列跟下面等价：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Spam!'</span>)
spam = logged(level=logging.CRITICAL, name=<span class="hljs-string">'example'</span>)(spam)
</code></pre>
<p>初始调用 <code>logged()</code> 函数时，被包装函数并没有传递进来。 因此在装饰器内，它必须是可选的。这个反过来会迫使其他参数必须使用关键字来指定。 并且，但这些参数被传递进来后，装饰器要返回一个接受一个函数参数并包装它的函数(参考9.5小节)。 为了这样做，我们使用了一个技巧，就是利用 <code>functools.partial</code> 。 它会返回一个未完全初始化的自身，除了被包装函数外其他参数都已经确定下来了。 可以参考7.8小节获取更多 <code>partial()</code> 方法的知识。</p>
<h1 id="97-利用装饰器强制函数上的类型检查">9.7 利用装饰器强制函数上的类型检查</h1>
<h2 id="问题">问题</h2>
<p>作为某种编程规约，你想在对函数参数进行强制类型检查。</p>
<h2 id="解决方案">解决方案</h2>
<p>在演示实际代码前，先说明我们的目标：能对函数参数类型进行断言，类似下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@typeassert(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>)
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x + y
...
&gt;&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-string">'hello'</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"contract.py"</span>, line <span class="hljs-number">33</span>, <span class="hljs-keyword">in</span> wrapper
TypeError: Argument y must be &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>下面是使用装饰器技术来实现 <code>@typeassert</code>：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> signature
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-keyword">def</span> <span class="hljs-title function_">typeassert</span>(<span class="hljs-params">*ty_args, **ty_kwargs</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):
        <span class="hljs-comment"># If in optimized mode, disable type checking</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">__debug__</span>:
            <span class="hljs-keyword">return</span> func

        <span class="hljs-comment"># Map function argument names to supplied types</span>
        sig = signature(func)
        bound_types = sig.bind_partial(*ty_args, **ty_kwargs).arguments

<span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
            bound_values = sig.bind(*args, **kwargs)
            <span class="hljs-comment"># Enforce type assertions across supplied arguments</span>
            <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> bound_values.arguments.items():
                <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> bound_types:
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, bound_types[name]):
                        <span class="hljs-keyword">raise</span> TypeError(
                            <span class="hljs-string">'Argument {} must be {}'</span>.<span class="hljs-built_in">format</span>(name, bound_types[name])
                            )
            <span class="hljs-keyword">return</span> func(*args, **kwargs)
        <span class="hljs-keyword">return</span> wrapper
    <span class="hljs-keyword">return</span> decorate
</code></pre>
<p>可以看出这个装饰器非常灵活，既可以指定所有参数类型，也可以只指定部分。 并且可以通过位置或关键字来指定参数类型。下面是使用示例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@typeassert(<span class="hljs-built_in">int</span>, z=<span class="hljs-built_in">int</span>)
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">x, y, z=<span class="hljs-number">42</span></span>):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(x, y, z)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>spam(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>spam(<span class="hljs-number">1</span>, <span class="hljs-string">'hello'</span>, <span class="hljs-number">3</span>)
<span class="hljs-number">1</span> hello <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>spam(<span class="hljs-number">1</span>, <span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>)
Traceback (most recent call last):
File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
File <span class="hljs-string">"contract.py"</span>, line <span class="hljs-number">33</span>, <span class="hljs-keyword">in</span> wrapper
TypeError: Argument z must be &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>这节是高级装饰器示例，引入了很多重要的概念。</p>
<p>首先，装饰器只会在函数定义时被调用一次。 有时候你去掉装饰器的功能，那么你只需要简单的返回被装饰函数即可。 下面的代码中，如果全局变量　<code>__debug__</code> 被设置成了 False(当你使用-O 或-OO 参数的优化模式执行程序时)， 那么就直接返回未修改过的函数本身：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):
    <span class="hljs-comment"># If in optimized mode, disable type checking</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">__debug__</span>:
        <span class="hljs-keyword">return</span> func
</code></pre>
<p>其次，这里还对被包装函数的参数签名进行了检查，我们使用了 <code>inspect.signature()</code>函数。 简单来讲，它运行你提取一个可调用对象的参数签名信息。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> signature
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">x, y, z=<span class="hljs-number">42</span></span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span>
...
<span class="hljs-meta">&gt;&gt;&gt; </span>sig = signature(spam)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(sig)
(x, y, z=<span class="hljs-number">42</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>sig.parameters
mappingproxy(OrderedDict([(<span class="hljs-string">'x'</span>, &lt;Parameter at <span class="hljs-number">0x10077a050</span> <span class="hljs-string">'x'</span>&gt;),
(<span class="hljs-string">'y'</span>, &lt;Parameter at <span class="hljs-number">0x10077a158</span> <span class="hljs-string">'y'</span>&gt;), (<span class="hljs-string">'z'</span>, &lt;Parameter at <span class="hljs-number">0x10077a1b0</span> <span class="hljs-string">'z'</span>&gt;)]))
<span class="hljs-meta">&gt;&gt;&gt; </span>sig.parameters[<span class="hljs-string">'z'</span>].name
<span class="hljs-string">'z'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sig.parameters[<span class="hljs-string">'z'</span>].default
<span class="hljs-number">42</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sig.parameters[<span class="hljs-string">'z'</span>].kind
&lt;_ParameterKind: <span class="hljs-string">'POSITIONAL_OR_KEYWORD'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>装饰器的开始部分，我们使用了 <code>bind_partial()</code> 方法来执行从指定类型到名称的部分绑定。 下面是例子演示：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>bound_types = sig.bind_partial(<span class="hljs-built_in">int</span>,z=<span class="hljs-built_in">int</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>bound_types
&lt;inspect.BoundArguments <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10069bb50</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>bound_types.arguments
OrderedDict([(<span class="hljs-string">'x'</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;), (<span class="hljs-string">'z'</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;)])
&gt;&gt;&gt;
</code></pre>
<p>在这个部分绑定中，你可以注意到缺失的参数被忽略了(比如并没有对 y 进行绑定)。 不过最重要的是创建了一个有序字典 <code>bound_types.arguments</code>。 这个字典会将参数名以函数签名中相同顺序映射到指定的类型值上面去。 在我们的装饰器例子中，这个映射包含了我们要强制指定的类型断言。</p>
<p>在装饰器创建的实际包装函数中使用到了 <code>sig.bind()</code>方法。<code>bind()</code> 跟 <code>bind_partial()</code>类似，但是它不允许忽略任何参数。因此有了下面的结果：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>bound_values = sig.bind(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>bound_values.arguments
OrderedDict([(<span class="hljs-string">'x'</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">'y'</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">'z'</span>, <span class="hljs-number">3</span>)])
&gt;&gt;&gt;
</code></pre>
<p>使用这个映射我们可以很轻松的实现我们的强制类型检查：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> bound_values.arguments.items():
<span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> bound_types.arguments:
<span class="hljs-meta">... </span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, bound_types.arguments[name]):
<span class="hljs-meta">... </span>            <span class="hljs-keyword">raise</span> TypeError()
...
&gt;&gt;&gt;
</code></pre>
<p>不过这个方案还有点小瑕疵，它对于有默认值的参数并不适用。 比如下面的代码可以正常工作，尽管 items 的类型是错误的：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@typeassert(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">list</span>)
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x, items=<span class="hljs-literal">None</span></span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> items <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
<span class="hljs-meta">... </span>        items = []
<span class="hljs-meta">... </span>    items.append(x)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> items
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">2</span>)
[<span class="hljs-number">2</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"contract.py"</span>, line <span class="hljs-number">33</span>, <span class="hljs-keyword">in</span> wrapper
TypeError: Argument items must be &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'list'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>bar(<span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
&gt;&gt;&gt;
</code></pre>
<p>最后一点是关于适用装饰器参数和函数注解之间的争论。 例如，为什么不像下面这样写一个装饰器来查找函数中的注解呢？</p>
<pre><code class="lang-python"><span class="hljs-meta">@typeassert</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, y, z:<span class="hljs-built_in">int</span> = <span class="hljs-number">42</span></span>):
    <span class="hljs-built_in">print</span>(x,y,z)
</code></pre>
<p>一个可能的原因是如果使用了函数参数注解，那么就被限制了。 如果注解被用来做类型检查就不能做其他事情了。而且 <code>@typeassert</code> 不能再用于使用注解做其他事情的函数了。 而使用上面的装饰器参数灵活性大多了，也更加通用。</p>
<p>可以在 PEP 362 以及 <code>inspect</code> 模块中找到更多关于函数参数对象的信息。在9.16小节还有另外一个例子。</p>
<h1 id="98-将装饰器定义为类的一部分">9.8 将装饰器定义为类的一部分</h1>
<h2 id="问题">问题</h2>
<p>你想在类中定义装饰器，并将其作用在其他函数或方法上。</p>
<h2 id="解决方案">解决方案</h2>
<p>在类里面定义装饰器很简单，但是你首先要确认它的使用方式。比如到底是作为一个实例方法还是类方法。 下面我们用例子来阐述它们的不同：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-comment"># Decorator as an instance method</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator1</span>(<span class="hljs-params">self, func</span>):
<span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Decorator 1'</span>)
            <span class="hljs-keyword">return</span> func(*args, **kwargs)
        <span class="hljs-keyword">return</span> wrapper

    <span class="hljs-comment"># Decorator as a class method</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator2</span>(<span class="hljs-params">cls, func</span>):
<span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Decorator 2'</span>)
            <span class="hljs-keyword">return</span> func(*args, **kwargs)
        <span class="hljs-keyword">return</span> wrapper
</code></pre>
<p>下面是一使用例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># As an instance method</span>
a = A()
<span class="hljs-meta">@a.decorator1</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
    <span class="hljs-keyword">pass</span>
<span class="hljs-comment"># As a class method</span>
<span class="hljs-meta">@A.decorator2</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">grok</span>():
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>仔细观察可以发现一个是实例调用，一个是类调用。</p>
<h2 id="讨论">讨论</h2>
<p>在类中定义装饰器初看上去好像很奇怪，但是在标准库中有很多这样的例子。 特别的，<code>@property</code> 装饰器实际上是一个类，它里面定义了三个方法 <code>getter(), setter(), deleter() ,</code>每一个方法都是一个装饰器。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-comment"># Create a property instance</span>
    first_name = <span class="hljs-built_in">property</span>()

    <span class="hljs-comment"># Apply decorator methods</span>
<span class="hljs-meta">    @first_name.getter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._first_name

<span class="hljs-meta">    @first_name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
        <span class="hljs-variable language_">self</span>._first_name = value
</code></pre>
<p>它为什么要这么定义的主要原因是各种不同的装饰器方法会在关联的 <code>property</code>实例上操作它的状态。 因此，任何时候只要你碰到需要在装饰器中记录或绑定信息，那么这不失为一种可行方法。</p>
<p>在类中定义装饰器有个难理解的地方就是对于额外参数 <code>self</code>或 <code>cls</code> 的正确使用。 尽管最外层的装饰器函数比如 <code>decorator1()</code>或 <code>decorator2()</code>需要提供一个 <code>self</code> 或 <code>cls</code>参数， 但是在两个装饰器内部被创建的<code>wrapper()</code> 函数并不需要包含这个 <code>self</code>参数。 你唯一需要这个参数是在你确实要访问包装器中这个实例的某些部分的时候。其他情况下都不用去管它。</p>
<p>对于类里面定义的包装器还有一点比较难理解，就是在涉及到继承的时候。 例如，假设你想让在 A 中定义的装饰器作用在子类 B 中。你需要像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
<span class="hljs-meta">    @A.decorator2</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>也就是说，装饰器要被定义成类方法并且你必须显式的使用父类名去调用它。 你不能使用 <code>@B.decorator2</code>，因为在方法定义时，这个类 B 还没有被创建。</p>
<h1 id="99-将装饰器定义为类">9.9 将装饰器定义为类</h1>
<h2 id="问题">问题</h2>
<p>你想使用一个装饰器去包装函数，但是希望返回一个可调用的实例。 你需要让你的装饰器可以同时工作在类定义的内部和外部。</p>
<h2 id="解决方案">解决方案</h2>
<p>为了将装饰器定义成一个实例，你需要确保它实现了 <code>__call__()</code>和<code>__get__()</code> 方法。 例如，下面的代码定义了一个类，它在其他函数上放置一个简单的记录层：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> types
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Profiled</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):
        wraps(func)(<span class="hljs-variable language_">self</span>)
        <span class="hljs-variable language_">self</span>.ncalls = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-variable language_">self</span>.ncalls += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__wrapped__(*args, **kwargs)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> types.MethodType(<span class="hljs-variable language_">self</span>, instance)
</code></pre>
<p>你可以将它当做一个普通的装饰器来使用，在类里面或外面都可以：</p>
<pre><code class="lang-python"><span class="hljs-meta">@Profiled</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
<span class="hljs-meta">    @Profiled</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>, x)
</code></pre>
<p>在交互环境中的使用示例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
<span class="hljs-number">9</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add.ncalls
<span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-number">1</span>)
&lt;__main__.Spam <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10069e9d0</span>&gt; <span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-number">2</span>)
&lt;__main__.Spam <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10069e9d0</span>&gt; <span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-number">3</span>)
&lt;__main__.Spam <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10069e9d0</span>&gt; <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>Spam.bar.ncalls
<span class="hljs-number">3</span>
</code></pre>
<h2 id="讨论">讨论</h2>
<p>将装饰器定义成类通常是很简单的。但是这里还是有一些细节需要解释下，特别是当你想将它作用在实例方法上的时候。</p>
<p>首先，使用 <code>functools.wraps()</code>函数的作用跟之前还是一样，将被包装函数的元信息复制到可调用实例中去。</p>
<p>其次，通常很容易会忽视上面的 <code>__get__()</code> 方法。如果你忽略它，保持其他代码不变再次运行， 你会发现当你去调用被装饰实例方法时出现很奇怪的问题。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-number">3</span>)
Traceback (most recent call last):
...
TypeError: bar() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">'x'</span>
</code></pre>
<p>出错原因是当方法函数在一个类中被查找时，它们的 <code>__get__()</code> 方法依据描述器协议被调用， 在8.9小节已经讲述过描述器协议了。在这里，<code>__get__()</code>的目的是创建一个绑定方法对象 (最终会给这个方法传递 self 参数)。下面是一个例子来演示底层原理：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">grok</span>(<span class="hljs-params">self, x</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span>
...
<span class="hljs-meta">&gt;&gt;&gt; </span>grok.__get__(s, Spam)
&lt;bound method Spam.grok of &lt;__main__.Spam <span class="hljs-built_in">object</span> at <span class="hljs-number">0x100671e90</span>&gt;&gt;
&gt;&gt;&gt;
</code></pre>
<p><code>__get__()</code>方法是为了确保绑定方法对象能被正确的创建。 <code>type.MethodType()</code> 手动创建一个绑定方法来使用。只有当实例被使用的时候绑定方法才会被创建。 如果这个方法是在类上面来访问， 那么 <code>__get__()</code> 中的 instance 参数会被设置成 None 并直接返回 <code>Profiled</code>实例本身。 这样的话我们就可以提取它的 <code>ncalls</code>属性了。</p>
<p>如果你想避免一些混乱，也可以考虑另外一个使用闭包和 <code>nonlocal</code> 变量实现的装饰器，这个在9.5小节有讲到。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> types
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-keyword">def</span> <span class="hljs-title function_">profiled</span>(<span class="hljs-params">func</span>):
    ncalls = <span class="hljs-number">0</span>
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-keyword">nonlocal</span> ncalls
        ncalls += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> func(*args, **kwargs)
    wrapper.ncalls = <span class="hljs-keyword">lambda</span>: ncalls
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-comment"># Example</span>
<span class="hljs-meta">@profiled</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y
</code></pre>
<p>这个方式跟之前的效果几乎一样，除了对于 <code>ncalls</code>的访问现在是通过一个被绑定为属性的函数来实现，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
<span class="hljs-number">9</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>add.ncalls()
<span class="hljs-number">2</span>
&gt;&gt;&gt;
</code></pre>
<h1 id="910-为类和静态方法提供装饰器">9.10 为类和静态方法提供装饰器</h1>
<h2 id="问题">问题</h2>
<p>你想给类或静态方法提供装饰器。</p>
<h2 id="解决方案">解决方案</h2>
<p>给类或静态方法提供装饰器是很简单的，不过要确保装饰器在 <code>@classmethod</code>或 <code>@staticmethod</code>之前。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-comment"># A simple decorator</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">timethis</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        start = time.time()
        r = func(*args, **kwargs)
        end = time.time()
        <span class="hljs-built_in">print</span>(end-start)
        <span class="hljs-keyword">return</span> r
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-comment"># Class illustrating application of the decorator to different kinds of methods</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
<span class="hljs-meta">    @timethis</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">instance_method</span>(<span class="hljs-params">self, n</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>, n)
        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
            n -= <span class="hljs-number">1</span>

<span class="hljs-meta">    @classmethod</span>
<span class="hljs-meta">    @timethis</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">class_method</span>(<span class="hljs-params">cls, n</span>):
        <span class="hljs-built_in">print</span>(cls, n)
        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
            n -= <span class="hljs-number">1</span>

<span class="hljs-meta">    @staticmethod</span>
<span class="hljs-meta">    @timethis</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">static_method</span>(<span class="hljs-params">n</span>):
        <span class="hljs-built_in">print</span>(n)
        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
            n -= <span class="hljs-number">1</span>
</code></pre>
<p>装饰后的类和静态方法可正常工作，只不过增加了额外的计时功能：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.instance_method(<span class="hljs-number">1000000</span>)
&lt;__main__.Spam <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a6050</span>&gt; <span class="hljs-number">1000000</span>
<span class="hljs-number">0.11817407608032227</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>Spam.class_method(<span class="hljs-number">1000000</span>)
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.Spam'</span>&gt; <span class="hljs-number">1000000</span>
<span class="hljs-number">0.11334395408630371</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>Spam.static_method(<span class="hljs-number">1000000</span>)
<span class="hljs-number">1000000</span>
<span class="hljs-number">0.11740279197692871</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>如果你把装饰器的顺序写错了就会出错。例如，假设你像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
<span class="hljs-meta">    @timethis</span>
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">static_method</span>(<span class="hljs-params">n</span>):
        <span class="hljs-built_in">print</span>(n)
        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
            n -= <span class="hljs-number">1</span>
</code></pre>
<p>那么你调用这个镜头方法时就会报错：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>Spam.static_method(<span class="hljs-number">1000000</span>)
Traceback (most recent call last):
File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
File <span class="hljs-string">"timethis.py"</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> wrapper
start = time.time()
TypeError: <span class="hljs-string">'staticmethod'</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span>
&gt;&gt;&gt;
</code></pre>
<p>问题在于 <code>@classmethod</code> 和 <code>@staticmethod</code>实际上并不会创建可直接调用的对象， 而是创建特殊的描述器对象(参考8.9小节)。因此当你试着在其他装饰器中将它们当做函数来使用时就会出错。 确保这种装饰器出现在装饰器链中的第一个位置可以修复这个问题。</p>
<p>当我们在抽象基类中定义类方法和静态方法(参考8.12小节)时，这里讲到的知识就很有用了。 例如，如果你想定义一个抽象类方法，可以使用类似下面的代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(metaclass=ABCMeta):
<span class="hljs-meta">    @classmethod</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method</span>(<span class="hljs-params">cls</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>在这段代码中，<code>@classmethod</code>跟 <code>@abstractmethod</code>两者的顺序是有讲究的，如果你调换它们的顺序就会出错。</p>
<h1 id="911-装饰器为被包装函数增加参数">9.11 装饰器为被包装函数增加参数</h1>
<h2 id="问题">问题</h2>
<p>你想在装饰器中给被包装函数增加额外的参数，但是不能影响这个函数现有的调用规则。</p>
<h2 id="解决方案">解决方案</h2>
<p>可以使用关键字参数来给被包装函数增加额外参数。考虑下面的装饰器：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps

<span class="hljs-keyword">def</span> <span class="hljs-title function_">optional_debug</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, debug=<span class="hljs-literal">False</span>, **kwargs</span>):
        <span class="hljs-keyword">if</span> debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Calling'</span>, func.__name__)
        <span class="hljs-keyword">return</span> func(*args, **kwargs)

    <span class="hljs-keyword">return</span> wrapper
</code></pre>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@optional_debug
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">a,b,c</span>):
<span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(a,b,c)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>spam(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>spam(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, debug=<span class="hljs-literal">True</span>)
Calling spam
<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>通过装饰器来给被包装函数增加参数的做法并不常见。 尽管如此，有时候它可以避免一些重复代码。例如，如果你有下面这样的代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">x, debug=<span class="hljs-literal">False</span></span>):
    <span class="hljs-keyword">if</span> debug:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Calling a'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">x, y, z, debug=<span class="hljs-literal">False</span></span>):
    <span class="hljs-keyword">if</span> debug:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Calling b'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">x, y, debug=<span class="hljs-literal">False</span></span>):
    <span class="hljs-keyword">if</span> debug:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Calling c'</span>)
</code></pre>
<p>那么你可以将其重构成这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps
<span class="hljs-keyword">import</span> inspect

<span class="hljs-keyword">def</span> <span class="hljs-title function_">optional_debug</span>(<span class="hljs-params">func</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-string">'debug'</span> <span class="hljs-keyword">in</span> inspect.getargspec(func).args:
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'debug argument already defined'</span>)

<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, debug=<span class="hljs-literal">False</span>, **kwargs</span>):
        <span class="hljs-keyword">if</span> debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Calling'</span>, func.__name__)
        <span class="hljs-keyword">return</span> func(*args, **kwargs)
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-meta">@optional_debug</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">x</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-meta">@optional_debug</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">x, y, z</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-meta">@optional_debug</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>这种实现方案之所以行得通，在于强制关键字参数很容易被添加到接受 <code>*args</code> 和 <code>**kwargs</code> 参数的函数中。 通过使用强制关键字参数，它被作为一个特殊情况被挑选出来， 并且接下来仅仅使用剩余的位置和关键字参数去调用这个函数时，这个特殊参数会被排除在外。 也就是说，它并不会被纳入到<code>**kwargs</code>中去。</p>
<p>还有一个难点就是如何去处理被添加的参数与被包装函数参数直接的名字冲突。 例如，如果装饰器 <code>@optional_debug</code> 作用在一个已经拥有一个 <code>debug</code> 参数的函数上时会有问题。 这里我们增加了一步名字检查。</p>
<p>上面的方案还可以更完美一点，因为精明的程序员应该发现了被包装函数的函数签名其实是错误的。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@optional_debug
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x+y
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> inspect
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(inspect.signature(add))
(x, y)
&gt;&gt;&gt;
</code></pre>
<p>通过如下的修改，可以解决这个问题：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps
<span class="hljs-keyword">import</span> inspect

<span class="hljs-keyword">def</span> <span class="hljs-title function_">optional_debug</span>(<span class="hljs-params">func</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-string">'debug'</span> <span class="hljs-keyword">in</span> inspect.getargspec(func).args:
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'debug argument already defined'</span>)

<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, debug=<span class="hljs-literal">False</span>, **kwargs</span>):
        <span class="hljs-keyword">if</span> debug:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Calling'</span>, func.__name__)
        <span class="hljs-keyword">return</span> func(*args, **kwargs)

    sig = inspect.signature(func)
    parms = <span class="hljs-built_in">list</span>(sig.parameters.values())
    parms.append(inspect.Parameter(<span class="hljs-string">'debug'</span>,
                inspect.Parameter.KEYWORD_ONLY,
                default=<span class="hljs-literal">False</span>))
    wrapper.__signature__ = sig.replace(parameters=parms)
    <span class="hljs-keyword">return</span> wrapper
</code></pre>
<p>通过这样的修改，包装后的函数签名就能正确的显示 <code>debug</code> 参数的存在了。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>@optional_debug
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x+y
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(inspect.signature(add))
(x, y, *, debug=<span class="hljs-literal">False</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-number">5</span>
&gt;&gt;&gt;
</code></pre>
<p>参考9.16小节获取更多关于函数签名的信息。</p>
<h1 id="912-使用装饰器扩充类的功能">9.12 使用装饰器扩充类的功能</h1>
<h2 id="问题">问题</h2>
<p>你想通过反省或者重写类定义的某部分来修改它的行为，但是你又不希望使用继承或元类的方式。</p>
<h2 id="解决方案">解决方案</h2>
<p>这种情况可能是类装饰器最好的使用场景了。例如，下面是一个重写了特殊方法 <code>__getattribute__</code>的类装饰器， 可以打印日志：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">log_getattribute</span>(<span class="hljs-params">cls</span>):
    <span class="hljs-comment"># Get the original implementation</span>
    orig_getattribute = cls.__getattribute__

    <span class="hljs-comment"># Make a new definition</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_getattribute</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'getting:'</span>, name)
        <span class="hljs-keyword">return</span> orig_getattribute(<span class="hljs-variable language_">self</span>, name)

    <span class="hljs-comment"># Attach to the class and return</span>
    cls.__getattribute__ = new_getattribute
    <span class="hljs-keyword">return</span> cls

<span class="hljs-comment"># Example use</span>
<span class="hljs-meta">@log_getattribute</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,x</span>):
        <span class="hljs-variable language_">self</span>.x = x
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>下面是使用效果：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = A(<span class="hljs-number">42</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a.x
getting: x
<span class="hljs-number">42</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.spam()
getting: spam
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>类装饰器通常可以作为其他高级技术比如混入或元类的一种非常简洁的替代方案。 比如，上面示例中的另外一种实现使用到继承：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggedGetattribute</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'getting:'</span>, name)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getattribute__(name)

<span class="hljs-comment"># Example:</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">LoggedGetattribute</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,x</span>):
        <span class="hljs-variable language_">self</span>.x = x
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>这种方案也行得通，但是为了去理解它，你就必须知道方法调用顺序、<code>super()</code> 以及其它8.7小节介绍的继承知识。 某种程度上来讲，类装饰器方案就显得更加直观，并且它不会引入新的继承体系。它的运行速度也更快一些， 因为他并不依赖 <code>super()</code>函数。</p>
<p>如果你系想在一个类上面使用多个类装饰器，那么就需要注意下顺序问题。 例如，一个装饰器 A 会将其装饰的方法完整替换成另一种实现， 而另一个装饰器 B 只是简单的在其装饰的方法中添加点额外逻辑。 那么这时候装饰器A就需要放在装饰器 B 的前面。</p>
<p>你还可以回顾一下8.13小节另外一个关于类装饰器的有用的例子。</p>
<h1 id="913-使用元类控制实例的创建">9.13 使用元类控制实例的创建</h1>
<h2 id="问题">问题</h2>
<p>你想通过改变实例创建方式来实现单例、缓存或其他类似的特性。</p>
<h2 id="解决方案">解决方案</h2>
<p>Python 程序员都知道，如果你定义了一个类，就能像函数一样的调用它来创建实例，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

a = Spam(<span class="hljs-string">'Guido'</span>)
b = Spam(<span class="hljs-string">'Diana'</span>)
</code></pre>
<p>如果你想自定义这个步骤，你可以定义一个元类并自己实现 <code>__call__()</code> 方法。</p>
<p>为了演示，假设你不想任何人创建这个类的实例：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoInstances</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">"Can't instantiate directly"</span>)

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(metaclass=NoInstances):
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">grok</span>(<span class="hljs-params">x</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Spam.grok'</span>)
</code></pre>
<p>这样的话，用户只能调用这个类的静态方法，而不能使用通常的方法来创建它的实例。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>Spam.grok(<span class="hljs-number">42</span>)
Spam.grok
<span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam()
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example1.py"</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> __call__
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">"Can't instantiate directly"</span>)
TypeError: Can<span class="hljs-string">'t instantiate directly
&gt;&gt;&gt;
</span></code></pre>
<p>现在，假如你想实现单例模式（只能创建唯一实例的类），实现起来也很简单：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-variable language_">self</span>.__instance = <span class="hljs-literal">None</span>
        <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.__instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-variable language_">self</span>.__instance = <span class="hljs-built_in">super</span>().__call__(*args, **kwargs)
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__instance
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__instance

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(metaclass=Singleton):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Creating Spam'</span>)
</code></pre>
<p>那么 Spam 类就只能创建唯一的实例了，演示如下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Spam()
Creating Spam
<span class="hljs-meta">&gt;&gt;&gt; </span>b = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> c
<span class="hljs-literal">True</span>
&gt;&gt;&gt;
</code></pre>
<p>最后，假设你想创建8.25小节中那样的缓存实例。下面我们可以通过元类来实现：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> weakref

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cached</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
        <span class="hljs-variable language_">self</span>.__cache = weakref.WeakValueDictionary()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args</span>):
        <span class="hljs-keyword">if</span> args <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.__cache:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__cache[args]
        <span class="hljs-keyword">else</span>:
            obj = <span class="hljs-built_in">super</span>().__call__(*args)
            <span class="hljs-variable language_">self</span>.__cache[args] = obj
            <span class="hljs-keyword">return</span> obj

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(metaclass=Cached):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Creating Spam({!r})'</span>.<span class="hljs-built_in">format</span>(name))
        <span class="hljs-variable language_">self</span>.name = name
</code></pre>
<p>然后我也来测试一下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Spam(<span class="hljs-string">'Guido'</span>)
Creating Spam(<span class="hljs-string">'Guido'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b = Spam(<span class="hljs-string">'Diana'</span>)
Creating Spam(<span class="hljs-string">'Diana'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c = Spam(<span class="hljs-string">'Guido'</span>) <span class="hljs-comment"># Cached</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> c <span class="hljs-comment"># Cached value returned</span>
<span class="hljs-literal">True</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>利用元类实现多种实例创建模式通常要比不使用元类的方式优雅得多。</p>
<p>假设你不使用元类，你可能需要将类隐藏在某些工厂函数后面。 比如为了实现一个单例，你你可能会像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Spam</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Creating Spam'</span>)

_spam_instance = <span class="hljs-literal">None</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">Spam</span>():
    <span class="hljs-keyword">global</span> _spam_instance

    <span class="hljs-keyword">if</span> _spam_instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> _spam_instance
    <span class="hljs-keyword">else</span>:
        _spam_instance = _Spam()
        <span class="hljs-keyword">return</span> _spam_instance
</code></pre>
<p>尽管使用元类可能会涉及到比较高级点的技术，但是它的代码看起来会更加简洁舒服，而且也更加直观。</p>
<p>更多关于创建缓存实例、弱引用等内容，请参考8.25小节。</p>
<h1 id="914-捕获类的属性定义顺序">9.14 捕获类的属性定义顺序</h1>
<h2 id="问题">问题</h2>
<p>你想自动记录一个类中属性和方法定义的顺序， 然后可以利用它来做很多操作（比如序列化、映射到数据库等等）。</p>
<h2 id="解决方案">解决方案</h2>
<p>利用元类可以很容易的捕获类的定义信息。下面是一个例子，使用了一个 OrderedDict 来记录描述器的定义顺序：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict

<span class="hljs-comment"># A set of descriptors for various types</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Typed</span>:
    _expected_type = <span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-literal">None</span></span>):
        <span class="hljs-variable language_">self</span>._name = name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-variable language_">self</span>._expected_type):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>._expected_type))
        instance.__dict__[<span class="hljs-variable language_">self</span>._name] = value

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-title class_ inherited__">Typed</span>):
    _expected_type = <span class="hljs-built_in">int</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Float</span>(<span class="hljs-title class_ inherited__">Typed</span>):
    _expected_type = <span class="hljs-built_in">float</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>(<span class="hljs-title class_ inherited__">Typed</span>):
    _expected_type = <span class="hljs-built_in">str</span>

<span class="hljs-comment"># Metaclass that uses an OrderedDict for class body</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderedMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, clsname, bases, clsdict</span>):
        d = <span class="hljs-built_in">dict</span>(clsdict)
        order = []
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> clsdict.items():
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, Typed):
                value._name = name
                order.append(name)
        d[<span class="hljs-string">'_order'</span>] = order
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, clsname, bases, d)

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__prepare__</span>(<span class="hljs-params">cls, clsname, bases</span>):
        <span class="hljs-keyword">return</span> OrderedDict()
</code></pre>
<p>在这个元类中，执行类主体时描述器的定义顺序会被一个<code>OrderedDict</code>捕获到， 生成的有序名称从字典中提取出来并放入类属性 <code>_order</code>中。这样的话类中的方法可以通过多种方式来使用它。 例如，下面是一个简单的类，使用这个排序字典来实现将一个类实例的数据序列化为一行 CSV 数据：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure</span>(metaclass=OrderedMeta):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">as_csv</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">','</span>.join(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>,name)) <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._order)

<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    name = String()
    shares = Integer()
    price = Float()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, shares, price</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.shares = shares
        <span class="hljs-variable language_">self</span>.price = price
</code></pre>
<p>我们在交互式环境中测试一下这个 Stock 类：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Stock(<span class="hljs-string">'GOOG'</span>,<span class="hljs-number">100</span>,<span class="hljs-number">490.1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name
<span class="hljs-string">'GOOG'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.as_csv()
<span class="hljs-string">'GOOG,100,490.1'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>t = Stock(<span class="hljs-string">'AAPL'</span>,<span class="hljs-string">'a lot'</span>, <span class="hljs-number">610.23</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"dupmethod.py"</span>, line <span class="hljs-number">34</span>, <span class="hljs-keyword">in</span> __init__
TypeError: shares expects &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>本节一个关键点就是 OrderedMeta 元类中定义的 <code>__prepare__()</code> 方法。 这个方法会在开始定义类和它的父类的时候被执行。它必须返回一个映射对象以便在类定义体中被使用到。 我们这里通过返回了一个 OrderedDict 而不是一个普通的字典，可以很容易的捕获定义的顺序。</p>
<p>如果你想构造自己的类字典对象，可以很容易的扩展这个功能。比如，下面的这个修改方案可以防止重复的定义：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDupOrderedDict</span>(<span class="hljs-title class_ inherited__">OrderedDict</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clsname</span>):
        <span class="hljs-variable language_">self</span>.clsname = clsname
        <span class="hljs-built_in">super</span>().__init__()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, name, value</span>):
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>:
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'{} already defined in {}'</span>.<span class="hljs-built_in">format</span>(name, <span class="hljs-variable language_">self</span>.clsname))
        <span class="hljs-built_in">super</span>().__setitem__(name, value)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderedMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, clsname, bases, clsdict</span>):
        d = <span class="hljs-built_in">dict</span>(clsdict)
        d[<span class="hljs-string">'_order'</span>] = [name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> clsdict <span class="hljs-keyword">if</span> name[<span class="hljs-number">0</span>] != <span class="hljs-string">'_'</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, clsname, bases, d)

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__prepare__</span>(<span class="hljs-params">cls, clsname, bases</span>):
        <span class="hljs-keyword">return</span> NoDupOrderedDict(clsname)
</code></pre>
<p>下面我们测试重复的定义会出现什么情况：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(metaclass=OrderedMeta):
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
<span class="hljs-meta">... </span><span class="hljs-keyword">pass</span>
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
<span class="hljs-meta">... </span><span class="hljs-keyword">pass</span>
...
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> A
    File <span class="hljs-string">"dupmethod2.py"</span>, line <span class="hljs-number">25</span>, <span class="hljs-keyword">in</span> __setitem__
        (name, <span class="hljs-variable language_">self</span>.clsname))
TypeError: spam already defined <span class="hljs-keyword">in</span> A
&gt;&gt;&gt;
</code></pre>
<p>最后还有一点很重要，就是在 <code>__new__()</code>方法中对于元类中被修改字典的处理。 尽管类使用了另外一个字典来定义，在构造最终的<code>class</code>对象的时候， 我们仍然需要将这个字典转换为一个正确的 <code>dict</code>实例。 通过语句 <code>d = dict(clsdict)</code> 来完成这个效果。</p>
<p>对于很多应用程序而已，能够捕获类定义的顺序是一个看似不起眼却又非常重要的特性。 例如，在对象关系映射中，我们通常会看到下面这种方式定义的类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Model</span>):
    name = String()
    shares = Integer()
    price = Float()
</code></pre>
<p>在框架底层，我们必须捕获定义的顺序来将对象映射到元组或数据库表中的行（就类似于上面例子中的 <code>as_csv()</code>的功能）。 这节演示的技术非常简单，并且通常会比其他类似方法（通常都要在描述器类中维护一个隐藏的计数器）要简单的多。</p>
<h1 id="915-定义有可选参数的元类">9.15 定义有可选参数的元类</h1>
<h2 id="问题">问题</h2>
<p>你想定义一个元类，允许类定义时提供可选参数，这样可以控制或配置类型的创建过程。</p>
<h2 id="解决方案">解决方案</h2>
<p>在定义类的时候，Python 允许我们使用 <code>metaclass</code>关键字参数来指定特定的元类。 例如使用抽象基类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod
<span class="hljs-keyword">class</span> <span class="hljs-title class_">IStream</span>(metaclass=ABCMeta):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, maxsize=<span class="hljs-literal">None</span></span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>然而，在自定义元类中我们还可以提供其他的关键字参数，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(metaclass=MyMeta, debug=<span class="hljs-literal">True</span>, synchronize=<span class="hljs-literal">True</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>为了使元类支持这些关键字参数，你必须确保在 <code>__prepare__()</code>, <code>__new__()</code> 和 <code>__init__()</code> 方法中 都使用强制关键字参数。就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-comment"># Optional</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__prepare__</span>(<span class="hljs-params">cls, name, bases, *, debug=<span class="hljs-literal">False</span>, synchronize=<span class="hljs-literal">False</span></span>):
        <span class="hljs-comment"># Custom processing</span>
        <span class="hljs-keyword">pass</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__prepare__(name, bases)

    <span class="hljs-comment"># Required</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, ns, *, debug=<span class="hljs-literal">False</span>, synchronize=<span class="hljs-literal">False</span></span>):
        <span class="hljs-comment"># Custom processing</span>
        <span class="hljs-keyword">pass</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, ns)

    <span class="hljs-comment"># Required</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, bases, ns, *, debug=<span class="hljs-literal">False</span>, synchronize=<span class="hljs-literal">False</span></span>):
        <span class="hljs-comment"># Custom processing</span>
        <span class="hljs-keyword">pass</span>
        <span class="hljs-built_in">super</span>().__init__(name, bases, ns)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>给一个元类添加可选关键字参数需要你完全弄懂类创建的所有步骤， 因为这些参数会被传递给每一个相关的方法。 <code>__prepare__()</code> 方法在所有类定义开始执行前首先被调用，用来创建类命名空间。 通常来讲，这个方法只是简单的返回一个字典或其他映射对象。 <code>__new__()</code> 方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。 <code>__init__()</code>方法最后被调用，用来执行其他的一些初始化工作。</p>
<p>当我们构造元类的时候，通常只需要定义一个 <code>__new__()</code> 或 <code>__init__()</code> 方法，但不是两个都定义。 但是，如果需要接受其他的关键字参数的话，这两个方法就要同时提供，并且都要提供对应的参数签名。 默认的<code>__prepare__()</code> 方法接受任意的关键字参数，但是会忽略它们， 所以只有当这些额外的参数可能会影响到类命名空间的创建时你才需要去定义 <code>__prepare__()</code>方法。</p>
<p>通过使用强制关键字参数，在类的创建过程中我们必须通过关键字来指定这些参数。</p>
<p>使用关键字参数配置一个元类还可以视作对类变量的一种替代方式。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(metaclass=MyMeta):
    debug = <span class="hljs-literal">True</span>
    synchronize = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>将这些属性定义为参数的好处在于它们不会污染类的名称空间， 这些属性仅仅只从属于类的创建阶段，而不是类中的语句执行阶段。 另外，它们在<code>__prepare__()</code> 方法中是可以被访问的，因为这个方法会在所有类主体执行前被执行。 但是类变量只能在元类的 <code>__new__()</code>和<code>__init__()</code> 方法中可见。</p>
<h1 id="916-args和kwargs的强制参数签名">9.16 <em>args和*</em>kwargs的强制参数签名</h1>
<h2 id="问题">问题</h2>
<p>你有一个函数或方法，它使用 <em>args 和 *</em>kwargs 作为参数，这样使得它比较通用， 但有时候你想检查传递进来的参数是不是某个你想要的类型。</p>
<h2 id="解决方案">解决方案</h2>
<p>对任何涉及到操作函数调用签名的问题，你都应该使用 <code>inspect</code> 模块中的签名特性。 我们最主要关注两个类：<code>Signature</code> 和 <code>Parameter</code> 。下面是一个创建函数前面的交互例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> Signature, Parameter
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Make a signature for a func(x, y=42, *, z=None)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>parms = [ Parameter(<span class="hljs-string">'x'</span>, Parameter.POSITIONAL_OR_KEYWORD),
<span class="hljs-meta">... </span>        Parameter(<span class="hljs-string">'y'</span>, Parameter.POSITIONAL_OR_KEYWORD, default=<span class="hljs-number">42</span>),
<span class="hljs-meta">... </span>        Parameter(<span class="hljs-string">'z'</span>, Parameter.KEYWORD_ONLY, default=<span class="hljs-literal">None</span>) ]
<span class="hljs-meta">&gt;&gt;&gt; </span>sig = Signature(parms)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(sig)
(x, y=<span class="hljs-number">42</span>, *, z=<span class="hljs-literal">None</span>)
&gt;&gt;&gt;
</code></pre>
<p>一旦你有了一个签名对象，你就可以使用它的 <code>bind()</code> 方法很容易的将它绑定到 <code>*args</code>和 <code>**kwargs</code>上去。 下面是一个简单的演示：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">*args, **kwargs</span>):
<span class="hljs-meta">... </span>    bound_values = sig.bind(*args, **kwargs)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> bound_values.arguments.items():
<span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(name,value)
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Try various examples</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, z=<span class="hljs-number">3</span>)
x <span class="hljs-number">1</span>
y <span class="hljs-number">2</span>
z <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>func(<span class="hljs-number">1</span>)
x <span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>func(<span class="hljs-number">1</span>, z=<span class="hljs-number">3</span>)
x <span class="hljs-number">1</span>
z <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>func(y=<span class="hljs-number">2</span>, x=<span class="hljs-number">1</span>)
x <span class="hljs-number">1</span>
y <span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
Traceback (most recent call last):
...
    File <span class="hljs-string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="hljs-number">1972</span>, <span class="hljs-keyword">in</span> _bind
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'too many positional arguments'</span>)
TypeError: too many positional arguments
<span class="hljs-meta">&gt;&gt;&gt; </span>func(y=<span class="hljs-number">2</span>)
Traceback (most recent call last):
...
    File <span class="hljs-string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="hljs-number">1961</span>, <span class="hljs-keyword">in</span> _bind
        <span class="hljs-keyword">raise</span> TypeError(msg) <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span>
TypeError: <span class="hljs-string">'x'</span> parameter lacking default value
<span class="hljs-meta">&gt;&gt;&gt; </span>func(<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>, x=<span class="hljs-number">3</span>)
Traceback (most recent call last):
...
    File <span class="hljs-string">"/usr/local/lib/python3.3/inspect.py"</span>, line <span class="hljs-number">1985</span>, <span class="hljs-keyword">in</span> _bind
        <span class="hljs-string">'{arg!r}'</span>.<span class="hljs-built_in">format</span>(arg=param.name))
TypeError: multiple values <span class="hljs-keyword">for</span> argument <span class="hljs-string">'x'</span>
&gt;&gt;&gt;
</code></pre>
<p>可以看出来，通过将签名和传递的参数绑定起来，可以强制函数调用遵循特定的规则，比如必填、默认、重复等等。</p>
<p>下面是一个强制函数签名更具体的例子。在代码中，我们在基类中先定义了一个非常通用的<code>__init__()</code>方法， 然后我们强制所有的子类必须提供一个特定的参数签名。</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> Signature, Parameter

<span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sig</span>(<span class="hljs-params">*names</span>):
    parms = [Parameter(name, Parameter.POSITIONAL_OR_KEYWORD)
            <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names]
    <span class="hljs-keyword">return</span> Signature(parms)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure</span>:
    __signature__ = make_sig()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        bound_values = <span class="hljs-variable language_">self</span>.__signature__.bind(*args, **kwargs)
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> bound_values.arguments.items():
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, value)

<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    __signature__ = make_sig(<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    __signature__ = make_sig(<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>)
</code></pre>
<p>下面是使用这个 <code>Stock</code>类的示例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> inspect
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(inspect.signature(Stock))
(name, shares, price)
<span class="hljs-meta">&gt;&gt;&gt; </span>s1 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">490.1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s2 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">100</span>)
Traceback (most recent call last):
...
TypeError: <span class="hljs-string">'price'</span> parameter lacking default value
<span class="hljs-meta">&gt;&gt;&gt; </span>s3 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">490.1</span>, shares=<span class="hljs-number">50</span>)
Traceback (most recent call last):
...
TypeError: multiple values <span class="hljs-keyword">for</span> argument <span class="hljs-string">'shares'</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>在我们需要构建通用函数库、编写装饰器或实现代理的时候，对于 <code>*args</code>和 <code>**kwargs</code> 的使用是很普遍的。 但是，这样的函数有一个缺点就是当你想要实现自己的参数检验时，代码就会笨拙混乱。在8.11小节里面有这样一个例子。 这时候我们可以通过一个签名对象来简化它。</p>
<p>在最后的一个方案实例中，我们还可以通过使用自定义元类来创建签名对象。下面演示怎样来实现：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> Signature, Parameter

<span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sig</span>(<span class="hljs-params">*names</span>):
    parms = [Parameter(name, Parameter.POSITIONAL_OR_KEYWORD)
            <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names]
    <span class="hljs-keyword">return</span> Signature(parms)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StructureMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, clsname, bases, clsdict</span>):
        clsdict[<span class="hljs-string">'__signature__'</span>] = make_sig(*clsdict.get(<span class="hljs-string">'_fields'</span>,[]))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, clsname, bases, clsdict)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure</span>(metaclass=StructureMeta):
    _fields = []
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        bound_values = <span class="hljs-variable language_">self</span>.__signature__.bind(*args, **kwargs)
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> bound_values.arguments.items():
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, value)

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields = [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]
</code></pre>
<p>当我们自定义签名的时候，将签名存储在特定的属性 <code>__signature__</code>中通常是很有用的。 这样的话，在使用 <code>inspect</code>模块执行内省的代码就能发现签名并将它作为调用约定。</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> inspect
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(inspect.signature(Stock))
(name, shares, price)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(inspect.signature(Point))
(x, y)
&gt;&gt;&gt;
</code></pre>
<h1 id="917-在类上强制使用编程规约">9.17 在类上强制使用编程规约</h1>
<h2 id="问题">问题</h2>
<p>你的程序包含一个很大的类继承体系，你希望强制执行某些编程规约（或者代码诊断）来帮助程序员保持清醒。</p>
<h2 id="解决方案">解决方案</h2>
<p>如果你想监控类的定义，通常可以通过定义一个元类。一个基本元类通常是继承自<code>type</code> 并重定义它的<code>__new__()</code> 方法 或者是 <code>__init__()</code>方法。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">self, clsname, bases, clsdict</span>):
        <span class="hljs-comment"># clsname is name of class being defined</span>
        <span class="hljs-comment"># bases is tuple of base classes</span>
        <span class="hljs-comment"># clsdict is class dictionary</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, clsname, bases, clsdict)
</code></pre>
<p>另一种是，定义 <code>__init__()</code> 方法：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clsname, bases, clsdict</span>):
        <span class="hljs-built_in">super</span>().__init__(clsname, bases, clsdict)
        <span class="hljs-comment"># clsname is name of class being defined</span>
        <span class="hljs-comment"># bases is tuple of base classes</span>
        <span class="hljs-comment"># clsdict is class dictionary</span>
</code></pre>
<p>为了使用这个元类，你通常要将它放到到一个顶级父类定义中，然后其他的类继承这个顶级父类。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Root</span>(metaclass=MyMeta):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Root</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">Root</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>元类的一个关键特点是它允许你在定义的时候检查类的内容。在重新定义 <code>__init__()</code> 方法中， 你可以很轻松的检查类字典、父类等等。并且，一旦某个元类被指定给了某个类，那么就会被继承到所有子类中去。 因此，一个框架的构建者就能在大型的继承体系中通过给一个顶级父类指定一个元类去捕获所有下面子类的定义。</p>
<p>作为一个具体的应用例子，下面定义了一个元类，它会拒绝任何有混合大小写名字作为方法的类定义（可能是想气死Java程序员^_^）：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoMixedCaseMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, clsname, bases, clsdict</span>):
        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> clsdict:
            <span class="hljs-keyword">if</span> name.lower() != name:
                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Bad attribute name: '</span> + name)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, clsname, bases, clsdict)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Root</span>(metaclass=NoMixedCaseMeta):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Root</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo_bar</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># Ok</span>
        <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">Root</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fooBar</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># TypeError</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>作为更高级和实用的例子，下面有一个元类，它用来检测重载方法，确保它的调用参数跟父类中原始方法有着相同的参数签名。</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> signature
<span class="hljs-keyword">import</span> logging

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchSignaturesMeta</span>(<span class="hljs-title class_ inherited__">type</span>):

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clsname, bases, clsdict</span>):
        <span class="hljs-built_in">super</span>().__init__(clsname, bases, clsdict)
        sup = <span class="hljs-built_in">super</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-variable language_">self</span>)
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> clsdict.items():
            <span class="hljs-keyword">if</span> name.startswith(<span class="hljs-string">'_'</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span>(value):
                <span class="hljs-keyword">continue</span>
            <span class="hljs-comment"># Get the previous definition (if any) and compare the signatures</span>
            prev_dfn = <span class="hljs-built_in">getattr</span>(sup,name,<span class="hljs-literal">None</span>)
            <span class="hljs-keyword">if</span> prev_dfn:
                prev_sig = signature(prev_dfn)
                val_sig = signature(value)
                <span class="hljs-keyword">if</span> prev_sig != val_sig:
                    logging.warning(<span class="hljs-string">'Signature mismatch in %s. %s != %s'</span>,
                                    value.__qualname__, prev_sig, val_sig)

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Root</span>(metaclass=MatchSignaturesMeta):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Root</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self, x, *, z</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># Class with redefined methods, but slightly different signatures</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self, a, b</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self,x,z</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>如果你运行这段代码，就会得到下面这样的输出结果：</p>
<pre><code class="lang-python">WARNING:root:Signature mismatch <span class="hljs-keyword">in</span> B.spam. (<span class="hljs-variable language_">self</span>, x, *, z) != (<span class="hljs-variable language_">self</span>, x, z)
WARNING:root:Signature mismatch <span class="hljs-keyword">in</span> B.foo. (<span class="hljs-variable language_">self</span>, x, y) != (<span class="hljs-variable language_">self</span>, a, b)
</code></pre>
<p>这种警告信息对于捕获一些微妙的程序 bug 是很有用的。例如，如果某个代码依赖于传递给方法的关键字参数， 那么当子类改变参数名字的时候就会调用出错。</p>
<h2 id="讨论">讨论</h2>
<p>在大型面向对象的程序中，通常将类的定义放在元类中控制是很有用的。 元类可以监控类的定义，警告编程人员某些没有注意到的可能出现的问题。</p>
<p>有人可能会说，像这样的错误可以通过程序分析工具或 IDE 去做会更好些。诚然，这些工具是很有用。 但是，如果你在构建一个框架或函数库供其他人使用，那么你没办法去控制使用者要使用什么工具。 因此，对于这种类型的程序，如果可以在元类中做检测或许可以带来更好的用户体验。</p>
<p>在元类中选择重新定义 <code>__new__()</code>方法还是 <code>__init__()</code> 方法取决于你想怎样使用结果类。 <code>__new__()</code>方法在类创建之前被调用，通常用于通过某种方式（比如通过改变类字典的内容）修改类的定义。 而 <code>__init__()</code>方法是在类被创建之后被调用，当你需要完整构建类对象的时候会很有用。 在最后一个例子中，这是必要的，因为它使用了 <code>super()</code>函数来搜索之前的定义。 它只能在类的实例被创建之后，并且相应的方法解析顺序也已经被设置好了。</p>
<p>最后一个例子还演示了 Python 的函数签名对象的使用。 实际上，元类会管理中每个一个调用定义，搜索前一个定义（如果有的话）， 然后通过使用 <code>inspect.signature()</code>来简单的比较它们的调用签名。</p>
<p>最后一点，代码中有一行使用了 <code>super(self, self)</code>并不是排版错误。 当使用元类的时候，我们要时刻记住一点就是<code>self</code>实际上是一个类对象。 因此，这条语句其实就是用来寻找位于继承体系中构建 <code>self</code>父类的定义。</p>
<h1 id="918-以编程方式定义类">9.18 以编程方式定义类</h1>
<h2 id="问题">问题</h2>
<p>你在写一段代码，最终需要创建一个新的类对象。你考虑将类的定义源代码以字符串的形式发布出去。 并且使用函数比如 <code>exec()</code>来执行它，但是你想寻找一个更加优雅的解决方案。</p>
<h2 id="解决方案">解决方案</h2>
<p>你可以使用函数 <code>types.new_class()</code> 来初始化新的类对象。 你需要做的只是提供类的名字、父类元组、关键字参数，以及一个用成员变量填充类字典的回调函数。例如：</p>
<pre><code class="lang-python"><span class="hljs-comment"># stock.py</span>
<span class="hljs-comment"># Example of making a class manually from parts</span>

<span class="hljs-comment"># Methods</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, shares, price</span>):
    <span class="hljs-variable language_">self</span>.name = name
    <span class="hljs-variable language_">self</span>.shares = shares
    <span class="hljs-variable language_">self</span>.price = price
<span class="hljs-keyword">def</span> <span class="hljs-title function_">cost</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.shares * <span class="hljs-variable language_">self</span>.price

cls_dict = {
    <span class="hljs-string">'__init__'</span> : __init__,
    <span class="hljs-string">'cost'</span> : cost,
}

<span class="hljs-comment"># Make a class</span>
<span class="hljs-keyword">import</span> types

Stock = types.new_class(<span class="hljs-string">'Stock'</span>, (), {}, <span class="hljs-keyword">lambda</span> ns: ns.update(cls_dict))
Stock.__module__ = __name__
</code></pre>
<p>这种方式会构建一个普通的类对象，并且按照你的期望工作：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s
&lt;stock.Stock <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a9b10</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>s.cost()
<span class="hljs-number">4555.0</span>
&gt;&gt;&gt;
</code></pre>
<p>这种方法中，一个比较难理解的地方是在调用完 <code>types.new_class()</code> 对 <code>Stock.__module__</code>的赋值。 每次当一个类被定义后，它的 <code>__module__</code>属性包含定义它的模块名。 这个名字用于生成 <code>__repr__()</code> 方法的输出。它同样也被用于很多库，比如<code>pickle</code>。 因此，为了让你创建的类是“正确”的，你需要确保这个属性也设置正确了。</p>
<p>如果你想创建的类需要一个不同的元类，可以通过 <code>types.new_class()</code> 第三个参数传递给它。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> abc
<span class="hljs-meta">&gt;&gt;&gt; </span>Stock = types.new_class(<span class="hljs-string">'Stock'</span>, (), {<span class="hljs-string">'metaclass'</span>: abc.ABCMeta},
<span class="hljs-meta">... </span>                        <span class="hljs-keyword">lambda</span> ns: ns.update(cls_dict))
...
<span class="hljs-meta">&gt;&gt;&gt; </span>Stock.__module__ = __name__
<span class="hljs-meta">&gt;&gt;&gt; </span>Stock
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.Stock'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(Stock)
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'abc.ABCMeta'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>第三个参数还可以包含其他的关键字参数。比如，一个类的定义如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(Base, debug=<span class="hljs-literal">True</span>, typecheck=<span class="hljs-literal">False</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>那么可以将其翻译成如下的 <code>new_class()</code> 调用形式：</p>
<pre><code class="lang-python">Spam = types.new_class(<span class="hljs-string">'Spam'</span>, (Base,),
                        {<span class="hljs-string">'debug'</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">'typecheck'</span>: <span class="hljs-literal">False</span>},
                        <span class="hljs-keyword">lambda</span> ns: ns.update(cls_dict))
</code></pre>
<p><code>new_class()</code> 第四个参数最神秘，它是一个用来接受类命名空间的映射对象的函数。 通常这是一个普通的字典，但是它实际上是 <code>__prepare__()</code>方法返回的任意对象，这个在9.14小节已经介绍过了。 这个函数需要使用上面演示的 <code>update()</code> 方法给命名空间增加内容。</p>
<h2 id="讨论">讨论</h2>
<p>很多时候如果能构造新的类对象是很有用的。 有个很熟悉的例子是调用 <code>collections.namedtuple()</code> 函数，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>Stock = collections.namedtuple(<span class="hljs-string">'Stock'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>Stock
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.Stock'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p><code>namedtuple()</code> 使用 <code>exec()</code> 而不是上面介绍的技术。但是，下面通过一个简单的变化， 我们直接创建一个类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> operator
<span class="hljs-keyword">import</span> types
<span class="hljs-keyword">import</span> sys

<span class="hljs-keyword">def</span> <span class="hljs-title function_">named_tuple</span>(<span class="hljs-params">classname, fieldnames</span>):
    <span class="hljs-comment"># Populate a dictionary of field property accessors</span>
    cls_dict = { name: <span class="hljs-built_in">property</span>(operator.itemgetter(n))
                <span class="hljs-keyword">for</span> n, name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fieldnames) }

    <span class="hljs-comment"># Make a __new__ function and add to the class dict</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-built_in">len</span>(fieldnames):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected {} arguments'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(fieldnames)))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>.__new__(cls, args)

    cls_dict[<span class="hljs-string">'__new__'</span>] = __new__

    <span class="hljs-comment"># Make the class</span>
    cls = types.new_class(classname, (<span class="hljs-built_in">tuple</span>,), {},
                        <span class="hljs-keyword">lambda</span> ns: ns.update(cls_dict))

    <span class="hljs-comment"># Set the module to that of the caller</span>
    cls.__module__ = sys._getframe(<span class="hljs-number">1</span>).f_globals[<span class="hljs-string">'__name__'</span>]
    <span class="hljs-keyword">return</span> cls
</code></pre>
<p>这段代码的最后部分使用了一个所谓的”框架魔法”，通过调用 <code>sys._getframe()</code> 来获取调用者的模块名。 另外一个框架魔法例子在2.15小节中有介绍过。</p>
<p>下面的例子演示了前面的代码是如何工作的：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>Point = named_tuple(<span class="hljs-string">'Point'</span>, [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>Point
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.Point'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(p)
<span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p.x
<span class="hljs-number">4</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p.y
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p.x = <span class="hljs-number">2</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
AttributeError: can<span class="hljs-string">'t set attribute
&gt;&gt;&gt; print('</span>%s %s<span class="hljs-string">' % p)
4 5
&gt;&gt;&gt;
</span></code></pre>
<p>这项技术一个很重要的方面是它对于元类的正确使用。 你可能像通过直接实例化一个元类来直接创建一个类：</p>
<pre><code class="lang-python">Stock = <span class="hljs-built_in">type</span>(<span class="hljs-string">'Stock'</span>, (), cls_dict)
</code></pre>
<p>这种方法的问题在于它忽略了一些关键步骤，比如对于元类中 <code>__prepare__()</code> 方法的调用。 通过使用<code>types.new_class()</code> ，你可以保证所有的必要初始化步骤都能得到执行。 比如，<code>types.new_class()</code>第四个参数的回调函数接受<code>__prepare__()</code> 方法返回的映射对象。</p>
<p>如果你仅仅只是想执行准备步骤，可以使用 <code>types.prepare_class()</code> 。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> types
metaclass, kwargs, ns = types.prepare_class(<span class="hljs-string">'Stock'</span>, (), {<span class="hljs-string">'metaclass'</span>: <span class="hljs-built_in">type</span>})
</code></pre>
<p>它会查找合适的元类并调用它的 <code>__prepare__()</code>方法。 然后这个元类保存它的关键字参数，准备命名空间后被返回。</p>
<p>更多信息, 请参考 <a href="https://www.python.org/dev/peps/pep-3115/" target="_blank">PEP 3115</a> , 以及 <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" target="_blank">Python documentation</a> .</p>
<h1 id="919-在定义的时候初始化类的成员">9.19 在定义的时候初始化类的成员</h1>
<h2 id="问题">问题</h2>
<p>你想在类被定义的时候就初始化一部分类的成员，而不是要等到实例被创建后。</p>
<h2 id="解决方案">解决方案</h2>
<p>在类定义时就执行初始化或设置操作是元类的一个典型应用场景。本质上讲，一个元类会在定义时被触发， 这时候你可以执行一些额外的操作。</p>
<p>下面是一个例子，利用这个思路来创建类似于 <code>collections</code> 模块中的命名元组的类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> operator

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StructTupleMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):
        <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
        <span class="hljs-keyword">for</span> n, name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(cls._fields):
            <span class="hljs-built_in">setattr</span>(cls, name, <span class="hljs-built_in">property</span>(operator.itemgetter(n)))

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StructTuple</span>(<span class="hljs-built_in">tuple</span>, metaclass=StructTupleMeta):
    _fields = []
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-built_in">len</span>(cls._fields):
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'{} arguments required'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(cls._fields)))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls,args)
</code></pre>
<p>这段代码可以用来定义简单的基于元组的数据结构，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">StructTuple</span>):
    _fields = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">StructTuple</span>):
    _fields = [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]
</code></pre>
<p>下面演示它如何工作：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s
(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s[<span class="hljs-number">0</span>]
<span class="hljs-string">'ACME'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name
<span class="hljs-string">'ACME'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.shares * s.price
<span class="hljs-number">4555.0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.shares = <span class="hljs-number">23</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
AttributeError: can<span class="hljs-string">'t set attribute
&gt;&gt;&gt;
</span></code></pre>
<h2 id="讨论">讨论</h2>
<p>这一小节中，类 <code>StructTupleMeta</code> 获取到类属性 <code>_fields</code> 中的属性名字列表， 然后将它们转换成相应的可访问特定元组槽的方法。函数 <code>operator.itemgetter()</code> 创建一个访问器函数， 然后 <code>property()</code> 函数将其转换成一个属性。</p>
<p>本节最难懂的部分是知道不同的初始化步骤是什么时候发生的。 <code>StructTupleMeta</code> 中的 <code>__init__()</code>方法只在每个类被定义时被调用一次。 <code>cls</code>参数就是那个被定义的类。实际上，上述代码使用了<code>_fields</code> 类变量来保存新的被定义的类， 然后给它再添加一点新的东西。</p>
<p><code>StructTuple</code>类作为一个普通的基类，供其他使用者来继承。 这个类中的 <code>__new__()</code> 方法用来构造新的实例。 这里使用<code>__new__()</code> 并不是很常见，主要是因为我们要修改元组的调用签名， 使得我们可以像普通的实例调用那样创建实例。就像下面这样：</p>
<pre><code class="lang-python">s = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>) <span class="hljs-comment"># OK</span>
s = Stock((<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>)) <span class="hljs-comment"># Error</span>
</code></pre>
<p>跟 <code>__init__()</code> 不同的是，<code>__new__()</code>方法在实例被创建之前被触发。 由于元组是不可修改的，所以一旦它们被创建了就不可能对它做任何改变。而 <code>__init__()</code>会在实例创建的最后被触发， 这样的话我们就可以做我们想做的了。这也是为什么 <code>__new__()</code>方法已经被定义了。</p>
<p>尽管本节很短，还是需要你能仔细研读，深入思考 Python 类是如何被定义的，实例是如何被创建的， 还有就是元类和类的各个不同的方法究竟在什么时候被调用。</p>
<p><a href="http://www.python.org/dev/peps/pep-0422" target="_blank">PEP 422 </a>提供了一个解决本节问题的另外一种方法。 但是，截止到我写这本书的时候，它还没被采纳和接受。 尽管如此，如果你使用的是 Python 3.3 或更高的版本，那么还是值得去看一下的。</p>
<h1 id="920-利用函数注解实现方法重载">9.20 利用函数注解实现方法重载</h1>
<h2 id="问题">问题</h2>
<p>你已经学过怎样使用函数参数注解，那么你可能会想利用它来实现基于类型的方法重载。 但是你不确定应该怎样去实现（或者到底行得通不）。</p>
<h2 id="解决方案">解决方案</h2>
<p>本小节的技术是基于一个简单的技术，那就是 Python 允许参数注解，代码可以像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, x:<span class="hljs-built_in">int</span>, y:<span class="hljs-built_in">int</span></span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Bar 1:'</span>, x, y)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, s:<span class="hljs-built_in">str</span>, n:<span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Bar 2:'</span>, s, n)

s = Spam()
s.bar(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment"># Prints Bar 1: 2 3</span>
s.bar(<span class="hljs-string">'hello'</span>) <span class="hljs-comment"># Prints Bar 2: hello 0</span>
</code></pre>
<p>下面是我们第一步的尝试，使用到了一个元类和描述器：</p>
<pre><code class="lang-python"><span class="hljs-comment"># multiple.py</span>
<span class="hljs-keyword">import</span> inspect
<span class="hljs-keyword">import</span> types

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiMethod</span>:
    <span class="hljs-string">'''
    Represents a single multimethod.
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>._methods = {}
        <span class="hljs-variable language_">self</span>.__name__ = name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">self, meth</span>):
        <span class="hljs-string">'''
        Register a new method as a multimethod
        '''</span>
        sig = inspect.signature(meth)

        <span class="hljs-comment"># Build a type signature from the method's annotations</span>
        types = []
        <span class="hljs-keyword">for</span> name, parm <span class="hljs-keyword">in</span> sig.parameters.items():
            <span class="hljs-keyword">if</span> name == <span class="hljs-string">'self'</span>:
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> parm.annotation <span class="hljs-keyword">is</span> inspect.Parameter.empty:
                <span class="hljs-keyword">raise</span> TypeError(
                    <span class="hljs-string">'Argument {} must be annotated with a type'</span>.<span class="hljs-built_in">format</span>(name)
                )
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(parm.annotation, <span class="hljs-built_in">type</span>):
                <span class="hljs-keyword">raise</span> TypeError(
                    <span class="hljs-string">'Argument {} annotation must be a type'</span>.<span class="hljs-built_in">format</span>(name)
                )
            <span class="hljs-keyword">if</span> parm.default <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> inspect.Parameter.empty:
                <span class="hljs-variable language_">self</span>._methods[<span class="hljs-built_in">tuple</span>(types)] = meth
            types.append(parm.annotation)

        <span class="hljs-variable language_">self</span>._methods[<span class="hljs-built_in">tuple</span>(types)] = meth

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args</span>):
        <span class="hljs-string">'''
        Call a method based on type signature of the arguments
        '''</span>
        types = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">type</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args[<span class="hljs-number">1</span>:])
        meth = <span class="hljs-variable language_">self</span>._methods.get(types, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> meth:
            <span class="hljs-keyword">return</span> meth(*args)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'No matching method for types {}'</span>.<span class="hljs-built_in">format</span>(types))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-string">'''
        Descriptor method needed to make calls work in a class
        '''</span>
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> types.MethodType(<span class="hljs-variable language_">self</span>, instance)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiDict</span>(<span class="hljs-title class_ inherited__">dict</span>):
    <span class="hljs-string">'''
    Special dictionary to build multimethods in a metaclass
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>:
            <span class="hljs-comment"># If key already exists, it must be a multimethod or callable</span>
            current_value = <span class="hljs-variable language_">self</span>[key]
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(current_value, MultiMethod):
                current_value.register(value)
            <span class="hljs-keyword">else</span>:
                mvalue = MultiMethod(key)
                mvalue.register(current_value)
                mvalue.register(value)
                <span class="hljs-built_in">super</span>().__setitem__(key, mvalue)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">super</span>().__setitem__(key, value)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MultipleMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-string">'''
    Metaclass that allows multiple dispatch of methods
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, clsname, bases, clsdict</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, clsname, bases, <span class="hljs-built_in">dict</span>(clsdict))

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__prepare__</span>(<span class="hljs-params">cls, clsname, bases</span>):
        <span class="hljs-keyword">return</span> MultiDict()
</code></pre>
<p>为了使用这个类，你可以像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(metaclass=MultipleMeta):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, x:<span class="hljs-built_in">int</span>, y:<span class="hljs-built_in">int</span></span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Bar 1:'</span>, x, y)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, s:<span class="hljs-built_in">str</span>, n:<span class="hljs-built_in">int</span> = <span class="hljs-number">0</span></span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Bar 2:'</span>, s, n)

<span class="hljs-comment"># Example: overloaded __init__</span>
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>(metaclass=MultipleMeta):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year: <span class="hljs-built_in">int</span>, month:<span class="hljs-built_in">int</span>, day:<span class="hljs-built_in">int</span></span>):
        <span class="hljs-variable language_">self</span>.year = year
        <span class="hljs-variable language_">self</span>.month = month
        <span class="hljs-variable language_">self</span>.day = day

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        t = time.localtime()
        <span class="hljs-variable language_">self</span>.__init__(t.tm_year, t.tm_mon, t.tm_mday)
</code></pre>
<p>下面是一个交互示例来验证它能正确的工作：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
Bar <span class="hljs-number">1</span>: <span class="hljs-number">2</span> <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-string">'hello'</span>)
Bar <span class="hljs-number">2</span>: hello <span class="hljs-number">0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-string">'hello'</span>, <span class="hljs-number">5</span>)
Bar <span class="hljs-number">2</span>: hello <span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(<span class="hljs-number">2</span>, <span class="hljs-string">'hello'</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"multiple.py"</span>, line <span class="hljs-number">42</span>, <span class="hljs-keyword">in</span> __call__
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'No matching method for types {}'</span>.<span class="hljs-built_in">format</span>(types))
TypeError: No matching method <span class="hljs-keyword">for</span> types (&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'int'</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Overloaded __init__</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>d = Date(<span class="hljs-number">2012</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Get today's date</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e = Date()
<span class="hljs-meta">&gt;&gt;&gt; </span>e.year
<span class="hljs-number">2012</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e.month
<span class="hljs-number">12</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e.day
<span class="hljs-number">3</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>坦白来讲，相对于通常的代码而已本节使用到了很多的魔法代码。 但是，它却能让我们深入理解元类和描述器的底层工作原理， 并能加深对这些概念的印象。因此，就算你并不会立即去应用本节的技术， 它的一些底层思想却会影响到其它涉及到元类、描述器和函数注解的编程技术。</p>
<p>本节的实现中的主要思路其实是很简单的。<code>MutipleMeta</code> 元类使用它的 <code>__prepare__()</code>方法 来提供一个作为 <code>MultiDict</code>实例的自定义字典。这个跟普通字典不一样的是， <code>MultiDict</code>会在元素被设置的时候检查是否已经存在，如果存在的话，重复的元素会在 <code>MultiMethod</code>实例中合并。</p>
<p><code>MultiMethod</code>实例通过构建从类型签名到函数的映射来收集方法。 在这个构建过程中，函数注解被用来收集这些签名然后构建这个映射。 这个过程在 <code>MultiMethod.register()</code> 方法中实现。 这种映射的一个关键特点是对于多个方法，所有参数类型都必须要指定，否则就会报错。</p>
<p>为了让<code>MultiMethod</code> 实例模拟一个调用，它的 <code>__call__()</code> 方法被实现了。 这个方法从所有排除 <code>slef</code> 的参数中构建一个类型元组，在内部 map 中查找这个方法， 然后调用相应的方法。为了能让 <code>MultiMethod</code>实例在类定义时正确操作，<code>__get__()</code>是必须得实现的。 它被用来构建正确的绑定方法。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = s.bar
<span class="hljs-meta">&gt;&gt;&gt; </span>b
&lt;bound method Spam.bar of &lt;__main__.Spam <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a46d0</span>&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>b.__self__
&lt;__main__.Spam <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a46d0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>b.__func__
&lt;__main__.MultiMethod <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a4d50</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
Bar <span class="hljs-number">1</span>: <span class="hljs-number">2</span> <span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b(<span class="hljs-string">'hello'</span>)
Bar <span class="hljs-number">2</span>: hello <span class="hljs-number">0</span>
&gt;&gt;&gt;
</code></pre>
<p>不过本节的实现还有一些限制，其中一个是它不能使用关键字参数。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(x=<span class="hljs-number">2</span>, y=<span class="hljs-number">3</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: __call__() got an unexpected keyword argument <span class="hljs-string">'y'</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>s.bar(s=<span class="hljs-string">'hello'</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: __call__() got an unexpected keyword argument <span class="hljs-string">'s'</span>
&gt;&gt;&gt;
</code></pre>
<p>也许有其他的方法能添加这种支持，但是它需要一个完全不同的方法映射方式。 问题在于关键字参数的出现是没有顺序的。当它跟位置参数混合使用时， 那你的参数就会变得比较混乱了，这时候你不得不在 <code>__call__()</code> 方法中先去做个排序。</p>
<p>同样对于继承也是有限制的，例如，类似下面这种代码就不能正常工作：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>:
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>(metaclass=MultipleMeta):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self, x:A</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Foo 1:'</span>, x)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self, x:C</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Foo 2:'</span>, x)
</code></pre>
<p>原因是因为 <code>x:A</code>注解不能成功匹配子类实例（比如 B 的实例），如下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam()
<span class="hljs-meta">&gt;&gt;&gt; </span>a = A()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.foo(a)
Foo <span class="hljs-number">1</span>: &lt;__main__.A <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a5310</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>c = C()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.foo(c)
Foo <span class="hljs-number">2</span>: &lt;__main__.C <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1007a1910</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>b = B()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.foo(b)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"multiple.py"</span>, line <span class="hljs-number">44</span>, <span class="hljs-keyword">in</span> __call__
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'No matching method for types {}'</span>.<span class="hljs-built_in">format</span>(types))
TypeError: No matching method <span class="hljs-keyword">for</span> types (&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.B'</span>&gt;,)
&gt;&gt;&gt;
</code></pre>
<p>作为使用元类和注解的一种替代方案，可以通过描述器来实现类似的效果。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> types

<span class="hljs-keyword">class</span> <span class="hljs-title class_">multimethod</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):
        <span class="hljs-variable language_">self</span>._methods = {}
        <span class="hljs-variable language_">self</span>.__name__ = func.__name__
        <span class="hljs-variable language_">self</span>._default = func

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">self, *types</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">func</span>):
            ndefaults = <span class="hljs-built_in">len</span>(func.__defaults__) <span class="hljs-keyword">if</span> func.__defaults__ <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ndefaults+<span class="hljs-number">1</span>):
                <span class="hljs-variable language_">self</span>._methods[types[:<span class="hljs-built_in">len</span>(types) - n]] = func
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">return</span> register

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args</span>):
        types = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">type</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args[<span class="hljs-number">1</span>:])
        meth = <span class="hljs-variable language_">self</span>._methods.get(types, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> meth:
            <span class="hljs-keyword">return</span> meth(*args)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._default(*args)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> types.MethodType(<span class="hljs-variable language_">self</span>, instance)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
</code></pre>
<p>为了使用描述器版本，你需要像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
<span class="hljs-meta">    @multimethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, *args</span>):
        <span class="hljs-comment"># Default method called if no match</span>
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'No matching method for bar'</span>)

<span class="hljs-meta">    @bar.match(<span class="hljs-params"><span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Bar 1:'</span>, x, y)

<span class="hljs-meta">    @bar.match(<span class="hljs-params"><span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span></span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, s, n = <span class="hljs-number">0</span></span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Bar 2:'</span>, s, n)
</code></pre>
<p>描述器方案同样也有前面提到的限制（不支持关键字参数和继承）。</p>
<p>所有事物都是平等的，有好有坏，也许最好的办法就是在普通代码中避免使用方法重载。 不过有些特殊情况下还是有意义的，比如基于模式匹配的方法重载程序中。 举个例子，8.21小节中的访问者模式可以修改为一个使用方法重载的类。 但是，除了这个以外，通常不应该使用方法重载（就简单的使用不同名称的方法就行了）。</p>
<p>在 Python 社区对于实现方法重载的讨论已经由来已久。 对于引发这个争论的原因，可以参考下 Guido van Rossum 的这篇博客： <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=101605" target="_blank">Five-Minute Multimethods in Python</a></p>
<h1 id="921-避免重复的属性方法">9.21 避免重复的属性方法</h1>
<h2 id="问题">问题</h2>
<p>你在类中需要重复的定义一些执行相同逻辑的属性方法，比如进行类型检查，怎样去简化这些重复代码呢？</p>
<h2 id="解决方案">解决方案</h2>
<p>考虑下一个简单的类，它的属性由属性方法包装：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name ,age</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.age = age

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._name

<span class="hljs-meta">    @name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'name must be a string'</span>)
        <span class="hljs-variable language_">self</span>._name = value

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._age

<span class="hljs-meta">    @age.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'age must be an int'</span>)
        <span class="hljs-variable language_">self</span>._age = value
</code></pre>
<p>可以看到，为了实现属性值的类型检查我们写了很多的重复代码。 只要你以后看到类似这样的代码，你都应该想办法去简化它。 一个可行的方法是创建一个函数用来定义属性并返回它。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">typed_property</span>(<span class="hljs-params">name, expected_type</span>):
    storage_name = <span class="hljs-string">'_'</span> + name

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, storage_name)

<span class="hljs-meta">    @prop.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prop</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, expected_type):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'{} must be a {}'</span>.<span class="hljs-built_in">format</span>(name, expected_type))
        <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, storage_name, value)

    <span class="hljs-keyword">return</span> prop

<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    name = typed_property(<span class="hljs-string">'name'</span>, <span class="hljs-built_in">str</span>)
    age = typed_property(<span class="hljs-string">'age'</span>, <span class="hljs-built_in">int</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.age = age
</code></pre>
<h2 id="讨论">讨论</h2>
<p>本节我们演示内部函数或者闭包的一个重要特性，它们很像一个宏。例子中的函数 <code>typed_property()</code>看上去有点难理解，其实它所做的仅仅就是为你生成属性并返回这个属性对象。 因此，当在一个类中使用它的时候，效果跟将它里面的代码放到类定义中去是一样的。 尽管属性的 <code>getter</code>和 <code>setter</code>方法访问了本地变量如<code>name</code> , <code>expected_type</code> 以及<code>storate_name</code> ，这个很正常，这些变量的值会保存在闭包当中。</p>
<p>我们还可以使用 <code>functools.partial()</code> 来稍稍改变下这个例子，很有趣。例如，你可以像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial

String = partial(typed_property, expected_type=<span class="hljs-built_in">str</span>)
Integer = partial(typed_property, expected_type=<span class="hljs-built_in">int</span>)

<span class="hljs-comment"># Example:</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    name = String(<span class="hljs-string">'name'</span>)
    age = Integer(<span class="hljs-string">'age'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.age = age
</code></pre>
<p>其实你可以发现，这里的代码跟8.13小节中的类型系统描述器代码有些相似。</p>
<h1 id="922-定义上下文管理器的简单方法">9.22 定义上下文管理器的简单方法</h1>
<h2 id="问题">问题</h2>
<p>你想自己去实现一个新的上下文管理器，以便使用 with 语句。</p>
<h2 id="解决方案">解决方案</h2>
<p>实现一个新的上下文管理器的最简单的方法就是使用 <code>contexlib</code> 模块中的 <code>@contextmanager</code>装饰器。 下面是一个实现了代码块计时功能的上下文管理器例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager

<span class="hljs-meta">@contextmanager</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">timethis</span>(<span class="hljs-params">label</span>):
    start = time.time()
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">yield</span>
    <span class="hljs-keyword">finally</span>:
        end = time.time()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'{}: {}'</span>.<span class="hljs-built_in">format</span>(label, end - start))

<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">with</span> timethis(<span class="hljs-string">'counting'</span>):
    n = <span class="hljs-number">10000000</span>
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        n -= <span class="hljs-number">1</span>
</code></pre>
<p>在函数<code>timethis()</code> 中，<code>yield</code> 之前的代码会在上下文管理器中作为 <code>__enter__()</code> 方法执行， 所有在<code>yield</code>之后的代码会作为<code>__exit__()</code> 方法执行。 如果出现了异常，异常会在 yield 语句那里抛出。</p>
<p>下面是一个更加高级一点的上下文管理器，实现了列表对象上的某种事务：</p>
<pre><code class="lang-python"><span class="hljs-meta">@contextmanager</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">list_transaction</span>(<span class="hljs-params">orig_list</span>):
    working = <span class="hljs-built_in">list</span>(orig_list)
    <span class="hljs-keyword">yield</span> working
    orig_list[:] = working
</code></pre>
<p>这段代码的作用是任何对列表的修改只有当所有代码运行完成并且不出现异常的情况下才会生效。 下面我们来演示一下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> list_transaction(items) <span class="hljs-keyword">as</span> working:
<span class="hljs-meta">... </span>    working.append(<span class="hljs-number">4</span>)
<span class="hljs-meta">... </span>    working.append(<span class="hljs-number">5</span>)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>items
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> list_transaction(items) <span class="hljs-keyword">as</span> working:
<span class="hljs-meta">... </span>    working.append(<span class="hljs-number">6</span>)
<span class="hljs-meta">... </span>    working.append(<span class="hljs-number">7</span>)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'oops'</span>)
...
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
RuntimeError: oops
<span class="hljs-meta">&gt;&gt;&gt; </span>items
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>通常情况下，如果要写一个上下文管理器，你需要定义一个类，里面包含一个 <code>__enter__()</code> 和一个 <code>__exit__()</code> 方法，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time

<span class="hljs-keyword">class</span> <span class="hljs-title class_">timethis</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, label</span>):
        <span class="hljs-variable language_">self</span>.label = label

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.start = time.time()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_ty, exc_val, exc_tb</span>):
        end = time.time()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'{}: {}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.label, end - <span class="hljs-variable language_">self</span>.start))
</code></pre>
<p>尽管这个也不难写，但是相比较写一个简单的使用 <code>@contextmanager</code> 注解的函数而言还是稍显乏味。</p>
<p><code>@contextmanager</code>应该仅仅用来写自包含的上下文管理函数。 如果你有一些对象(比如一个文件、网络连接或锁)，需要支持<code>with</code> 语句，那么你就需要单独实现 <code>__enter__()</code> 方法和<code>__exit__()</code>方法。</p>
<h1 id="923-在局部变量域中执行代码">9.23 在局部变量域中执行代码</h1>
<h2 id="问题">问题</h2>
<p>你想在使用范围内执行某个代码片段，并且希望在执行后所有的结果都不可见。</p>
<h2 id="解决方案">解决方案</h2>
<p>为了理解这个问题，先试试一个简单场景。首先，在全局命名空间内执行一个代码片段：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">13</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">exec</span>(<span class="hljs-string">'b = a + 1'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(b)
<span class="hljs-number">14</span>
&gt;&gt;&gt;
</code></pre>
<p>然后，再在一个函数中执行同样的代码：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
<span class="hljs-meta">... </span>    a = <span class="hljs-number">13</span>
<span class="hljs-meta">... </span>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">'b = a + 1'</span>)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(b)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>test()
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> test
NameError: <span class="hljs-keyword">global</span> name <span class="hljs-string">'b'</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined
&gt;&gt;&gt;
</code></pre>
<p>可以看出，最后抛出了一个 NameError 异常，就跟在<code>exec()</code>语句从没执行过一样。 要是你想在后面的计算中使用到 <code>exec()</code> 执行结果的话就会有问题了。</p>
<p>为了修正这样的错误，你需要在调用 <code>exec()</code>之前使用 <code>locals()</code> 函数来得到一个局部变量字典。 之后你就能从局部字典中获取修改过后的变量值了。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():
<span class="hljs-meta">... </span>    a = <span class="hljs-number">13</span>
<span class="hljs-meta">... </span>    loc = <span class="hljs-built_in">locals</span>()
<span class="hljs-meta">... </span>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">'b = a + 1'</span>)
<span class="hljs-meta">... </span>    b = loc[<span class="hljs-string">'b'</span>]
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(b)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>test()
<span class="hljs-number">14</span>
&gt;&gt;&gt;
</code></pre>
<p>讨论
实际上对于<code>exec()</code>的正确使用是比较难的。大多数情况下当你要考虑使用 <code>exec()</code> 的时候， 还有另外更好的解决方案（比如装饰器、闭包、元类等等）。</p>
<p>然而，如果你仍然要使用 <code>exec()</code>，本节列出了一些如何正确使用它的方法。 默认情况下，<code>exec()</code>会在调用者局部和全局范围内执行代码。然而，在函数里面， 传递给 <code>exec()</code>的局部范围是拷贝实际局部变量组成的一个字典。 因此，如果<code>exec()</code>如果执行了修改操作，这种修改后的结果对实际局部变量值是没有影响的。 下面是另外一个演示它的例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>():
<span class="hljs-meta">... </span>    x = <span class="hljs-number">0</span>
<span class="hljs-meta">... </span>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">'x += 1'</span>)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(x)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>test1()
<span class="hljs-number">0</span>
&gt;&gt;&gt;
</code></pre>
<p>上面代码里，当你调用 <code>locals()</code> 获取局部变量时，你获得的是传递给 <code>exec()</code> 的局部变量的一个拷贝。 通过在代码执行后审查这个字典的值，那就能获取修改后的值了。下面是一个演示例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>():
<span class="hljs-meta">... </span>    x = <span class="hljs-number">0</span>
<span class="hljs-meta">... </span>    loc = <span class="hljs-built_in">locals</span>()
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'before:'</span>, loc)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">'x += 1'</span>)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'after:'</span>, loc)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'x ='</span>, x)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>test2()
before: {<span class="hljs-string">'x'</span>: <span class="hljs-number">0</span>}
after: {<span class="hljs-string">'loc'</span>: {...}, <span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>}
x = <span class="hljs-number">0</span>
&gt;&gt;&gt;
</code></pre>
<p>仔细观察最后一步的输出，除非你将<code>loc</code>中被修改后的值手动赋值给 x，否则 x 变量值是不会变的。</p>
<p>在使用 <code>locals()</code>的时候，你需要注意操作顺序。每次它被调用的时候， <code>locals()</code> 会获取局部变量值中的值并覆盖字典中相应的变量。 请注意观察下下面这个试验的输出结果：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test3</span>():
<span class="hljs-meta">... </span>    x = <span class="hljs-number">0</span>
<span class="hljs-meta">... </span>    loc = <span class="hljs-built_in">locals</span>()
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(loc)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">'x += 1'</span>)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(loc)
<span class="hljs-meta">... </span>    <span class="hljs-built_in">locals</span>()
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(loc)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>test3()
{<span class="hljs-string">'x'</span>: <span class="hljs-number">0</span>}
{<span class="hljs-string">'loc'</span>: {...}, <span class="hljs-string">'x'</span>: <span class="hljs-number">1</span>}
{<span class="hljs-string">'loc'</span>: {...}, <span class="hljs-string">'x'</span>: <span class="hljs-number">0</span>}
&gt;&gt;&gt;
</code></pre>
<p>注意最后一次调用 <code>locals()</code>的时候 x 的值是如何被覆盖掉的。</p>
<p>作为 <code>locals()</code> 的一个替代方案，你可以使用你自己的字典，并将它传递给<code>exec()</code> 。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">test4</span>():
<span class="hljs-meta">... </span>    a = <span class="hljs-number">13</span>
<span class="hljs-meta">... </span>    loc = { <span class="hljs-string">'a'</span> : a }
<span class="hljs-meta">... </span>    glb = { }
<span class="hljs-meta">... </span>    <span class="hljs-built_in">exec</span>(<span class="hljs-string">'b = a + 1'</span>, glb, loc)
<span class="hljs-meta">... </span>    b = loc[<span class="hljs-string">'b'</span>]
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(b)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>test4()
<span class="hljs-number">14</span>
&gt;&gt;&gt;
</code></pre>
<p>大部分情况下，这种方式是使用<code>exec()</code>的最佳实践。 你只需要保证全局和局部字典在后面代码访问时已经被初始化。</p>
<p>还有一点，在使用 <code>exec()</code>之前，你可能需要问下自己是否有其他更好的替代方案。 大多数情况下当你要考虑使用 <code>exec()</code> 的时候， 还有另外更好的解决方案，比如装饰器、闭包、元类，或其他一些元编程特性。</p>
<h1 id="924-解析与分析-python-源码">9.24 解析与分析 Python 源码</h1>
<h2 id="问题">问题</h2>
<p>你想写解析并分析 Python 源代码的程序。</p>
<h2 id="解决方案">解决方案</h2>
<p>大部分程序员知道 Python 能够计算或执行字符串形式的源代码。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">42</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">eval</span>(<span class="hljs-string">'2 + 3*4 + x'</span>)
<span class="hljs-number">56</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">exec</span>(<span class="hljs-string">'for i in range(10): print(i)'</span>)
<span class="hljs-number">0</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span>
<span class="hljs-number">8</span>
<span class="hljs-number">9</span>
&gt;&gt;&gt;
</code></pre>
<p>尽管如此，<code>ast</code> 模块能被用来将 Python 源码编译成一个可被分析的抽象语法树（AST）。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> ast
<span class="hljs-meta">&gt;&gt;&gt; </span>ex = ast.parse(<span class="hljs-string">'2 + 3*4 + x'</span>, mode=<span class="hljs-string">'eval'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>ex
&lt;_ast.Expression <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1007473d0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>ast.dump(ex)
<span class="hljs-string">"Expression(body=BinOp(left=BinOp(left=Num(n=2), op=Add(),
right=BinOp(left=Num(n=3), op=Mult(), right=Num(n=4))), op=Add(),
right=Name(id='x', ctx=Load())))"</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>top = ast.parse(<span class="hljs-string">'for i in range(10): print(i)'</span>, mode=<span class="hljs-string">'exec'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>top
&lt;_ast.Module <span class="hljs-built_in">object</span> at <span class="hljs-number">0x100747390</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>ast.dump(top)
<span class="hljs-string">"Module(body=[For(target=Name(id='i', ctx=Store()),
iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=10)],
keywords=[], starargs=None, kwargs=None),
body=[Expr(value=Call(func=Name(id='print', ctx=Load()),
args=[Name(id='i', ctx=Load())], keywords=[], starargs=None,
kwargs=None))], orelse=[])])"</span>
&gt;&gt;&gt;
</code></pre>
<p>分析源码树需要你自己更多的学习，它是由一系列 AST 节点组成的。 分析这些节点最简单的方法就是定义一个访问者类，实现很多 <code>visit_NodeName()</code>方法， <code>NodeName()</code>匹配那些你感兴趣的节点。下面是这样一个类，记录了哪些名字被加载、存储和删除的信息。</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> ast

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeAnalyzer</span>(ast.NodeVisitor):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.loaded = <span class="hljs-built_in">set</span>()
        <span class="hljs-variable language_">self</span>.stored = <span class="hljs-built_in">set</span>()
        <span class="hljs-variable language_">self</span>.deleted = <span class="hljs-built_in">set</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Name</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(node.ctx, ast.Load):
            <span class="hljs-variable language_">self</span>.loaded.add(node.<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(node.ctx, ast.Store):
            <span class="hljs-variable language_">self</span>.stored.add(node.<span class="hljs-built_in">id</span>)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(node.ctx, ast.Del):
            <span class="hljs-variable language_">self</span>.deleted.add(node.<span class="hljs-built_in">id</span>)

<span class="hljs-comment"># Sample usage</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># Some Python code</span>
    code = <span class="hljs-string">'''
    for i in range(10):
        print(i)
    del i
    '''</span>

    <span class="hljs-comment"># Parse into an AST</span>
    top = ast.parse(code, mode=<span class="hljs-string">'exec'</span>)

    <span class="hljs-comment"># Feed the AST to analyze name usage</span>
    c = CodeAnalyzer()
    c.visit(top)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Loaded:'</span>, c.loaded)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Stored:'</span>, c.stored)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Deleted:'</span>, c.deleted)
</code></pre>
<p>如果你运行这个程序，你会得到下面这样的输出：</p>
<pre><code class="lang-python">Loaded: {<span class="hljs-string">'i'</span>, <span class="hljs-string">'range'</span>, <span class="hljs-string">'print'</span>}
Stored: {<span class="hljs-string">'i'</span>}
Deleted: {<span class="hljs-string">'i'</span>}
</code></pre>
<p>最后，AST 可以通过 <code>compile()</code> 函数来编译并执行。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">exec</span>(<span class="hljs-built_in">compile</span>(top,<span class="hljs-string">'&lt;stdin&gt;'</span>, <span class="hljs-string">'exec'</span>))
<span class="hljs-number">0</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">4</span>
<span class="hljs-number">5</span>
<span class="hljs-number">6</span>
<span class="hljs-number">7</span>
<span class="hljs-number">8</span>
<span class="hljs-number">9</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>当你能够分析源代码并从中获取信息的时候，你就能写很多代码分析、优化或验证工具了。 例如，相比盲目的传递一些代码片段到类似 <code>exec()</code> 函数中，你可以先将它转换成一个 AST， 然后观察它的细节看它到底是怎样做的。 你还可以写一些工具来查看某个模块的全部源码，并且在此基础上执行某些静态分析。</p>
<p>需要注意的是，如果你知道自己在干啥，你还能够重写 AST 来表示新的代码。 下面是一个装饰器例子，可以通过重新解析函数体源码、 重写 AST 并重新创建函数代码对象来将全局访问变量降为函数体作用范围，</p>
<pre><code class="lang-python"><span class="hljs-comment"># namelower.py</span>
<span class="hljs-keyword">import</span> ast
<span class="hljs-keyword">import</span> inspect

<span class="hljs-comment"># Node visitor that lowers globally accessed names into</span>
<span class="hljs-comment"># the function body as local variables.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameLower</span>(ast.NodeVisitor):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lowered_names</span>):
        <span class="hljs-variable language_">self</span>.lowered_names = lowered_names

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_FunctionDef</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-comment"># Compile some assignments to lower the constants</span>
        code = <span class="hljs-string">'__globals = globals()\n'</span>
        code += <span class="hljs-string">'\n'</span>.join(<span class="hljs-string">"{0} = __globals['{0}']"</span>.<span class="hljs-built_in">format</span>(name)
                            <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.lowered_names)
        code_ast = ast.parse(code, mode=<span class="hljs-string">'exec'</span>)

        <span class="hljs-comment"># Inject new statements into the function body</span>
        node.body[:<span class="hljs-number">0</span>] = code_ast.body

        <span class="hljs-comment"># Save the function object</span>
        <span class="hljs-variable language_">self</span>.func = node

<span class="hljs-comment"># Decorator that turns global names into locals</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">lower_names</span>(<span class="hljs-params">*namelist</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lower</span>(<span class="hljs-params">func</span>):
        srclines = inspect.getsource(func).splitlines()
        <span class="hljs-comment"># Skip source lines prior to the @lower_names decorator</span>
        <span class="hljs-keyword">for</span> n, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(srclines):
            <span class="hljs-keyword">if</span> <span class="hljs-string">'@lower_names'</span> <span class="hljs-keyword">in</span> line:
                <span class="hljs-keyword">break</span>

        src = <span class="hljs-string">'\n'</span>.join(srclines[n+<span class="hljs-number">1</span>:])
        <span class="hljs-comment"># Hack to deal with indented code</span>
        <span class="hljs-keyword">if</span> src.startswith((<span class="hljs-string">' '</span>,<span class="hljs-string">'\t'</span>)):
            src = <span class="hljs-string">'if 1:\n'</span> + src
        top = ast.parse(src, mode=<span class="hljs-string">'exec'</span>)

        <span class="hljs-comment"># Transform the AST</span>
        cl = NameLower(namelist)
        cl.visit(top)

        <span class="hljs-comment"># Execute the modified AST</span>
        temp = {}
        <span class="hljs-built_in">exec</span>(<span class="hljs-built_in">compile</span>(top,<span class="hljs-string">''</span>,<span class="hljs-string">'exec'</span>), temp, temp)

        <span class="hljs-comment"># Pull out the modified code object</span>
        func.__code__ = temp[func.__name__].__code__
        <span class="hljs-keyword">return</span> func
    <span class="hljs-keyword">return</span> lower
</code></pre>
<p>为了使用这个代码，你可以像下面这样写：</p>
<pre><code class="lang-python">INCR = <span class="hljs-number">1</span>
<span class="hljs-meta">@lower_names(<span class="hljs-params"><span class="hljs-string">'INCR'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        n -= INCR
</code></pre>
<p>装饰器会将 <code>countdown()</code>函数重写为类似下面这样子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    __<span class="hljs-built_in">globals</span> = <span class="hljs-built_in">globals</span>()
    INCR = __<span class="hljs-built_in">globals</span>[<span class="hljs-string">'INCR'</span>]
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        n -= INCR
</code></pre>
<p>在性能测试中，它会让函数运行快20%</p>
<p>现在，你是不是想为你所有的函数都加上这个装饰器呢？或许不会。 但是，这却是对于一些高级技术比如 AST 操作、源码操作等等的一个很好的演示说明</p>
<p>本节受另外一个在 <code>ActiveState</code>中处理 Python 字节码的章节的启示。 使用 AST 是一个更加高级点的技术，并且也更简单些。参考下面一节获得字节码的更多信息。</p>
<h1 id="925-拆解-python-字节码">9.25 拆解 Python 字节码</h1>
<h2 id="问题">问题</h2>
<p>你想通过将你的代码反编译成低级的字节码来查看它底层的工作机制。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>dis</code>模块可以被用来输出任何 Python 函数的反编译结果。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
<span class="hljs-meta">... </span><span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'T-minus'</span>, n)
<span class="hljs-meta">... </span>    n -= <span class="hljs-number">1</span>
<span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-string">'Blastoff!'</span>)
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> dis
<span class="hljs-meta">&gt;&gt;&gt; </span>dis.dis(countdown)
...
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>当你想要知道你的程序底层的运行机制的时候，<code>dis</code> 模块是很有用的。比如如果你想试着理解性能特征。 被 <code>dis()</code> 函数解析的原始字节码如下所示：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>countdown.__code__.co_code
<span class="hljs-string">b"x'\x00|\x00\x00d\x01\x00k\x04\x00r)\x00t\x00\x00d\x02\x00|\x00\x00\x83
\x02\x00\x01|\x00\x00d\x03\x008}\x00\x00q\x03\x00Wt\x00\x00d\x04\x00\x83
\x01\x00\x01d\x00\x00S"</span>
&gt;&gt;&gt;
</code></pre>
<p>如果你想自己解释这段代码，你需要使用一些在 <code>opcode</code>模块中定义的常量。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = countdown.__code__.co_code
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> opcode
<span class="hljs-meta">&gt;&gt;&gt; </span>opcode.opname[c[<span class="hljs-number">0</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span>opcode.opname[c[<span class="hljs-number">0</span>]]
<span class="hljs-string">'SETUP_LOOP'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>opcode.opname[c[<span class="hljs-number">3</span>]]
<span class="hljs-string">'LOAD_FAST'</span>
&gt;&gt;&gt;
</code></pre>
<p>奇怪的是，在 <code>dis</code> 模块中并没有函数让你以编程方式很容易的来处理字节码。 不过，下面的生成器函数可以将原始字节码序列转换成<code>opcodes</code> 和参数。</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> opcode

<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_opcodes</span>(<span class="hljs-params">codebytes</span>):
    extended_arg = <span class="hljs-number">0</span>
    i = <span class="hljs-number">0</span>
    n = <span class="hljs-built_in">len</span>(codebytes)
    <span class="hljs-keyword">while</span> i &lt; n:
        op = codebytes[i]
        i += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> op &gt;= opcode.HAVE_ARGUMENT:
            oparg = codebytes[i] + codebytes[i+<span class="hljs-number">1</span>]*<span class="hljs-number">256</span> + extended_arg
            extended_arg = <span class="hljs-number">0</span>
            i += <span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> op == opcode.EXTENDED_ARG:
                extended_arg = oparg * <span class="hljs-number">65536</span>
                <span class="hljs-keyword">continue</span>
        <span class="hljs-keyword">else</span>:
            oparg = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">yield</span> (op, oparg)
</code></pre>
<p>使用方法如下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> op, oparg <span class="hljs-keyword">in</span> generate_opcodes(countdown.__code__.co_code):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(op, opcode.opname[op], oparg)
</code></pre>
<p>这种方式很少有人知道，你可以利用它替换任何你想要替换的函数的原始字节码。 下面我们用一个示例来演示整个过程：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x + y
...
<span class="hljs-meta">&gt;&gt;&gt; </span>c = add.__code__
<span class="hljs-meta">&gt;&gt;&gt; </span>c
&lt;code <span class="hljs-built_in">object</span> add at <span class="hljs-number">0x1007beed0</span>, file <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>c.co_code
<span class="hljs-string">b'|\x00\x00|\x01\x00\x17S'</span>
&gt;&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Make a completely new code object with bogus byte code</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> types
<span class="hljs-meta">&gt;&gt;&gt; </span>newbytecode = <span class="hljs-string">b'xxxxxxx'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>nc = types.CodeType(c.co_argcount, c.co_kwonlyargcount,
<span class="hljs-meta">... </span>    c.co_nlocals, c.co_stacksize, c.co_flags, newbytecode, c.co_consts,
<span class="hljs-meta">... </span>    c.co_names, c.co_varnames, c.co_filename, c.co_name,
<span class="hljs-meta">... </span>    c.co_firstlineno, c.co_lnotab)
<span class="hljs-meta">&gt;&gt;&gt; </span>nc
&lt;code <span class="hljs-built_in">object</span> add at <span class="hljs-number">0x10069fe40</span>, file <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>add.__code__ = nc
<span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
Segmentation fault
</code></pre>
<p>你可以像这样耍大招让解释器奔溃。但是，对于编写更高级优化和元编程工具的程序员来讲， 他们可能真的需要重写字节码。本节最后的部分演示了这个是怎样做到的。你还可以参考另外一个类似的例子： <a href="http://code.activestate.com/recipes/277940-decorator-for-bindingconstants-at-compile-time/" target="_blank">this code on ActiveState</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="classes-and-objects.html" class="navigation navigation-prev " aria-label="Previous page: 第八章：类与对象">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="module-and-pack.html" class="navigation navigation-next " aria-label="Next page: 第十章：模块与包">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第九章：元编程","level":"1.10","depth":1,"next":{"title":"第十章：模块与包","level":"1.11","depth":1,"path":"module-and-pack.md","ref":"module-and-pack.md","articles":[]},"previous":{"title":"第八章：类与对象","level":"1.9","depth":1,"path":"classes-and-objects.md","ref":"classes-and-objects.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"metaprogramming.md","mtime":"2025-01-09T21:48:32.002Z","type":"markdown"},"gitbook":{"version":"6.0.2","time":"2025-01-11T18:48:45.487Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

