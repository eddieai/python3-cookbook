
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第十一章：网络与 Web 编程 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="concurrent-programming.html" />
    
    
    <link rel="prev" href="module-and-pack.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="data-structures-and-algorithms.html">
            
                <a href="data-structures-and-algorithms.html">
            
                    
                    第一章：数据结构和算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="string-and-text.html">
            
                <a href="string-and-text.html">
            
                    
                    第二章：字符串和文本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="digital-date-and-time.html">
            
                <a href="digital-date-and-time.html">
            
                    
                    第三章：数字日期和时间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="iterators-and-generators.html">
            
                <a href="iterators-and-generators.html">
            
                    
                    第四章：迭代器与生成器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="files-and-io.html">
            
                <a href="files-and-io.html">
            
                    
                    第五章：文件与 IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="coding-and-processing-data.html">
            
                <a href="coding-and-processing-data.html">
            
                    
                    第六章：数据编码和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    第七章：函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="classes-and-objects.html">
            
                <a href="classes-and-objects.html">
            
                    
                    第八章：类与对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="metaprogramming.html">
            
                <a href="metaprogramming.html">
            
                    
                    第九章：元编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="module-and-pack.html">
            
                <a href="module-and-pack.html">
            
                    
                    第十章：模块与包
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.12" data-path="network-and-web-programming.html">
            
                <a href="network-and-web-programming.html">
            
                    
                    第十一章：网络与 Web 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="concurrent-programming.html">
            
                <a href="concurrent-programming.html">
            
                    
                    第十二章：并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="scripting-and-systems-management.html">
            
                <a href="scripting-and-systems-management.html">
            
                    
                    第十三章：脚本编程与系统管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="testing-debugging-and-exception.html">
            
                <a href="testing-debugging-and-exception.html">
            
                    
                    第十四章：测试、调试和异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="c-language-extensions.html">
            
                <a href="c-language-extensions.html">
            
                    
                    第十五章：C 语言扩展
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第十一章：网络与 Web 编程</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第十一章：网络与-web-编程">第十一章：网络与 Web 编程</h1>
<p>本章是关于在网络应用和分布式应用中使用的各种主题。主题划分为使用 Python 编写客户端程序来访问已有的服务，以及使用 Python 实现网络服务端程序。也给出了一些常见的技术，用于编写涉及协同或通信的的代码。</p>
<h1 id="111-作为客户端与-http-服务交互">11.1 作为客户端与 HTTP 服务交互</h1>
<h2 id="问题">问题</h2>
<p>你需要通过 HTTP 协议以客户端的方式访问多种服务。例如，下载数据或者与基于 REST 的 API 进行交互。</p>
<h2 id="解决方案">解决方案</h2>
<p>对于简单的事情来说，通常使用 <code>urllib.request</code> 模块就够了。例如，发送一个简单的 HTTP GET 请求到远程的服务上，可以这样做：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request, parse

<span class="hljs-comment"># Base URL being accessed</span>
url = <span class="hljs-string">'http://httpbin.org/get'</span>

<span class="hljs-comment"># Dictionary of query parameters (if any)</span>
parms = {
   <span class="hljs-string">'name1'</span> : <span class="hljs-string">'value1'</span>,
   <span class="hljs-string">'name2'</span> : <span class="hljs-string">'value2'</span>
}

<span class="hljs-comment"># Encode the query string</span>
querystring = parse.urlencode(parms)

<span class="hljs-comment"># Make a GET request and read the response</span>
u = request.urlopen(url+<span class="hljs-string">'?'</span> + querystring)
resp = u.read()
</code></pre>
<p>如果你需要使用 POST 方法在请求主体中发送查询参数，可以将参数编码后作为可选参数提供给 <code>urlopen()</code> 函数，就像这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request, parse

<span class="hljs-comment"># Base URL being accessed</span>
url = <span class="hljs-string">'http://httpbin.org/post'</span>

<span class="hljs-comment"># Dictionary of query parameters (if any)</span>
parms = {
   <span class="hljs-string">'name1'</span> : <span class="hljs-string">'value1'</span>,
   <span class="hljs-string">'name2'</span> : <span class="hljs-string">'value2'</span>
}

<span class="hljs-comment"># Encode the query string</span>
querystring = parse.urlencode(parms)

<span class="hljs-comment"># Make a POST request and read the response</span>
u = request.urlopen(url, querystring.encode(<span class="hljs-string">'ascii'</span>))
resp = u.read()
</code></pre>
<p>如果你需要在发出的请求中提供一些自定义的 HTTP 头，例如修改 <code>user-agent</code> 字段,可以创建一个包含字段值的字典，并创建一个 Request 实例然后将其传给 <code>urlopen()</code> ，如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request, parse
...

<span class="hljs-comment"># Extra headers</span>
headers = {
    <span class="hljs-string">'User-agent'</span> : <span class="hljs-string">'none/ofyourbusiness'</span>,
    <span class="hljs-string">'Spam'</span> : <span class="hljs-string">'Eggs'</span>
}

req = request.Request(url, querystring.encode(<span class="hljs-string">'ascii'</span>), headers=headers)

<span class="hljs-comment"># Make a request and read the response</span>
u = request.urlopen(req)
resp = u.read()
</code></pre>
<p>如果需要交互的服务比上面的例子都要复杂，也许应该去看看 requests 库（<a href="https://pypi.python.org/pypi/requests）。例如，下面这个示例采用" target="_blank">https://pypi.python.org/pypi/requests）。例如，下面这个示例采用</a> requests 库重新实现了上面的操作：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> requests

<span class="hljs-comment"># Base URL being accessed</span>
url = <span class="hljs-string">'http://httpbin.org/post'</span>

<span class="hljs-comment"># Dictionary of query parameters (if any)</span>
parms = {
   <span class="hljs-string">'name1'</span> : <span class="hljs-string">'value1'</span>,
   <span class="hljs-string">'name2'</span> : <span class="hljs-string">'value2'</span>
}

<span class="hljs-comment"># Extra headers</span>
headers = {
    <span class="hljs-string">'User-agent'</span> : <span class="hljs-string">'none/ofyourbusiness'</span>,
    <span class="hljs-string">'Spam'</span> : <span class="hljs-string">'Eggs'</span>
}

resp = requests.post(url, data=parms, headers=headers)

<span class="hljs-comment"># Decoded text returned by the request</span>
text = resp.text
</code></pre>
<p>关于 requests 库，一个值得一提的特性就是它能以多种方式从请求中返回响应结果的内容。从上面的代码来看， <code>resp.text</code> 带给我们的是以 Unicode 解码的响应文本。但是，如果去访问 <code>resp.content</code> ，就会得到原始的二进制数据。另一方面，如果访问 <code>resp.json</code> ，那么就会得到 JSON 格式的响应内容。</p>
<p>下面这个示例利用 <code>requests</code> 库发起一个 HEAD 请求，并从响应中提取出一些 HTTP 头数据的字段：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> requests

resp = requests.head(<span class="hljs-string">'http://www.python.org/index.html'</span>)

status = resp.status_code
last_modified = resp.headers[<span class="hljs-string">'last-modified'</span>]
content_type = resp.headers[<span class="hljs-string">'content-type'</span>]
content_length = resp.headers[<span class="hljs-string">'content-length'</span>]

Here <span class="hljs-keyword">is</span> a requests example that executes a login into the Python Package index using
basic authentication:
<span class="hljs-keyword">import</span> requests

resp = requests.get(<span class="hljs-string">'http://pypi.python.org/pypi?:action=login'</span>,
                    auth=(<span class="hljs-string">'user'</span>,<span class="hljs-string">'password'</span>))

Here <span class="hljs-keyword">is</span> an example of using requests to <span class="hljs-keyword">pass</span> HTTP cookies <span class="hljs-keyword">from</span> one request to the
<span class="hljs-built_in">next</span>:

<span class="hljs-keyword">import</span> requests

<span class="hljs-comment"># First request</span>
resp1 = requests.get(url)
...

<span class="hljs-comment"># Second requests with cookies received on first requests</span>
resp2 = requests.get(url, cookies=resp1.cookies)

Last, but <span class="hljs-keyword">not</span> least, here <span class="hljs-keyword">is</span> an example of using requests to upload content:

<span class="hljs-keyword">import</span> requests
url = <span class="hljs-string">'http://httpbin.org/post'</span>
files = { <span class="hljs-string">'file'</span>: (<span class="hljs-string">'data.csv'</span>, <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.csv'</span>, <span class="hljs-string">'rb'</span>)) }

r = requests.post(url, files=files)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>对于真的很简单 HTTP 客户端代码，用内置的 <code>urllib</code> 模块通常就足够了。但是，如果你要做的不仅仅只是简单的 GET 或 POST 请求，那就真的不能再依赖它的功能了。这时候就是第三方模块比如 <code>requests</code>大显身手的时候了。</p>
<p>例如，如果你决定坚持使用标准的程序库而不考虑像 <code>requests</code> 这样的第三方库，那么也许就不得不使用底层的 <code>http.client</code> 模块来实现自己的代码。比方说，下面的代码展示了如何执行一个 HEAD 请求：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> http.client <span class="hljs-keyword">import</span> HTTPConnection
<span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> parse

c = HTTPConnection(<span class="hljs-string">'www.python.org'</span>, <span class="hljs-number">80</span>)
c.request(<span class="hljs-string">'HEAD'</span>, <span class="hljs-string">'/index.html'</span>)
resp = c.getresponse()

<span class="hljs-built_in">print</span>(<span class="hljs-string">'Status'</span>, resp.status)
<span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> resp.getheaders():
    <span class="hljs-built_in">print</span>(name, value)
</code></pre>
<p>同样地，如果必须编写涉及代理、认证、cookies 以及其他一些细节方面的代码，那么使用 <code>urllib</code>就显得特别别扭和啰嗦。比方说，下面这个示例实现在 Python 包索引上的认证：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> urllib.request

auth = urllib.request.HTTPBasicAuthHandler()
auth.add_password(<span class="hljs-string">'pypi'</span>,<span class="hljs-string">'http://pypi.python.org'</span>,<span class="hljs-string">'username'</span>,<span class="hljs-string">'password'</span>)
opener = urllib.request.build_opener(auth)

r = urllib.request.Request(<span class="hljs-string">'http://pypi.python.org/pypi?:action=login'</span>)
u = opener.<span class="hljs-built_in">open</span>(r)
resp = u.read()

<span class="hljs-comment"># From here. You can access more pages using opener</span>
...
</code></pre>
<p>坦白说，所有的这些操作在 <code>requests</code>库中都变得简单的多。</p>
<p>在开发过程中测试 HTTP 客户端代码常常是很令人沮丧的，因为所有棘手的细节问题都需要考虑（例如 cookies、认证、HTTP 头、编码方式等）。要完成这些任务，考虑使用 httpbin 服务（<a href="http://httpbin.org）。这个站点会接收发出的请求，然后以" target="_blank">http://httpbin.org）。这个站点会接收发出的请求，然后以</a> JSON 的形式将相应信息回传回来。下面是一个交互式的例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests
<span class="hljs-meta">&gt;&gt;&gt; </span>r = requests.get(<span class="hljs-string">'http://httpbin.org/get?name=Dave&amp;n=37'</span>,
<span class="hljs-meta">... </span>    headers = { <span class="hljs-string">'User-agent'</span>: <span class="hljs-string">'goaway/1.0'</span> })
<span class="hljs-meta">&gt;&gt;&gt; </span>resp = r.json
<span class="hljs-meta">&gt;&gt;&gt; </span>resp[<span class="hljs-string">'headers'</span>]
{<span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'goaway/1.0'</span>, <span class="hljs-string">'Content-Length'</span>: <span class="hljs-string">''</span>, <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">''</span>,
<span class="hljs-string">'Accept-Encoding'</span>: <span class="hljs-string">'gzip, deflate, compress'</span>, <span class="hljs-string">'Connection'</span>:
<span class="hljs-string">'keep-alive'</span>, <span class="hljs-string">'Host'</span>: <span class="hljs-string">'httpbin.org'</span>, <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'*/*'</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>resp[<span class="hljs-string">'args'</span>]
{<span class="hljs-string">'name'</span>: <span class="hljs-string">'Dave'</span>, <span class="hljs-string">'n'</span>: <span class="hljs-string">'37'</span>}
&gt;&gt;&gt;
</code></pre>
<p>在要同一个真正的站点进行交互前，先在 httpbin.org 这样的网站上做实验常常是可取的办法。尤其是当我们面对3次登录失败就会关闭账户这样的风险时尤为有用（不要尝试自己编写 HTTP 认证客户端来登录你的银行账户）。</p>
<p>尽管本节没有涉及， <code>request</code> 库还对许多高级的 HTTP 客户端协议提供了支持，比如 OAuth。 <code>requests</code> 模块的文档（<a href="http://docs.python-requests.org)质量很高（坦白说比在这短短的一节的篇幅中所提供的任何信息都好），可以参考文档以获得更多地信息。" target="_blank">http://docs.python-requests.org)质量很高（坦白说比在这短短的一节的篇幅中所提供的任何信息都好），可以参考文档以获得更多地信息。</a></p>
<h1 id="112-创建-tcp-服务器">11.2 创建 TCP 服务器</h1>
<h2 id="问题">问题</h2>
<p>你想实现一个服务器，通过 TCP 协议和客户端通信。</p>
<h2 id="解决方案">解决方案</h2>
<p>创建一个 TCP 服务器的一个简单方法是使用 <code>socketserver</code> 库。例如，下面是一个简单的应答服务器：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socketserver <span class="hljs-keyword">import</span> BaseRequestHandler, TCPServer

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoHandler</span>(<span class="hljs-title class_ inherited__">BaseRequestHandler</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from'</span>, <span class="hljs-variable language_">self</span>.client_address)
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:

            msg = <span class="hljs-variable language_">self</span>.request.recv(<span class="hljs-number">8192</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
                <span class="hljs-keyword">break</span>
            <span class="hljs-variable language_">self</span>.request.send(msg)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    serv = TCPServer((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>), EchoHandler)
    serv.serve_forever()
</code></pre>
<p>在这段代码中，你定义了一个特殊的处理类，实现了一个 <code>handle()</code> 方法，用来为客户端连接服务。<code>request</code>属性是客户端 socket，<code>client_address</code> 有客户端地址。 为了测试这个服务器，运行它并打开另外一个 Python 进程连接这个服务器：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM
<span class="hljs-meta">&gt;&gt;&gt; </span>s = socket(AF_INET, SOCK_STREAM)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.connect((<span class="hljs-string">'localhost'</span>, <span class="hljs-number">20000</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>s.send(<span class="hljs-string">b'Hello'</span>)
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.recv(<span class="hljs-number">8192</span>)
<span class="hljs-string">b'Hello'</span>
&gt;&gt;&gt;
</code></pre>
<p>很多时候，可以很容易的定义一个不同的处理器。下面是一个使用 <code>StreamRequestHandler</code>基类将一个类文件接口放置在底层 socket 上的例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socketserver <span class="hljs-keyword">import</span> StreamRequestHandler, TCPServer

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoHandler</span>(<span class="hljs-title class_ inherited__">StreamRequestHandler</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from'</span>, <span class="hljs-variable language_">self</span>.client_address)
        <span class="hljs-comment"># self.rfile is a file-like object for reading</span>
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.rfile:
            <span class="hljs-comment"># self.wfile is a file-like object for writing</span>
            <span class="hljs-variable language_">self</span>.wfile.write(line)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    serv = TCPServer((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>), EchoHandler)
    serv.serve_forever()
</code></pre>
<h2 id="讨论">讨论</h2>
<p><code>socketserver</code> 可以让我们很容易的创建简单的 TCP 服务器。 但是，你需要注意的是，默认情况下这种服务器是单线程的，一次只能为一个客户端连接服务。 如果你想处理多个客户端，可以初始化一个 <code>ForkingTCPServer</code> 或者是 <code>ThreadingTCPServer</code> 对象。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socketserver <span class="hljs-keyword">import</span> ThreadingTCPServer


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    serv = ThreadingTCPServer((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>), EchoHandler)
    serv.serve_forever()
</code></pre>
<p>使用 fork 或线程服务器有个潜在问题就是它们会为每个客户端连接创建一个新的进程或线程。 由于客户端连接数是没有限制的，因此一个恶意的黑客可以同时发送大量的连接让你的服务器奔溃。</p>
<p>如果你担心这个问题，你可以创建一个预先分配大小的工作线程池或进程池。 你先创建一个普通的非线程服务器，然后在一个线程池中使用 <code>serve_forever()</code> 方法来启动它们。</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
    NWORKERS = <span class="hljs-number">16</span>
    serv = TCPServer((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>), EchoHandler)
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(NWORKERS):
        t = Thread(target=serv.serve_forever)
        t.daemon = <span class="hljs-literal">True</span>
        t.start()
    serv.serve_forever()
</code></pre>
<p>一般来讲，一个 <code>TCPServer</code> 在实例化的时候会绑定并激活相应的 <code>socket</code>。 不过，有时候你想通过设置某些选项去调整底下的 <code>socket</code> ，可以设置参数 <code>bind_and_activate=False</code>。如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    serv = TCPServer((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>), EchoHandler, bind_and_activate=<span class="hljs-literal">False</span>)
    <span class="hljs-comment"># Set up various socket options</span>
    serv.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-literal">True</span>)
    <span class="hljs-comment"># Bind and activate</span>
    serv.server_bind()
    serv.server_activate()
    serv.serve_forever()
</code></pre>
<p>上面的<code>socket</code>选项是一个非常普遍的配置项，它允许服务器重新绑定一个之前使用过的端口号。 由于要被经常使用到，它被放置到类变量中，可以直接在 <code>TCPServer</code> 上面设置。 在实例化服务器的时候去设置它的值，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    TCPServer.allow_reuse_address = <span class="hljs-literal">True</span>
    serv = TCPServer((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>), EchoHandler)
    serv.serve_forever()
</code></pre>
<p>在上面示例中，我们演示了两种不同的处理器基类（ <code>BaseRequestHandler</code>和 <code>StreamRequestHandler</code> ）。 <code>StreamRequestHandler</code>更加灵活点，能通过设置其他的类变量来支持一些新的特性。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> socket

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoHandler</span>(<span class="hljs-title class_ inherited__">StreamRequestHandler</span>):
    <span class="hljs-comment"># Optional settings (defaults shown)</span>
    timeout = <span class="hljs-number">5</span>                      <span class="hljs-comment"># Timeout on all socket operations</span>
    rbufsize = -<span class="hljs-number">1</span>                    <span class="hljs-comment"># Read buffer size</span>
    wbufsize = <span class="hljs-number">0</span>                     <span class="hljs-comment"># Write buffer size</span>
    disable_nagle_algorithm = <span class="hljs-literal">False</span>  <span class="hljs-comment"># Sets TCP_NODELAY socket option</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from'</span>, <span class="hljs-variable language_">self</span>.client_address)
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.rfile:
                <span class="hljs-comment"># self.wfile is a file-like object for writing</span>
                <span class="hljs-variable language_">self</span>.wfile.write(line)
        <span class="hljs-keyword">except</span> socket.timeout:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Timed out!'</span>)
</code></pre>
<p>最后，还需要注意的是巨大部分 Python 的高层网络模块（比如 HTTP、XML-RPC 等）都是建立在 s<code>ocketserver</code> 功能之上。 也就是说，直接使用 <code>socket</code> 库来实现服务器也并不是很难。 下面是一个使用 <code>socket</code>直接编程实现的一个服务器简单例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_handler</span>(<span class="hljs-params">address, client_sock</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from {}'</span>.<span class="hljs-built_in">format</span>(address))
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        msg = client_sock.recv(<span class="hljs-number">8192</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
            <span class="hljs-keyword">break</span>
        client_sock.sendall(msg)
    client_sock.close()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_server</span>(<span class="hljs-params">address, backlog=<span class="hljs-number">5</span></span>):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(address)
    sock.listen(backlog)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client_sock, client_addr = sock.accept()
        echo_handler(client_addr, client_sock)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    echo_server((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>))
</code></pre>
<h1 id="113-创建-udp-服务器">11.3 创建 UDP 服务器</h1>
<h2 id="问题">问题</h2>
<p>你想实现一个基于 UDP 协议的服务器来与客户端通信。</p>
<h2 id="解决方案">解决方案</h2>
<p>跟 TCP 一样，UDP 服务器也可以通过使用 <code>socketserver</code> 库很容易的被创建。 例如，下面是一个简单的时间服务器：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socketserver <span class="hljs-keyword">import</span> BaseRequestHandler, UDPServer
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeHandler</span>(<span class="hljs-title class_ inherited__">BaseRequestHandler</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from'</span>, <span class="hljs-variable language_">self</span>.client_address)
        <span class="hljs-comment"># Get message and client socket</span>
        msg, sock = <span class="hljs-variable language_">self</span>.request
        resp = time.ctime()
        sock.sendto(resp.encode(<span class="hljs-string">'ascii'</span>), <span class="hljs-variable language_">self</span>.client_address)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    serv = UDPServer((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>), TimeHandler)
    serv.serve_forever()
</code></pre>
<p>跟之前一样，你先定义一个实现 <code>handle()</code>特殊方法的类，为客户端连接服务。 这个类的 <code>request</code> 属性是一个包含了数据报和底层 socket 对象的元组。<code>client_address</code>包含了客户端地址。</p>
<p>我们来测试下这个服务器，首先运行它，然后打开另外一个 Python 进程向服务器发送消息：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_DGRAM
<span class="hljs-meta">&gt;&gt;&gt; </span>s = socket(AF_INET, SOCK_DGRAM)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.sendto(<span class="hljs-string">b''</span>, (<span class="hljs-string">'localhost'</span>, <span class="hljs-number">20000</span>))
<span class="hljs-number">0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.recvfrom(<span class="hljs-number">8192</span>)
(<span class="hljs-string">b'Wed Aug 15 20:35:08 2012'</span>, (<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">20000</span>))
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>一个典型的 UPD 服务器接收到达的数据报(消息)和客户端地址。如果服务器需要做应答， 它要给客户端回发一个数据报。对于数据报的传送， 你应该使用 socket 的 <code>sendto()</code> 和 <code>recvfrom()</code>方法。 尽管传统的 <code>send()</code> 和 <code>recv()</code>也可以达到同样的效果， 但是前面的两个方法对于 UDP 连接而言更普遍。</p>
<p>由于没有底层的连接，UPD 服务器相对于 TCP 服务器来讲实现起来更加简单。 不过，UDP 天生是不可靠的（因为通信没有建立连接，消息可能丢失）。 因此需要由你自己来决定该怎样处理丢失消息的情况。这个已经不在本书讨论范围内了， 不过通常来说，如果可靠性对于你程序很重要，你需要借助于序列号、重试、超时以及一些其他方法来保证。 UDP 通常被用在那些对于可靠传输要求不是很高的场合。例如，在实时应用如多媒体流以及游戏领域， 无需返回恢复丢失的数据包（程序只需简单的忽略它并继续向前运行）。</p>
<p><code>UDPServer</code>类是单线程的，也就是说一次只能为一个客户端连接服务。 实际使用中，这个无论是对于 UDP 还是 TCP 都不是什么大问题。 如果你想要并发操作，可以实例化一个 <code>ForkingUDPServer</code> 或 <code>ThreadingUDPServer</code> 对象：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socketserver <span class="hljs-keyword">import</span> ThreadingUDPServer

   <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    serv = ThreadingUDPServer((<span class="hljs-string">''</span>,<span class="hljs-number">20000</span>), TimeHandler)
    serv.serve_forever()
</code></pre>
<p>直接使用 <code>socket</code> 来是想一个 UDP 服务器也不难，下面是一个例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_DGRAM
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">def</span> <span class="hljs-title function_">time_server</span>(<span class="hljs-params">address</span>):
    sock = socket(AF_INET, SOCK_DGRAM)
    sock.bind(address)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        msg, addr = sock.recvfrom(<span class="hljs-number">8192</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got message from'</span>, addr)
        resp = time.ctime()
        sock.sendto(resp.encode(<span class="hljs-string">'ascii'</span>), addr)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    time_server((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>))
</code></pre>
<h1 id="114-通过-cidr-地址生成对应的-ip-地址集">11.4 通过 CIDR 地址生成对应的 IP 地址集</h1>
<h2 id="问题">问题</h2>
<p>你有一个 CIDR 网络地址比如“123.45.67.89/27”，你想将其转换成它所代表的所有 IP （比如，“123.45.67.64”, “123.45.67.65”, …, “123.45.67.95”)）</p>
<h2 id="解决方案">解决方案</h2>
<p>可以使用 <code>ipaddress</code> 模块很容易的实现这样的计算。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> ipaddress
<span class="hljs-meta">&gt;&gt;&gt; </span>net = ipaddress.ip_network(<span class="hljs-string">'123.45.67.64/27'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>net
IPv4Network(<span class="hljs-string">'123.45.67.64/27'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> net:
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a)
...
<span class="hljs-number">123.45</span><span class="hljs-number">.67</span><span class="hljs-number">.64</span>
<span class="hljs-number">123.45</span><span class="hljs-number">.67</span><span class="hljs-number">.65</span>
<span class="hljs-number">123.45</span><span class="hljs-number">.67</span><span class="hljs-number">.66</span>
<span class="hljs-number">123.45</span><span class="hljs-number">.67</span><span class="hljs-number">.67</span>
<span class="hljs-number">123.45</span><span class="hljs-number">.67</span><span class="hljs-number">.68</span>
...
<span class="hljs-number">123.45</span><span class="hljs-number">.67</span><span class="hljs-number">.95</span>
&gt;&gt;&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>net6 = ipaddress.ip_network(<span class="hljs-string">'12:3456:78:90ab:cd:ef01:23:30/125'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>net6
IPv6Network(<span class="hljs-string">'12:3456:78:90ab:cd:ef01:23:30/125'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> net6:
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a)
...
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">30</span>
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">31</span>
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">32</span>
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">33</span>
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">34</span>
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">35</span>
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">36</span>
<span class="hljs-number">12</span>:<span class="hljs-number">3456</span>:<span class="hljs-number">78</span>:90ab:cd:ef01:<span class="hljs-number">23</span>:<span class="hljs-number">37</span>
&gt;&gt;&gt;
</code></pre>
<p><code>Network</code>也允许像数组一样的索引取值，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>net.num_addresses
<span class="hljs-number">32</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>net[<span class="hljs-number">0</span>]

IPv4Address(<span class="hljs-string">'123.45.67.64'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>net[<span class="hljs-number">1</span>]
IPv4Address(<span class="hljs-string">'123.45.67.65'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>net[-<span class="hljs-number">1</span>]
IPv4Address(<span class="hljs-string">'123.45.67.95'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>net[-<span class="hljs-number">2</span>]
IPv4Address(<span class="hljs-string">'123.45.67.94'</span>)
&gt;&gt;&gt;
</code></pre>
<p>另外，你还可以执行网络成员检查之类的操作：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = ipaddress.ip_address(<span class="hljs-string">'123.45.67.69'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">in</span> net
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>b = ipaddress.ip_address(<span class="hljs-string">'123.45.67.123'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b <span class="hljs-keyword">in</span> net
<span class="hljs-literal">False</span>
&gt;&gt;&gt;
</code></pre>
<p>一个 IP 地址和网络地址能通过一个 IP 接口来指定，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>inet = ipaddress.ip_interface(<span class="hljs-string">'123.45.67.73/27'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inet.network
IPv4Network(<span class="hljs-string">'123.45.67.64/27'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inet.ip
IPv4Address(<span class="hljs-string">'123.45.67.73'</span>)
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p><code>ipaddress</code> 模块有很多类可以表示 IP 地址、网络和接口。 当你需要操作网络地址（比如解析、打印、验证等）的时候会很有用。</p>
<p>要注意的是，<code>ipaddress</code>模块跟其他一些和网络相关的模块比如 <code>socket</code>库交集很少。 所以，你不能使用 <code>IPv4Address</code> 的实例来代替一个地址字符串，你首先得显式的使用<code>str()</code>转换它。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = ipaddress.ip_address(<span class="hljs-string">'127.0.0.1'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM
<span class="hljs-meta">&gt;&gt;&gt; </span>s = socket(AF_INET, SOCK_STREAM)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.connect((a, <span class="hljs-number">8080</span>))
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: Can<span class="hljs-string">'t convert '</span>IPv4Address<span class="hljs-string">' object to str implicitly
&gt;&gt;&gt; s.connect((str(a), 8080))
&gt;&gt;&gt;
</span></code></pre>
<p>更多相关内容，请参考 <a href="https://docs.python.org/3/howto/ipaddress.html" target="_blank">An Introduction to the ipaddress Module</a></p>
<h1 id="115-创建一个简单的-rest-接口">11.5 创建一个简单的 REST 接口</h1>
<h2 id="问题">问题</h2>
<p>你想使用一个简单的 REST 接口通过网络远程控制或访问你的应用程序，但是你又不想自己去安装一个完整的 web 框架。</p>
<h2 id="解决方案">解决方案</h2>
<p>构建一个 REST 风格的接口最简单的方法是创建一个基于 WSGI 标准（PEP 3333）的很小的库，下面是一个例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># resty.py</span>

<span class="hljs-keyword">import</span> cgi

<span class="hljs-keyword">def</span> <span class="hljs-title function_">notfound_404</span>(<span class="hljs-params">environ, start_response</span>):
    start_response(<span class="hljs-string">'404 Not Found'</span>, [ (<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'text/plain'</span>) ])
    <span class="hljs-keyword">return</span> [<span class="hljs-string">b'Not Found'</span>]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PathDispatcher</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.pathmap = { }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, environ, start_response</span>):
        path = environ[<span class="hljs-string">'PATH_INFO'</span>]
        params = cgi.FieldStorage(environ[<span class="hljs-string">'wsgi.input'</span>],
                                  environ=environ)
        method = environ[<span class="hljs-string">'REQUEST_METHOD'</span>].lower()
        environ[<span class="hljs-string">'params'</span>] = { key: params.getvalue(key) <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> params }
        handler = <span class="hljs-variable language_">self</span>.pathmap.get((method,path), notfound_404)
        <span class="hljs-keyword">return</span> handler(environ, start_response)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">self, method, path, function</span>):
        <span class="hljs-variable language_">self</span>.pathmap[method.lower(), path] = function
        <span class="hljs-keyword">return</span> function
</code></pre>
<p>为了使用这个调度器，你只需要编写不同的处理器，就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time

_hello_resp = <span class="hljs-string">'''\
&lt;html&gt;
  &lt;head&gt;
     &lt;title&gt;Hello {name}&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;h1&gt;Hello {name}!&lt;/h1&gt;
   &lt;/body&gt;
&lt;/html&gt;'''</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>(<span class="hljs-params">environ, start_response</span>):
    start_response(<span class="hljs-string">'200 OK'</span>, [ (<span class="hljs-string">'Content-type'</span>,<span class="hljs-string">'text/html'</span>)])
    params = environ[<span class="hljs-string">'params'</span>]
    resp = _hello_resp.<span class="hljs-built_in">format</span>(name=params.get(<span class="hljs-string">'name'</span>))
    <span class="hljs-keyword">yield</span> resp.encode(<span class="hljs-string">'utf-8'</span>)

_localtime_resp = <span class="hljs-string">'''\
&lt;?xml version="1.0"?&gt;
&lt;time&gt;
  &lt;year&gt;{t.tm_year}&lt;/year&gt;
  &lt;month&gt;{t.tm_mon}&lt;/month&gt;
  &lt;day&gt;{t.tm_mday}&lt;/day&gt;
  &lt;hour&gt;{t.tm_hour}&lt;/hour&gt;
  &lt;minute&gt;{t.tm_min}&lt;/minute&gt;
  &lt;second&gt;{t.tm_sec}&lt;/second&gt;
&lt;/time&gt;'''</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">localtime</span>(<span class="hljs-params">environ, start_response</span>):
    start_response(<span class="hljs-string">'200 OK'</span>, [ (<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'application/xml'</span>) ])
    resp = _localtime_resp.<span class="hljs-built_in">format</span>(t=time.localtime())
    <span class="hljs-keyword">yield</span> resp.encode(<span class="hljs-string">'utf-8'</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">from</span> resty <span class="hljs-keyword">import</span> PathDispatcher
    <span class="hljs-keyword">from</span> wsgiref.simple_server <span class="hljs-keyword">import</span> make_server

    <span class="hljs-comment"># Create the dispatcher and register functions</span>
    dispatcher = PathDispatcher()
    dispatcher.register(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/hello'</span>, hello_world)
    dispatcher.register(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/localtime'</span>, localtime)

    <span class="hljs-comment"># Launch a basic server</span>
    httpd = make_server(<span class="hljs-string">''</span>, <span class="hljs-number">8080</span>, dispatcher)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Serving on port 8080...'</span>)
    httpd.serve_forever()
</code></pre>
<p>要测试下这个服务器，你可以使用一个浏览器或 <code>urllib</code>和它交互。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>u = urlopen(<span class="hljs-string">'http://localhost:8080/hello?name=Guido'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(u.read().decode(<span class="hljs-string">'utf-8'</span>))
&lt;html&gt;
  &lt;head&gt;
     &lt;title&gt;Hello Guido&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;h1&gt;Hello Guido!&lt;/h1&gt;
   &lt;/body&gt;
&lt;/html&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>u = urlopen(<span class="hljs-string">'http://localhost:8080/localtime'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(u.read().decode(<span class="hljs-string">'utf-8'</span>))
&lt;?xml version=<span class="hljs-string">"1.0"</span>?&gt;
&lt;time&gt;
  &lt;year&gt;<span class="hljs-number">2012</span>&lt;/year&gt;
  &lt;month&gt;<span class="hljs-number">11</span>&lt;/month&gt;
  &lt;day&gt;<span class="hljs-number">24</span>&lt;/day&gt;
  &lt;hour&gt;<span class="hljs-number">14</span>&lt;/hour&gt;
  &lt;minute&gt;<span class="hljs-number">49</span>&lt;/minute&gt;
  &lt;second&gt;<span class="hljs-number">17</span>&lt;/second&gt;
&lt;/time&gt;
&gt;&gt;&gt;
</code></pre>
<p>讨论
在编写 REST 接口时，通常都是服务于普通的 HTTP 请求。但是跟那些功能完整的网站相比，你通常只需要处理数据。 这些数据以各种标准格式编码，比如 XML、JSON 或 CSV。 尽管程序看上去很简单，但是以这种方式提供的 API 对于很多应用程序来讲是非常有用的。</p>
<p>例如，长期运行的程序可能会使用一个 REST API 来实现监控或诊断。 大数据应用程序可以使用 REST 来构建一个数据查询或提取系统。 REST 还能用来控制硬件设备比如机器人、传感器、工厂或灯泡。 更重要的是，REST API 已经被大量客户端编程环境所支持，比如 Javascript, Android, iOS 等。 因此，利用这种接口可以让你开发出更加复杂的应用程序。</p>
<p>为了实现一个简单的 REST 接口，你只需让你的程序代码满足 Python 的 WSGI 标准即可。 WSGI 被标准库支持，同时也被绝大部分第三方 web 框架支持。 因此，如果你的代码遵循这个标准，在后面的使用过程中就会更加的灵活！</p>
<p>在 WSGI 中，你可以像下面这样约定的方式以一个可调用对象形式来实现你的程序。</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> cgi

<span class="hljs-keyword">def</span> <span class="hljs-title function_">wsgi_app</span>(<span class="hljs-params">environ, start_response</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p><code>environ</code>属性是一个字典，包含了从 web 服务器如 Apache [参考 Internet RFC 3875]提供的 CGI 接口中获取的值。 要将这些不同的值提取出来，你可以像这么这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wsgi_app</span>(<span class="hljs-params">environ, start_response</span>):
    method = environ[<span class="hljs-string">'REQUEST_METHOD'</span>]
    path = environ[<span class="hljs-string">'PATH_INFO'</span>]
    <span class="hljs-comment"># Parse the query parameters</span>
    params = cgi.FieldStorage(environ[<span class="hljs-string">'wsgi.input'</span>], environ=environ)
</code></pre>
<p>我们展示了一些常见的值。<code>environ['REQUEST_METHOD']</code>代表请求类型如 GET、POST、HEAD 等。 <code>environ['PATH_INFO']</code>表示被请求资源的路径。 调用 <code>cgi.FieldStorage()</code>可以从请求中提取查询参数并将它们放入一个类字典对象中以便后面使用。</p>
<p><code>start_response</code>参数是一个为了初始化一个请求对象而必须被调用的函数。 第一个参数是返回的 HTTP 状态值，第二个参数是一个(名,值)元组列表，用来构建返回的 HTTP 头。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wsgi_app</span>(<span class="hljs-params">environ, start_response</span>):
    <span class="hljs-keyword">pass</span>
    start_response(<span class="hljs-string">'200 OK'</span>, [(<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'text/plain'</span>)])
</code></pre>
<p>为了返回数据，一个 WSGI 程序必须返回一个字节字符串序列。可以像下面这样使用一个列表来完成：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wsgi_app</span>(<span class="hljs-params">environ, start_response</span>):
    <span class="hljs-keyword">pass</span>
    start_response(<span class="hljs-string">'200 OK'</span>, [(<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'text/plain'</span>)])
    resp = []
    resp.append(<span class="hljs-string">b'Hello World\n'</span>)
    resp.append(<span class="hljs-string">b'Goodbye!\n'</span>)
    <span class="hljs-keyword">return</span> resp
</code></pre>
<p>或者，你还可以使用<code>yield</code> ：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wsgi_app</span>(<span class="hljs-params">environ, start_response</span>):
    <span class="hljs-keyword">pass</span>
    start_response(<span class="hljs-string">'200 OK'</span>, [(<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'text/plain'</span>)])
    <span class="hljs-keyword">yield</span> <span class="hljs-string">b'Hello World\n'</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-string">b'Goodbye!\n'</span>
</code></pre>
<p>这里要强调的一点是最后返回的必须是字节字符串。如果返回结果包含文本字符串，必须先将其编码成字节。 当然，并没有要求你返回的一点是文本，你可以很轻松的编写一个生成图片的程序。</p>
<p>尽管 WSGI 程序通常被定义成一个函数，不过你也可以使用类实例来实现，只要它实现了合适的 <code>__call__()</code> 方法。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WSGIApplication</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        ...
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, environ, start_response</span>)
       ...
</code></pre>
<p>我们已经在上面使用这种技术创建 <code>PathDispatcher</code> 类。 这个分发器仅仅只是管理一个字典，将(方法,路径)对映射到处理器函数上面。 当一个请求到来时，它的方法和路径被提取出来，然后被分发到对应的处理器上面去。 另外，任何查询变量会被解析后放到一个字典中，以 <code>environ['params']</code> 形式存储。 后面这个步骤太常见，所以建议你在分发器里面完成，这样可以省掉很多重复代码。 使用分发器的时候，你只需简单的创建一个实例，然后通过它注册各种 WSGI 形式的函数。 编写这些函数应该超级简单了，只要你遵循 <code>start_response()</code> 函数的编写规则，并且最后返回字节字符串即可。</p>
<p>当编写这种函数的时候还需注意的一点就是对于字符串模板的使用。 没人愿意写那种到处混合着 <code>print()</code> 函数 、XML 和大量格式化操作的代码。 我们上面使用了三引号包含的预先定义好的字符串模板。 这种方式的可以让我们很容易的在以后修改输出格式(只需要修改模板本身，而不用动任何使用它的地方)。</p>
<p>最后，使用 WSGI 还有一个很重要的部分就是没有什么地方是针对特定 web 服务器的。 因为标准对于服务器和框架是中立的，你可以将你的程序放入任何类型服务器中。 我们使用下面的代码测试测试本节代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">from</span> wsgiref.simple_server <span class="hljs-keyword">import</span> make_server

    <span class="hljs-comment"># Create the dispatcher and register functions</span>
    dispatcher = PathDispatcher()
    <span class="hljs-keyword">pass</span>

    <span class="hljs-comment"># Launch a basic server</span>
    httpd = make_server(<span class="hljs-string">''</span>, <span class="hljs-number">8080</span>, dispatcher)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Serving on port 8080...'</span>)
    httpd.serve_forever()
</code></pre>
<p>上面代码创建了一个简单的服务器，然后你就可以来测试下你的实现是否能正常工作。 最后，当你准备进一步扩展你的程序的时候，你可以修改这个代码，让它可以为特定服务器工作。</p>
<p>WSGI 本身是一个很小的标准。因此它并没有提供一些高级的特性比如认证、cookies、重定向等。 这些你自己实现起来也不难。不过如果你想要更多的支持，可以考虑第三方库，比如<code>WebOb</code> 或者<code>Paste</code></p>
<h1 id="116-通过-xml-rpc-实现简单的远程调用">11.6 通过 XML-RPC 实现简单的远程调用</h1>
<h2 id="问题">问题</h2>
<p>你想找到一个简单的方式去执行运行在远程机器上面的 Python 程序中的函数或方法。</p>
<h2 id="解决方案">解决方案</h2>
<p>实现一个远程方法调用的最简单方式是使用 XML-RPC。下面我们演示一下一个实现了键-值存储功能的简单服务器：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> xmlrpc.server <span class="hljs-keyword">import</span> SimpleXMLRPCServer

<span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyValueServer</span>:
    _rpc_methods_ = [<span class="hljs-string">'get'</span>, <span class="hljs-string">'set'</span>, <span class="hljs-string">'delete'</span>, <span class="hljs-string">'exists'</span>, <span class="hljs-string">'keys'</span>]
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, address</span>):
        <span class="hljs-variable language_">self</span>._data = {}
        <span class="hljs-variable language_">self</span>._serv = SimpleXMLRPCServer(address, allow_none=<span class="hljs-literal">True</span>)
        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._rpc_methods_:
            <span class="hljs-variable language_">self</span>._serv.register_function(<span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, name))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._data[name]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, name, value</span>):
        <span class="hljs-variable language_">self</span>._data[name] = value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>._data[name]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exists</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">return</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._data

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">keys</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>._data)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">serve_forever</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._serv.serve_forever()

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    kvserv = KeyValueServer((<span class="hljs-string">''</span>, <span class="hljs-number">15000</span>))
    kvserv.serve_forever()
</code></pre>
<p>下面我们从一个客户端机器上面来访问服务器：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> xmlrpc.client <span class="hljs-keyword">import</span> ServerProxy
<span class="hljs-meta">&gt;&gt;&gt; </span>s = ServerProxy(<span class="hljs-string">'http://localhost:15000'</span>, allow_none=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.<span class="hljs-built_in">set</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.<span class="hljs-built_in">set</span>(<span class="hljs-string">'spam'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>s.keys()
[<span class="hljs-string">'spam'</span>, <span class="hljs-string">'foo'</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>s.get(<span class="hljs-string">'foo'</span>)
<span class="hljs-string">'bar'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.get(<span class="hljs-string">'spam'</span>)
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>s.delete(<span class="hljs-string">'spam'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.exists(<span class="hljs-string">'spam'</span>)
<span class="hljs-literal">False</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>XML-RPC 可以让我们很容易的构造一个简单的远程调用服务。你所需要做的仅仅是创建一个服务器实例， 通过它的方法 <code>register_function()</code>来注册函数，然后使用方法 <code>serve_forever()</code>启动它。 在上面我们将这些步骤放在一起写到一个类中，不够这并不是必须的。比如你还可以像下面这样创建一个服务器：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> xmlrpc.server <span class="hljs-keyword">import</span> SimpleXMLRPCServer
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):
    <span class="hljs-keyword">return</span> x+y

serv = SimpleXMLRPCServer((<span class="hljs-string">''</span>, <span class="hljs-number">15000</span>))
serv.register_function(add)
serv.serve_forever()
</code></pre>
<p>XML-RPC 暴露出来的函数只能适用于部分数据类型，比如字符串、整形、列表和字典。 对于其他类型就得需要做些额外的功课了。 例如，如果你想通过 XML-RPC 传递一个对象实例，实际上只有他的实例字典被处理：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):
<span class="hljs-meta">... </span>            <span class="hljs-variable language_">self</span>.x = x
<span class="hljs-meta">... </span>            <span class="hljs-variable language_">self</span>.y = y
...
<span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.<span class="hljs-built_in">set</span>(<span class="hljs-string">'foo'</span>, p)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.get(<span class="hljs-string">'foo'</span>)
{<span class="hljs-string">'x'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'y'</span>: <span class="hljs-number">3</span>}
&gt;&gt;&gt;
</code></pre>
<p>类似的，对于二进制数据的处理也跟你想象的不太一样：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s.<span class="hljs-built_in">set</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-string">b'Hello World'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.get(<span class="hljs-string">'foo'</span>)
&lt;xmlrpc.client.Binary <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10131d410</span>&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span>_.data
<span class="hljs-string">b'Hello World'</span>
&gt;&gt;&gt;
</code></pre>
<p>一般来讲，你不应该将 XML-RPC 服务以公共 API 的方式暴露出来。 对于这种情况，通常分布式应用程序会是一个更好的选择。</p>
<p>XML-RPC 的一个缺点是它的性能。<code>SimpleXMLRPCServer</code> 的实现是单线程的， 所以它不适合于大型程序，尽管我们在11.2小节中演示过它是可以通过多线程来执行的。 另外，由于 XML-RPC 将所有数据都序列化为 XML 格式，所以它会比其他的方式运行的慢一些。 但是它也有优点，这种方式的编码可以被绝大部分其他编程语言支持。 通过使用这种方式，其他语言的客户端程序都能访问你的服务。</p>
<p>虽然 XML-RPC 有很多缺点，但是如果你需要快速构建一个简单远程过程调用系统的话，它仍然值得去学习的。 有时候，简单的方案就已经足够了。</p>
<h1 id="117-在不同的-python-解释器之间交互">11.7 在不同的 Python 解释器之间交互</h1>
<h2 id="问题">问题</h2>
<p>你在不同的机器上面运行着多个 Python 解释器实例，并希望能够在这些解释器之间通过消息来交换数据。</p>
<h2 id="解决方案">解决方案</h2>
<p>通过使用 <code>multiprocessing.connection</code>模块可以很容易的实现解释器之间的通信。 下面是一个简单的应答服务器例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> multiprocessing.connection <span class="hljs-keyword">import</span> Listener
<span class="hljs-keyword">import</span> traceback

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_client</span>(<span class="hljs-params">conn</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            msg = conn.recv()
            conn.send(msg)
    <span class="hljs-keyword">except</span> EOFError:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Connection closed'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_server</span>(<span class="hljs-params">address, authkey</span>):
    serv = Listener(address, authkey=authkey)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">try</span>:
            client = serv.accept()

            echo_client(client)
        <span class="hljs-keyword">except</span> Exception:
            traceback.print_exc()

echo_server((<span class="hljs-string">''</span>, <span class="hljs-number">25000</span>), authkey=<span class="hljs-string">b'peekaboo'</span>)
</code></pre>
<p>然后客户端连接服务器并发送消息的简单示例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> multiprocessing.connection <span class="hljs-keyword">import</span> Client
<span class="hljs-meta">&gt;&gt;&gt; </span>c = Client((<span class="hljs-string">'localhost'</span>, <span class="hljs-number">25000</span>), authkey=<span class="hljs-string">b'peekaboo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c.send(<span class="hljs-string">'hello'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c.recv()
<span class="hljs-string">'hello'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.send(<span class="hljs-number">42</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c.recv()
<span class="hljs-number">42</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.send([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>c.recv()
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
&gt;&gt;&gt;
</code></pre>
<p>跟底层 socket 不同的是，每个消息会完整保存（每一个通过 send()发送的对象能通过 recv()来完整接受）。 另外，所有对象会通过 pickle 序列化。因此，任何兼容 pickle 的对象都能在此连接上面被发送和接受。</p>
<h2 id="讨论">讨论</h2>
<p>目前有很多用来实现各种消息传输的包和函数库，比如 ZeroMQ、Celery 等。 你还有另外一种选择就是自己在底层 socket 基础之上来实现一个消息传输层。 但是你想要简单一点的方案，那么这时候 <code>multiprocessing.connection</code> 就派上用场了。 仅仅使用一些简单的语句即可实现多个解释器之间的消息通信。</p>
<p>如果你的解释器运行在同一台机器上面，那么你可以使用另外的通信机制，比如 Unix 域套接字或者是 Windows 命名管道。 要想使用 UNIX 域套接字来创建一个连接，只需简单的将地址改写一个文件名即可：</p>
<pre><code class="lang-python">s = Listener(<span class="hljs-string">'/tmp/myconn'</span>, authkey=<span class="hljs-string">b'peekaboo'</span>)
</code></pre>
<p>要想使用 Windows 命名管道来创建连接，只需像下面这样使用一个文件名：</p>
<pre><code class="lang-python">s = Listener(<span class="hljs-string">r'\\.\pipe\myconn'</span>, authkey=<span class="hljs-string">b'peekaboo'</span>)
</code></pre>
<p>一个通用准则是，你不要使用 <code>multiprocessing</code> 来实现一个对外的公共服务。 <code>Client()</code> 和 <code>Listener()</code> 中的 <code>authkey</code> 参数用来认证发起连接的终端用户。 如果密钥不对会产生一个异常。此外，该模块最适合用来建立长连接（而不是大量的短连接）， 例如，两个解释器之间启动后就开始建立连接并在处理某个问题过程中会一直保持连接状态。</p>
<p>如果你需要对底层连接做更多的控制，比如需要支持超时、非阻塞 I/O 或其他类似的特性， 你最好使用另外的库或者是在高层 socket 上来实现这些特性。</p>
<h1 id="118-实现远程方法调用">11.8 实现远程方法调用</h1>
<h2 id="问题">问题</h2>
<p>你想在一个消息传输层如 <code>sockets</code> 、<code>multiprocessing connections</code> 或 <code>ZeroMQ</code>的基础之上实现一个简单的远程过程调用（RPC）。</p>
<h2 id="解决方案">解决方案</h2>
<p>将函数请求、参数和返回值使用 pickle 编码后，在不同的解释器直接传送 pickle 字节字符串，可以很容易的实现 RPC。 下面是一个简单的 PRC 处理器，可以被整合到一个服务器中去：</p>
<pre><code class="lang-python"><span class="hljs-comment"># rpcserver.py</span>

<span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCHandler</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._functions = { }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">register_function</span>(<span class="hljs-params">self, func</span>):
        <span class="hljs-variable language_">self</span>._functions[func.__name__] = func

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-params">self, connection</span>):
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                <span class="hljs-comment"># Receive a message</span>
                func_name, args, kwargs = pickle.loads(connection.recv())
                <span class="hljs-comment"># Run the RPC and send a response</span>
                <span class="hljs-keyword">try</span>:
                    r = <span class="hljs-variable language_">self</span>._functions[func_name](*args,**kwargs)
                    connection.send(pickle.dumps(r))
                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
                    connection.send(pickle.dumps(e))
        <span class="hljs-keyword">except</span> EOFError:
             <span class="hljs-keyword">pass</span>
</code></pre>
<p>要使用这个处理器，你需要将它加入到一个消息服务器中。你有很多种选择， 但是使用 <code>multiprocessing</code> 库是最简单的。下面是一个 RPC 服务器例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> multiprocessing.connection <span class="hljs-keyword">import</span> Listener
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread

<span class="hljs-keyword">def</span> <span class="hljs-title function_">rpc_server</span>(<span class="hljs-params">handler, address, authkey</span>):
    sock = Listener(address, authkey=authkey)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client = sock.accept()
        t = Thread(target=handler.handle_connection, args=(client,))
        t.daemon = <span class="hljs-literal">True</span>
        t.start()

<span class="hljs-comment"># Some remote functions</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">def</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">x, y</span>):
    <span class="hljs-keyword">return</span> x - y

<span class="hljs-comment"># Register with a handler</span>
handler = RPCHandler()
handler.register_function(add)
handler.register_function(sub)

<span class="hljs-comment"># Run the server</span>
rpc_server(handler, (<span class="hljs-string">'localhost'</span>, <span class="hljs-number">17000</span>), authkey=<span class="hljs-string">b'peekaboo'</span>)
</code></pre>
<p>为了从一个远程客户端访问服务器，你需要创建一个对应的用来传送请求的 RPC 代理类。例如</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> pickle

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCProxy</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, connection</span>):
        <span class="hljs-variable language_">self</span>._connection = connection
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_rpc</span>(<span class="hljs-params">*args, **kwargs</span>):
            <span class="hljs-variable language_">self</span>._connection.send(pickle.dumps((name, args, kwargs)))
            result = pickle.loads(<span class="hljs-variable language_">self</span>._connection.recv())
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(result, Exception):
                <span class="hljs-keyword">raise</span> result
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> do_rpc
</code></pre>
<p>要使用这个代理类，你需要将其包装到一个服务器的连接上面，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> multiprocessing.connection <span class="hljs-keyword">import</span> Client
<span class="hljs-meta">&gt;&gt;&gt; </span>c = Client((<span class="hljs-string">'localhost'</span>, <span class="hljs-number">17000</span>), authkey=<span class="hljs-string">b'peekaboo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>proxy = RPCProxy(c)
<span class="hljs-meta">&gt;&gt;&gt; </span>proxy.add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>proxy.sub(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
-<span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>proxy.sub([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">4</span>)
Traceback (most recent call last):
  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
  File <span class="hljs-string">"rpcserver.py"</span>, line <span class="hljs-number">37</span>, <span class="hljs-keyword">in</span> do_rpc
    <span class="hljs-keyword">raise</span> result
TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> -: <span class="hljs-string">'list'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'int'</span>
&gt;&gt;&gt;
</code></pre>
<p>要注意的是很多消息层（比如 <code>multiprocessing</code> ）已经使用 pickle 序列化了数据。 如果是这样的话，对 <code>pickle.dumps()</code> 和 <code>pickle.loads()</code> 的调用要去掉。</p>
<h2 id="讨论">讨论</h2>
<p><code>RPCHandler</code> 和 <code>RPCProxy</code> 的基本思路是很比较简单的。 如果一个客户端想要调用一个远程函数，比如 <code>foo(1, 2, z=3)</code> ,代理类创建一个包含了函数名和参数的元组 <code>('foo', (1, 2), {'z': 3})</code>。 这个元组被 pickle 序列化后通过网络连接发生出去。 这一步在 <code>RPCProxy</code>的<code>__getattr__()</code>方法返回的 <code>do_rpc()</code> 闭包中完成。 服务器接收后通过 pickle 反序列化消息，查找函数名看看是否已经注册过，然后执行相应的函数。 执行结果(或异常)被pickle序列化后返回发送给客户端。我们的实例需要依赖 <code>multiprocessing</code>进行通信。 不过，这种方式可以适用于其他任何消息系统。例如，如果你想在 ZeroMQ 之上实习 RPC， 仅仅只需要将连接对象换成合适的 ZeroMQ 的 socket 对象即可。</p>
<p>由于底层需要依赖 pickle，那么安全问题就需要考虑了 （因为一个聪明的黑客可以创建特定的消息，能够让任意函数通过 pickle 反序列化后被执行）。 因此你永远不要允许来自不信任或未认证的客户端的 RPC。特别是你绝对不要允许来自 Internet 的任意机器的访问， 这种只能在内部被使用，位于防火墙后面并且不要对外暴露。</p>
<p>作为 pickle 的替代，你也许可以考虑使用 JSON、XML 或一些其他的编码格式来序列化消息。 例如，本机实例可以很容易的改写成 JSON 编码方案。还需要将 <code>pickle.loads()</code> 和 <code>pickle.dumps()</code>替换成 <code>json.loads()</code> 和 <code>json.dumps()</code> 即可：</p>
<pre><code class="lang-python"><span class="hljs-comment"># jsonrpcserver.py</span>
<span class="hljs-keyword">import</span> json

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCHandler</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._functions = { }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">register_function</span>(<span class="hljs-params">self, func</span>):
        <span class="hljs-variable language_">self</span>._functions[func.__name__] = func

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-params">self, connection</span>):
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                <span class="hljs-comment"># Receive a message</span>
                func_name, args, kwargs = json.loads(connection.recv())
                <span class="hljs-comment"># Run the RPC and send a response</span>
                <span class="hljs-keyword">try</span>:
                    r = <span class="hljs-variable language_">self</span>._functions[func_name](*args,**kwargs)
                    connection.send(json.dumps(r))
                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
                    connection.send(json.dumps(<span class="hljs-built_in">str</span>(e)))
        <span class="hljs-keyword">except</span> EOFError:
             <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># jsonrpcclient.py</span>
<span class="hljs-keyword">import</span> json

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RPCProxy</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, connection</span>):
        <span class="hljs-variable language_">self</span>._connection = connection
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_rpc</span>(<span class="hljs-params">*args, **kwargs</span>):
            <span class="hljs-variable language_">self</span>._connection.send(json.dumps((name, args, kwargs)))
            result = json.loads(<span class="hljs-variable language_">self</span>._connection.recv())
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> do_rpc
</code></pre>
<p>实现 RPC 的一个比较复杂的问题是如何去处理异常。至少，当方法产生异常时服务器不应该奔溃。 因此，返回给客户端的异常所代表的含义就要好好设计了。 如果你使用 pickle，异常对象实例在客户端能被反序列化并抛出。如果你使用其他的协议，那得想想另外的方法了。 不过至少，你应该在响应中返回异常字符串。我们在 JSON 的例子中就是使用的这种方式。</p>
<p>对于其他的 RPC 实现例子，我推荐你看看在 XML-RPC 中使用的 <code>SimpleXMLRPCServer</code> 和 <code>ServerProxy</code> 的实现， 也就是11.6小节中的内容。</p>
<h1 id="119-简单的客户端认证">11.9 简单的客户端认证</h1>
<h2 id="问题">问题</h2>
<p>你想在分布式系统中实现一个简单的客户端连接认证功能，又不想像 SSL 那样的复杂。</p>
<h2 id="解决方案">解决方案</h2>
<p>可以利用 <code>hmac</code> 模块实现一个连接握手，从而实现一个简单而高效的认证过程。下面是代码示例：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> hmac
<span class="hljs-keyword">import</span> os

<span class="hljs-keyword">def</span> <span class="hljs-title function_">client_authenticate</span>(<span class="hljs-params">connection, secret_key</span>):
    <span class="hljs-string">'''
    Authenticate client to a remote service.
    connection represents a network connection.
    secret_key is a key known only to both client/server.
    '''</span>
    message = connection.recv(<span class="hljs-number">32</span>)
    <span class="hljs-built_in">hash</span> = hmac.new(secret_key, message)
    digest = <span class="hljs-built_in">hash</span>.digest()
    connection.send(digest)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">server_authenticate</span>(<span class="hljs-params">connection, secret_key</span>):
    <span class="hljs-string">'''
    Request client authentication.
    '''</span>
    message = os.urandom(<span class="hljs-number">32</span>)
    connection.send(message)
    <span class="hljs-built_in">hash</span> = hmac.new(secret_key, message)
    digest = <span class="hljs-built_in">hash</span>.digest()
    response = connection.recv(<span class="hljs-built_in">len</span>(digest))
    <span class="hljs-keyword">return</span> hmac.compare_digest(digest,response)
</code></pre>
<p>基本原理是当连接建立后，服务器给客户端发送一个随机的字节消息（这里例子中使用了 <code>os.urandom()</code> 返回值）。 客户端和服务器同时利用 hmac 和一个只有双方知道的密钥来计算出一个加密哈希值。然后客户端将它计算出的摘要发送给服务器， 服务器通过比较这个值和自己计算的是否一致来决定接受或拒绝连接。摘要的比较需要使用 <code>hmac.compare_digest()</code> 函数。 使用这个函数可以避免遭到时间分析攻击，不要用简单的比较操作符（==）。 为了使用这些函数，你需要将它集成到已有的网络或消息代码中。例如，对于 sockets，服务器代码应该类似下面：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM

secret_key = <span class="hljs-string">b'peekaboo'</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_handler</span>(<span class="hljs-params">client_sock</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> server_authenticate(client_sock, secret_key):
        client_sock.close()
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:

        msg = client_sock.recv(<span class="hljs-number">8192</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
            <span class="hljs-keyword">break</span>
        client_sock.sendall(msg)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_server</span>(<span class="hljs-params">address</span>):
    s = socket(AF_INET, SOCK_STREAM)
    s.bind(address)
    s.listen(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        c,a = s.accept()
        echo_handler(c)

echo_server((<span class="hljs-string">''</span>, <span class="hljs-number">18000</span>))

Within a client, you would do this:

<span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM

secret_key = <span class="hljs-string">b'peekaboo'</span>

s = socket(AF_INET, SOCK_STREAM)
s.connect((<span class="hljs-string">'localhost'</span>, <span class="hljs-number">18000</span>))
client_authenticate(s, secret_key)
s.send(<span class="hljs-string">b'Hello World'</span>)
resp = s.recv(<span class="hljs-number">1024</span>)
</code></pre>
<h2 id="讨论">讨论</h2>
<p><code>hmac</code> 认证的一个常见使用场景是内部消息通信系统和进程间通信。 例如，如果你编写的系统涉及到一个集群中多个处理器之间的通信， 你可以使用本节方案来确保只有被允许的进程之间才能彼此通信。 事实上，基于 <code>hmac</code> 的认证被 <code>multiprocessing</code> 模块使用来实现子进程直接的通信。</p>
<p>还有一点需要强调的是连接认证和加密是两码事。 认证成功之后的通信消息是以明文形式发送的，任何人只要想监听这个连接线路都能看到消息（尽管双方的密钥不会被传输）。</p>
<p>hmac 认证算法基于哈希函数如 MD5 和 SHA-1，关于这个在 IETF RFC 2104 中有详细介绍。</p>
<h1 id="1110-在网络服务中加入-ssl">11.10 在网络服务中加入 SSL</h1>
<h2 id="问题">问题</h2>
<p>你想实现一个基于 sockets 的网络服务，客户端和服务器通过 SSL 协议认证并加密传输的数据。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>ssl</code> 模块能为底层 socket 连接添加 SSL 的支持。 <code>ssl.wrap_socket()</code> 函数接受一个已存在的 socket 作为参数并使用 SSL 层来包装它。 例如，下面是一个简单的应答服务器，能在服务器端为所有客户端连接做认证。</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM
<span class="hljs-keyword">import</span> ssl

KEYFILE = <span class="hljs-string">'server_key.pem'</span>   <span class="hljs-comment"># Private key of the server</span>
CERTFILE = <span class="hljs-string">'server_cert.pem'</span> <span class="hljs-comment"># Server certificate (given to client)</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_client</span>(<span class="hljs-params">s</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        data = s.recv(<span class="hljs-number">8192</span>)
        <span class="hljs-keyword">if</span> data == <span class="hljs-string">b''</span>:
            <span class="hljs-keyword">break</span>
        s.send(data)
    s.close()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Connection closed'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_server</span>(<span class="hljs-params">address</span>):
    s = socket(AF_INET, SOCK_STREAM)
    s.bind(address)
    s.listen(<span class="hljs-number">1</span>)

    <span class="hljs-comment"># Wrap with an SSL layer requiring client certs</span>
    s_ssl = ssl.wrap_socket(s,
                            keyfile=KEYFILE,
                            certfile=CERTFILE,
                            server_side=<span class="hljs-literal">True</span>
                            )
    <span class="hljs-comment"># Wait for connections</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">try</span>:
            c,a = s_ssl.accept()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection'</span>, c, a)
            echo_client(c)
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'{}: {}'</span>.<span class="hljs-built_in">format</span>(e.__class__.__name__, e))

echo_server((<span class="hljs-string">''</span>, <span class="hljs-number">20000</span>))
</code></pre>
<p>下面我们演示一个客户端连接服务器的交互例子。客户端会请求服务器来认证并确认连接：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> ssl
<span class="hljs-meta">&gt;&gt;&gt; </span>s = socket(AF_INET, SOCK_STREAM)
<span class="hljs-meta">&gt;&gt;&gt; </span>s_ssl = ssl.wrap_socket(s,
                cert_reqs=ssl.CERT_REQUIRED,
                ca_certs = <span class="hljs-string">'server_cert.pem'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s_ssl.connect((<span class="hljs-string">'localhost'</span>, <span class="hljs-number">20000</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>s_ssl.send(<span class="hljs-string">b'Hello World?'</span>)
<span class="hljs-number">12</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s_ssl.recv(<span class="hljs-number">8192</span>)
<span class="hljs-string">b'Hello World?'</span>
&gt;&gt;&gt;
</code></pre>
<p>这种直接处理底层 socket 方式有个问题就是它不能很好的跟标准库中已存在的网络服务兼容。 例如，绝大部分服务器代码（HTTP、XML-RPC 等）实际上是基于 <code>socketserver</code> 库的。 客户端代码在一个较高层上实现。我们需要另外一种稍微不同的方式来将 SSL 添加到已存在的服务中：</p>
<p>首先，对于服务器而言，可以通过像下面这样使用一个 mixin 类来添加 SSL：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> ssl

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SSLMixin</span>:
<span class="hljs-string">'''
Mixin class that adds support for SSL to existing servers based
on the socketserver module.
'''</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args,
             keyfile=<span class="hljs-literal">None</span>, certfile=<span class="hljs-literal">None</span>, ca_certs=<span class="hljs-literal">None</span>,
             cert_reqs=ssl.NONE,
             **kwargs</span>):
    <span class="hljs-variable language_">self</span>._keyfile = keyfile
    <span class="hljs-variable language_">self</span>._certfile = certfile
    <span class="hljs-variable language_">self</span>._ca_certs = ca_certs
    <span class="hljs-variable language_">self</span>._cert_reqs = cert_reqs
    <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_request</span>(<span class="hljs-params">self</span>):
    client, addr = <span class="hljs-built_in">super</span>().get_request()
    client_ssl = ssl.wrap_socket(client,
                                 keyfile = <span class="hljs-variable language_">self</span>._keyfile,
                                 certfile = <span class="hljs-variable language_">self</span>._certfile,
                                 ca_certs = <span class="hljs-variable language_">self</span>._ca_certs,
                                 cert_reqs = <span class="hljs-variable language_">self</span>._cert_reqs,
                                 server_side = <span class="hljs-literal">True</span>)
    <span class="hljs-keyword">return</span> client_ssl, addr
</code></pre>
<p>为了使用这个 mixin 类，你可以将它跟其他服务器类混合。例如，下面是定义一个基于 SSL 的 XML-RPC 服务器例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># XML-RPC server with SSL</span>

<span class="hljs-keyword">from</span> xmlrpc.server <span class="hljs-keyword">import</span> SimpleXMLRPCServer

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SSLSimpleXMLRPCServer</span>(SSLMixin, SimpleXMLRPCServer):
    <span class="hljs-keyword">pass</span>

Here<span class="hljs-string">'s the XML-RPC server from Recipe 11.6 modified only slightly to use SSL:

import ssl
from xmlrpc.server import SimpleXMLRPCServer
from sslmixin import SSLMixin

class SSLSimpleXMLRPCServer(SSLMixin, SimpleXMLRPCServer):
    pass

class KeyValueServer:
    _rpc_methods_ = ['</span>get<span class="hljs-string">', '</span><span class="hljs-built_in">set</span><span class="hljs-string">', '</span>delete<span class="hljs-string">', '</span>exists<span class="hljs-string">', '</span>keys<span class="hljs-string">']
    def __init__(self, *args, **kwargs):
        self._data = {}
        self._serv = SSLSimpleXMLRPCServer(*args, allow_none=True, **kwargs)
        for name in self._rpc_methods_:
            self._serv.register_function(getattr(self, name))

    def get(self, name):
        return self._data[name]

    def set(self, name, value):
        self._data[name] = value

    def delete(self, name):
        del self._data[name]

    def exists(self, name):
        return name in self._data

    def keys(self):
        return list(self._data)

    def serve_forever(self):
        self._serv.serve_forever()

if __name__ == '</span>__main__<span class="hljs-string">':
    KEYFILE='</span>server_key.pem<span class="hljs-string">'    # Private key of the server
    CERTFILE='</span>server_cert.pem<span class="hljs-string">'  # Server certificate
    kvserv = KeyValueServer(('</span><span class="hljs-string">', 15000),
                            keyfile=KEYFILE,
                            certfile=CERTFILE),
    kvserv.serve_forever()
</span></code></pre>
<p>使用这个服务器时，你可以使用普通的 <code>xmlrpc.client</code>模块来连接它。 只需要在URL中指定 <code>https:</code>即可，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> xmlrpc.client <span class="hljs-keyword">import</span> ServerProxy
<span class="hljs-meta">&gt;&gt;&gt; </span>s = ServerProxy(<span class="hljs-string">'https://localhost:15000'</span>, allow_none=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.<span class="hljs-built_in">set</span>(<span class="hljs-string">'foo'</span>,<span class="hljs-string">'bar'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.<span class="hljs-built_in">set</span>(<span class="hljs-string">'spam'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>s.keys()
[<span class="hljs-string">'spam'</span>, <span class="hljs-string">'foo'</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>s.get(<span class="hljs-string">'foo'</span>)
<span class="hljs-string">'bar'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.get(<span class="hljs-string">'spam'</span>)
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>s.delete(<span class="hljs-string">'spam'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.exists(<span class="hljs-string">'spam'</span>)
<span class="hljs-literal">False</span>
&gt;&gt;&gt;
</code></pre>
<p>对于 SSL 客户端来讲一个比较复杂的问题是如何确认服务器证书或为服务器提供客户端认证（比如客户端证书）。 不幸的是，暂时还没有一个标准方法来解决这个问题，需要自己去研究。 不过，下面给出一个例子，用来建立一个安全的 XML-RPC 连接来确认服务器证书：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> xmlrpc.client <span class="hljs-keyword">import</span> SafeTransport, ServerProxy
<span class="hljs-keyword">import</span> ssl

<span class="hljs-keyword">class</span> <span class="hljs-title class_">VerifyCertSafeTransport</span>(<span class="hljs-title class_ inherited__">SafeTransport</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, cafile, certfile=<span class="hljs-literal">None</span>, keyfile=<span class="hljs-literal">None</span></span>):
        SafeTransport.__init__(<span class="hljs-variable language_">self</span>)
        <span class="hljs-variable language_">self</span>._ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
        <span class="hljs-variable language_">self</span>._ssl_context.load_verify_locations(cafile)
        <span class="hljs-keyword">if</span> cert:
            <span class="hljs-variable language_">self</span>._ssl_context.load_cert_chain(certfile, keyfile)
        <span class="hljs-variable language_">self</span>._ssl_context.verify_mode = ssl.CERT_REQUIRED

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_connection</span>(<span class="hljs-params">self, host</span>):
        <span class="hljs-comment"># Items in the passed dictionary are passed as keyword</span>
        <span class="hljs-comment"># arguments to the http.client.HTTPSConnection() constructor.</span>
        <span class="hljs-comment"># The context argument allows an ssl.SSLContext instance to</span>
        <span class="hljs-comment"># be passed with information about the SSL configuration</span>
        s = <span class="hljs-built_in">super</span>().make_connection((host, {<span class="hljs-string">'context'</span>: <span class="hljs-variable language_">self</span>._ssl_context}))

        <span class="hljs-keyword">return</span> s

<span class="hljs-comment"># Create the client proxy</span>
s = ServerProxy(<span class="hljs-string">'https://localhost:15000'</span>,
                transport=VerifyCertSafeTransport(<span class="hljs-string">'server_cert.pem'</span>),
                allow_none=<span class="hljs-literal">True</span>)
</code></pre>
<p>服务器将证书发送给客户端，客户端来确认它的合法性。这种确认可以是相互的。 如果服务器想要确认客户端，可以将服务器启动代码修改如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    KEYFILE=<span class="hljs-string">'server_key.pem'</span>   <span class="hljs-comment"># Private key of the server</span>
    CERTFILE=<span class="hljs-string">'server_cert.pem'</span> <span class="hljs-comment"># Server certificate</span>
    CA_CERTS=<span class="hljs-string">'client_cert.pem'</span> <span class="hljs-comment"># Certificates of accepted clients</span>

    kvserv = KeyValueServer((<span class="hljs-string">''</span>, <span class="hljs-number">15000</span>),
                            keyfile=KEYFILE,
                            certfile=CERTFILE,
                            ca_certs=CA_CERTS,
                            cert_reqs=ssl.CERT_REQUIRED,
                            )
    kvserv.serve_forever()
</code></pre>
<p>为了让 XML-RPC 客户端发送证书，修改 <code>ServerProxy</code> 的初始化代码如下：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Create the client proxy</span>
s = ServerProxy(<span class="hljs-string">'https://localhost:15000'</span>,
                transport=VerifyCertSafeTransport(<span class="hljs-string">'server_cert.pem'</span>,
                                                  <span class="hljs-string">'client_cert.pem'</span>,
                                                  <span class="hljs-string">'client_key.pem'</span>),
                allow_none=<span class="hljs-literal">True</span>)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>试着去运行本节的代码能测试你的系统配置能力和理解 SSL。 可能最大的挑战是如何一步步的获取初始配置 key、证书和其他所需依赖。</p>
<p>我解释下到底需要啥，每一个 SSL 连接终端一般都会有一个私钥和一个签名证书文件。 这个证书包含了公钥并在每一次连接的时候都会发送给对方。 对于公共服务器，它们的证书通常是被权威证书机构比如 Verisign、Equifax 或其他类似机构（需要付费的）签名过的。 为了确认服务器签名，客户端回保存一份包含了信任授权机构的证书列表文件。 例如，web 浏览器保存了主要的认证机构的证书，并使用它来为每一个 HTTPS 连接确认证书的合法性。 对本小节示例而言，只是为了测试，我们可以创建自签名的证书，下面是主要步骤：</p>
<pre><code class="lang-python">bash % openssl req -new -x509 -days <span class="hljs-number">365</span> -nodes -out server_cert.pem
-keyout server_key.pem
Generating a <span class="hljs-number">1024</span> bit RSA private key ..........................................++++++ ...++++++

writing new private key to ‘server_key.pem’

You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter <span class="hljs-keyword">is</span> what <span class="hljs-keyword">is</span> called a Distinguished Name <span class="hljs-keyword">or</span> a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter ‘.’, the field will be left blank.

Country Name (<span class="hljs-number">2</span> letter code) [AU]:US State <span class="hljs-keyword">or</span> Province Name (full name) [Some-State]:Illinois Locality Name (eg, city) []:Chicago Organization Name (eg, company) [Internet Widgits Pty Ltd]:Dabeaz, LLC Organizational Unit Name (eg, section) []: Common Name (eg, YOUR name) []:localhost Email Address []: bash %
</code></pre>
<p>在创建证书的时候，各个值的设定可以是任意的，但是”Common Name“的值通常要包含服务器的 DNS 主机名。 如果你只是在本机测试，那么就使用”localhost“，否则使用服务器的域名。</p>
<pre><code class="lang-python">—–BEGIN RSA PRIVATE KEY—– MIICXQIBAAKBgQCZrCNLoEyAKF+f9UNcFaz5Osa6jf7qkbUl8si5xQrY3ZYC7juu nL1dZLn/VbEFIITaUOgvBtPv1qUWTJGwga62VSG1oFE0ODIx3g2Nh4sRf+rySsx2 L4442nx0z4O5vJQ7k6eRNHAZUUnCL50+YvjyLyt7ryLSjSuKhCcJsbZgPwIDAQAB AoGAB5evrr7eyL4160tM5rHTeATlaLY3UBOe5Z8XN8Z6gLiB/ucSX9AysviVD/6F 3oD6z2aL8jbeJc1vHqjt0dC2dwwm32vVl8mRdyoAsQpWmiqXrkvP4Bsl04VpBeHw Qt8xNSW9SFhceL3LEvw9M8i9MV39viih1ILyH8OuHdvJyFECQQDLEjl2d2ppxND9 PoLqVFAirDfX2JnLTdWbc+M11a9Jdn3hKF8TcxfEnFVs5Gav1MusicY5KB0ylYPb YbTvqKc7AkEAwbnRBO2VYEZsJZp2X0IZqP9ovWokkpYx+PE4+c6MySDgaMcigL7v WDIHJG1CHudD09GbqENasDzyb2HAIW4CzQJBAKDdkv+xoW6gJx42Auc2WzTcUHCA eXR/+BLpPrhKykzbvOQ8YvS5W764SUO1u1LWs3G+wnRMvrRvlMCZKgggBjkCQQCG Jewto2+a+WkOKQXrNNScCDE5aPTmZQc5waCYq4UmCZQcOjkUOiN3ST1U5iuxRqfb V/yX6fw0qh+fLWtkOs/JAkA+okMSxZwqRtfgOFGBfwQ8/iKrnizeanTQ3L6scFXI CHZXdJ3XQ6qUmNxNn7iJ7S/LDawo1QfWkCfD9FYoxBlg —–END RSA PRIVATE KEY—–
</code></pre>
<p>服务器证书文件 server_cert.pem 内容类似下面这样：</p>
<pre><code class="lang-python">—–BEGIN CERTIFICATE—– MIIC+DCCAmGgAwIBAgIJAPMd+vi45js3MA0GCSqGSIb3DQEBBQUAMFwxCzAJBgNV BAYTAlVTMREwDwYDVQQIEwhJbGxpbm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIG A1UEChMLRGFiZWF6LCBMTEMxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0xMzAxMTEx ODQyMjdaFw0xNDAxMTExODQyMjdaMFwxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhJ bGxpbm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIGA1UEChMLRGFiZWF6LCBMTEMx EjAQBgNVBAMTCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA mawjS6BMgChfn/VDXBWs+TrGuo3+6pG1JfLIucUK2N2WAu47rpy9XWS5/1WxBSCE 2lDoLwbT79alFkyRsIGutlUhtaBRNDgyMd4NjYeLEX/q8krMdi+OONp8dM+DubyU

O5OnkTRwGVFJwi+dPmL48i8re68i0o0rioQnCbG2YD8CAwEAAaOBwTCBvjAdBgNV HQ4EFgQUrtoLHHgXiDZTr26NMmgKJLJLFtIwgY4GA1UdIwSBhjCBg4AUrtoLHHgX iDZTr26NMmgKJLJLFtKhYKReMFwxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhJbGxp bm9pczEQMA4GA1UEBxMHQ2hpY2FnbzEUMBIGA1UEChMLRGFiZWF6LCBMTEMxEjAQ BgNVBAMTCWxvY2FsaG9zdIIJAPMd+vi45js3MAwGA1UdEwQFMAMBAf8wDQYJKoZI hvcNAQEFBQADgYEAFci+dqvMG4xF8UTnbGVvZJPIzJDRee6Nbt6AHQo9pOdAIMAu WsGCplSOaDNdKKzl+b2UT2Zp3AIW4Qd51bouSNnR4M/gnr9ZD1ZctFd3jS+C5XRp D3vvcW5lAnCCC80P6rXy7d7hTeFu5EYKtRGXNvVNd/06NALGDflrrOwxF3Y= —–END CERTIFICATE—–
</code></pre>
<p>在服务器端代码中，私钥和证书文件会被传给 SSL 相关的包装函数。证书来自于客户端， 私钥应该在保存在服务器中，并加以安全保护。</p>
<p>在客户端代码中，需要保存一个合法证书授权文件来确认服务器证书。 如果你没有这个文件，你可以在客户端复制一份服务器的证书并使用它来确认。 连接建立后，服务器会提供它的证书，然后你就能使用已经保存的证书来确认它是否正确。</p>
<p>服务器也能选择是否要确认客户端的身份。如果要这样做的话，客户端需要有自己的私钥和认证文件。 服务器也需要保存一个被信任证书授权文件来确认客户端证书。</p>
<p>如果你要在真实环境中为你的网络服务加上 SSL 的支持，这小节只是一个入门介绍而已。 你还应该参考其他的文档，做好花费不少时间来测试它正常工作的准备。反正，就是得慢慢折腾吧~ ^_^</p>
<h1 id="1111-进程间传递-socket-文件描述符">11.11 进程间传递 Socket 文件描述符</h1>
<h2 id="问题">问题</h2>
<p>你有多个 Python 解释器进程在同时运行，你想将某个打开的文件描述符从一个解释器传递给另外一个。 比如，假设有个服务器进程相应连接请求，但是实际的相应逻辑是在另一个解释器中执行的。</p>
<h2 id="解决方案">解决方案</h2>
<p>为了在多个进程中传递文件描述符，你首先需要将它们连接到一起。在 Unix 机器上，你可能需要使用 Unix 域套接字， 而在 windows 上面你需要使用命名管道。不过你无需真的需要去操作这些底层， 通常使用 <code>multiprocessing</code> 模块来创建这样的连接会更容易一些。</p>
<p>一旦一个连接被创建，你可以使用 <code>multiprocessing.reduction</code> 中的 <code>send_handle()</code> 和<code>recv_handle()</code> 函数在不同的处理器直接传递文件描述符。 下面的例子演示了最基本的用法：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> multiprocessing
<span class="hljs-keyword">from</span> multiprocessing.reduction <span class="hljs-keyword">import</span> recv_handle, send_handle
<span class="hljs-keyword">import</span> socket

<span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">in_p, out_p</span>):
    out_p.close()
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        fd = recv_handle(in_p)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'CHILD: GOT FD'</span>, fd)
        <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM, fileno=fd) <span class="hljs-keyword">as</span> s:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                msg = s.recv(<span class="hljs-number">1024</span>)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
                    <span class="hljs-keyword">break</span>
                <span class="hljs-built_in">print</span>(<span class="hljs-string">'CHILD: RECV {!r}'</span>.<span class="hljs-built_in">format</span>(msg))
                s.send(msg)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">server</span>(<span class="hljs-params">address, in_p, out_p, worker_pid</span>):
    in_p.close()
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-literal">True</span>)
    s.bind(address)
    s.listen(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client, addr = s.accept()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'SERVER: Got connection from'</span>, addr)
        send_handle(out_p, client.fileno(), worker_pid)
        client.close()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    c1, c2 = multiprocessing.Pipe()
    worker_p = multiprocessing.Process(target=worker, args=(c1,c2))
    worker_p.start()

    server_p = multiprocessing.Process(target=server,
                  args=((<span class="hljs-string">''</span>, <span class="hljs-number">15000</span>), c1, c2, worker_p.pid))
    server_p.start()

    c1.close()
    c2.close()
</code></pre>
<p>在这个例子中，两个进程被创建并通过一个<code>multiprocessing</code>管道连接起来。 服务器进程打开一个 socket 并等待客户端连接请求。 工作进程仅仅使用 <code>recv_handle()</code>在管道上面等待接收一个文件描述符。 当服务器接收到一个连接，它将产生的 socket 文件描述符通过<code>send_handle()</code> 传递给工作进程。 工作进程接收到 socket 后向客户端回应数据，然后此次连接关闭。</p>
<p>如果你使用 Telnet 或类似工具连接到服务器，下面是一个演示例子：</p>
<pre><code class="lang-python">bash % python3 passfd.py SERVER: Got connection <span class="hljs-keyword">from</span> (‘<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>’, <span class="hljs-number">55543</span>) CHILD: GOT FD <span class="hljs-number">7</span> CHILD: RECV b’Hellorn’ CHILD: RECV b’Worldrn’
</code></pre>
<p>此例最重要的部分是服务器接收到的客户端 socket 实际上被另外一个不同的进程处理。 服务器仅仅只是将其转手并关闭此连接，然后等待下一个连接。</p>
<h2 id="讨论">讨论</h2>
<p>对于大部分程序员来讲在不同进程之间传递文件描述符好像没什么必要。 但是，有时候它是构建一个可扩展系统的很有用的工具。例如，在一个多核机器上面， 你可以有多个 Python 解释器实例，将文件描述符传递给其它解释器来实现负载均衡。</p>
<p><code>send_handle()</code>和 <code>recv_handle()</code>函数只能够用于 <code>multiprocessing</code> 连接。 使用它们来代替管道的使用（参考11.7节），只要你使用的是 Unix 域套接字或 Windows 管道。 例如，你可以让服务器和工作者各自以单独的程序来启动。下面是服务器的实现例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># servermp.py</span>
<span class="hljs-keyword">from</span> multiprocessing.connection <span class="hljs-keyword">import</span> Listener
<span class="hljs-keyword">from</span> multiprocessing.reduction <span class="hljs-keyword">import</span> send_handle
<span class="hljs-keyword">import</span> socket

<span class="hljs-keyword">def</span> <span class="hljs-title function_">server</span>(<span class="hljs-params">work_address, port</span>):
    <span class="hljs-comment"># Wait for the worker to connect</span>
    work_serv = Listener(work_address, authkey=<span class="hljs-string">b'peekaboo'</span>)
    worker = work_serv.accept()
    worker_pid = worker.recv()

    <span class="hljs-comment"># Now run a TCP/IP server and send clients to worker</span>
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-literal">True</span>)
    s.bind((<span class="hljs-string">''</span>, port))
    s.listen(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client, addr = s.accept()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'SERVER: Got connection from'</span>, addr)

        send_handle(worker, client.fileno(), worker_pid)
        client.close()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">import</span> sys
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">3</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Usage: server.py server_address port'</span>, file=sys.stderr)
        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

    server(sys.argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>]))
</code></pre>
<p>运行这个服务器，只需要执行 python3 servermp.py /tmp/servconn 15000 ，下面是相应的工作者代码：</p>
<pre><code class="lang-python"><span class="hljs-comment"># workermp.py</span>

<span class="hljs-keyword">from</span> multiprocessing.connection <span class="hljs-keyword">import</span> Client
<span class="hljs-keyword">from</span> multiprocessing.reduction <span class="hljs-keyword">import</span> recv_handle
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM

<span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">server_address</span>):
    serv = Client(server_address, authkey=<span class="hljs-string">b'peekaboo'</span>)
    serv.send(os.getpid())
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        fd = recv_handle(serv)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'WORKER: GOT FD'</span>, fd)
        <span class="hljs-keyword">with</span> socket(AF_INET, SOCK_STREAM, fileno=fd) <span class="hljs-keyword">as</span> client:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                msg = client.recv(<span class="hljs-number">1024</span>)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
                    <span class="hljs-keyword">break</span>
                <span class="hljs-built_in">print</span>(<span class="hljs-string">'WORKER: RECV {!r}'</span>.<span class="hljs-built_in">format</span>(msg))
                client.send(msg)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">import</span> sys
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">2</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Usage: worker.py server_address'</span>, file=sys.stderr)
        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

    worker(sys.argv[<span class="hljs-number">1</span>])
</code></pre>
<p>要运行工作者，执行执行命令 python3 workermp.py /tmp/servconn . 效果跟使用 Pipe()例子是完全一样的。 文件描述符的传递会涉及到UNIX域套接字的创建和套接字的 <code>sendmsg()</code>方法。 不过这种技术并不常见，下面是使用套接字来传递描述符的另外一种实现：</p>
<pre><code class="lang-python"><span class="hljs-comment"># server.py</span>
<span class="hljs-keyword">import</span> socket

<span class="hljs-keyword">import</span> struct

<span class="hljs-keyword">def</span> <span class="hljs-title function_">send_fd</span>(<span class="hljs-params">sock, fd</span>):
    <span class="hljs-string">'''
    Send a single file descriptor.
    '''</span>
    sock.sendmsg([<span class="hljs-string">b'x'</span>],
                 [(socket.SOL_SOCKET, socket.SCM_RIGHTS, struct.pack(<span class="hljs-string">'i'</span>, fd))])
    ack = sock.recv(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">assert</span> ack == <span class="hljs-string">b'OK'</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">server</span>(<span class="hljs-params">work_address, port</span>):
    <span class="hljs-comment"># Wait for the worker to connect</span>
    work_serv = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    work_serv.bind(work_address)
    work_serv.listen(<span class="hljs-number">1</span>)
    worker, addr = work_serv.accept()

    <span class="hljs-comment"># Now run a TCP/IP server and send clients to worker</span>
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-literal">True</span>)
    s.bind((<span class="hljs-string">''</span>,port))
    s.listen(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client, addr = s.accept()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'SERVER: Got connection from'</span>, addr)
        send_fd(worker, client.fileno())
        client.close()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">import</span> sys
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">3</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Usage: server.py server_address port'</span>, file=sys.stderr)
        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

    server(sys.argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>]))
</code></pre>
<p>下面是使用套接字的工作者实现：</p>
<pre><code class="lang-python"><span class="hljs-comment"># worker.py</span>
<span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> struct

<span class="hljs-keyword">def</span> <span class="hljs-title function_">recv_fd</span>(<span class="hljs-params">sock</span>):
    <span class="hljs-string">'''
    Receive a single file descriptor
    '''</span>
    msg, ancdata, flags, addr = sock.recvmsg(<span class="hljs-number">1</span>,
                                     socket.CMSG_LEN(struct.calcsize(<span class="hljs-string">'i'</span>)))

    cmsg_level, cmsg_type, cmsg_data = ancdata[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">assert</span> cmsg_level == socket.SOL_SOCKET <span class="hljs-keyword">and</span> cmsg_type == socket.SCM_RIGHTS
    sock.sendall(<span class="hljs-string">b'OK'</span>)

    <span class="hljs-keyword">return</span> struct.unpack(<span class="hljs-string">'i'</span>, cmsg_data)[<span class="hljs-number">0</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">server_address</span>):
    serv = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    serv.connect(server_address)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        fd = recv_fd(serv)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'WORKER: GOT FD'</span>, fd)
        <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM, fileno=fd) <span class="hljs-keyword">as</span> client:
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                msg = client.recv(<span class="hljs-number">1024</span>)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
                    <span class="hljs-keyword">break</span>
                <span class="hljs-built_in">print</span>(<span class="hljs-string">'WORKER: RECV {!r}'</span>.<span class="hljs-built_in">format</span>(msg))
                client.send(msg)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">import</span> sys
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">2</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Usage: worker.py server_address'</span>, file=sys.stderr)
        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

    worker(sys.argv[<span class="hljs-number">1</span>])
</code></pre>
<p>如果你想在你的程序中传递文件描述符，建议你参阅其他一些更加高级的文档， 比如 <code>Unix Network Programming by W. Richard Stevens  (Prentice  Hall,  1990)</code> . 在 Windows 上传递文件描述符跟 Unix 是不一样的，建议你研究下 <code>multiprocessing.reduction</code> 中的源代码看看其工作原理。</p>
<h1 id="1112-理解事件驱动的-io">11.12 理解事件驱动的 IO</h1>
<h2 id="问题">问题</h2>
<p>你应该已经听过基于事件驱动或异步 I/O 的包，但是你还不能完全理解它的底层到底是怎样工作的， 或者是如果使用它的话会对你的程序产生什么影响。</p>
<h2 id="解决方案">解决方案</h2>
<p>事件驱动 I/O 本质上来讲就是将基本 I/O 操作（比如读和写）转化为你程序需要处理的事件。 例如，当数据在某个 socket 上被接受后，它会转换成一个 <code>receive</code> 事件，然后被你定义的回调方法或函数来处理。 作为一个可能的起始点，一个事件驱动的框架可能会以一个实现了一系列基本事件处理器方法的基类开始：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventHandler</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fileno</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'Return the associated file descriptor'</span>
        <span class="hljs-keyword">raise</span> <span class="hljs-literal">NotImplemented</span>(<span class="hljs-string">'must implement'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wants_to_receive</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'Return True if receiving is allowed'</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_receive</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'Perform the receive operation'</span>
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wants_to_send</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'Return True if sending is requested'</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_send</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'Send outgoing data'</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>这个类的实例作为插件被放入类似下面这样的事件循环中：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> select

<span class="hljs-keyword">def</span> <span class="hljs-title function_">event_loop</span>(<span class="hljs-params">handlers</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        wants_recv = [h <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> handlers <span class="hljs-keyword">if</span> h.wants_to_receive()]
        wants_send = [h <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> handlers <span class="hljs-keyword">if</span> h.wants_to_send()]
        can_recv, can_send, _ = select.select(wants_recv, wants_send, [])
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> can_recv:
            h.handle_receive()
        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> can_send:
            h.handle_send()
</code></pre>
<p>事件循环的关键部分是 <code>select()</code> 调用，它会不断轮询文件描述符从而激活它。 在调用 <code>select()</code>之前，时间循环会询问所有的处理器来决定哪一个想接受或发生。 然后它将结果列表提供给 <code>select()</code>。然后 <code>select()</code> 返回准备接受或发送的对象组成的列表。 然后相应的 <code>handle_receive()</code> 或 <code>handle_send()</code>方法被触发。</p>
<p>编写应用程序的时候，<code>EventHandler</code> 的实例会被创建。例如，下面是两个简单的基于 UDP 网络服务的处理器例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPServer</span>(<span class="hljs-title class_ inherited__">EventHandler</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, address</span>):
        <span class="hljs-variable language_">self</span>.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        <span class="hljs-variable language_">self</span>.sock.bind(address)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fileno</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.sock.fileno()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wants_to_receive</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPTimeServer</span>(<span class="hljs-title class_ inherited__">UDPServer</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_receive</span>(<span class="hljs-params">self</span>):
        msg, addr = <span class="hljs-variable language_">self</span>.sock.recvfrom(<span class="hljs-number">1</span>)
        <span class="hljs-variable language_">self</span>.sock.sendto(time.ctime().encode(<span class="hljs-string">'ascii'</span>), addr)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPEchoServer</span>(<span class="hljs-title class_ inherited__">UDPServer</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_receive</span>(<span class="hljs-params">self</span>):
        msg, addr = <span class="hljs-variable language_">self</span>.sock.recvfrom(<span class="hljs-number">8192</span>)
        <span class="hljs-variable language_">self</span>.sock.sendto(msg, addr)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    handlers = [ UDPTimeServer((<span class="hljs-string">''</span>,<span class="hljs-number">14000</span>)), UDPEchoServer((<span class="hljs-string">''</span>,<span class="hljs-number">15000</span>))  ]
    event_loop(handlers)
</code></pre>
<p>测试这段代码，试着从另外一个 Python 解释器连接它：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *
<span class="hljs-meta">&gt;&gt;&gt; </span>s = socket(AF_INET, SOCK_DGRAM)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.sendto(<span class="hljs-string">b''</span>,(<span class="hljs-string">'localhost'</span>,<span class="hljs-number">14000</span>))
<span class="hljs-number">0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.recvfrom(<span class="hljs-number">128</span>)
(<span class="hljs-string">b'Tue Sep 18 14:29:23 2012'</span>, (<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">14000</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>s.sendto(<span class="hljs-string">b'Hello'</span>,(<span class="hljs-string">'localhost'</span>,<span class="hljs-number">15000</span>))
<span class="hljs-number">5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.recvfrom(<span class="hljs-number">128</span>)
(<span class="hljs-string">b'Hello'</span>, (<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">15000</span>))
&gt;&gt;&gt;
</code></pre>
<p>实现一个 TCP 服务器会更加复杂一点，因为每一个客户端都要初始化一个新的处理器对象。 下面是一个 TCP 应答客户端例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPServer</span>(<span class="hljs-title class_ inherited__">EventHandler</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, address, client_handler, handler_list</span>):
        <span class="hljs-variable language_">self</span>.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        <span class="hljs-variable language_">self</span>.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-literal">True</span>)
        <span class="hljs-variable language_">self</span>.sock.bind(address)
        <span class="hljs-variable language_">self</span>.sock.listen(<span class="hljs-number">1</span>)
        <span class="hljs-variable language_">self</span>.client_handler = client_handler
        <span class="hljs-variable language_">self</span>.handler_list = handler_list

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fileno</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.sock.fileno()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wants_to_receive</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_receive</span>(<span class="hljs-params">self</span>):
        client, addr = <span class="hljs-variable language_">self</span>.sock.accept()
        <span class="hljs-comment"># Add the client to the event loop's handler list</span>
        <span class="hljs-variable language_">self</span>.handler_list.append(<span class="hljs-variable language_">self</span>.client_handler(client, <span class="hljs-variable language_">self</span>.handler_list))

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPClient</span>(<span class="hljs-title class_ inherited__">EventHandler</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sock, handler_list</span>):
        <span class="hljs-variable language_">self</span>.sock = sock
        <span class="hljs-variable language_">self</span>.handler_list = handler_list
        <span class="hljs-variable language_">self</span>.outgoing = <span class="hljs-built_in">bytearray</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fileno</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.sock.fileno()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.sock.close()
        <span class="hljs-comment"># Remove myself from the event loop's handler list</span>
        <span class="hljs-variable language_">self</span>.handler_list.remove(<span class="hljs-variable language_">self</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wants_to_send</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.outgoing <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_send</span>(<span class="hljs-params">self</span>):
        nsent = <span class="hljs-variable language_">self</span>.sock.send(<span class="hljs-variable language_">self</span>.outgoing)
        <span class="hljs-variable language_">self</span>.outgoing = <span class="hljs-variable language_">self</span>.outgoing[nsent:]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPEchoClient</span>(<span class="hljs-title class_ inherited__">TCPClient</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wants_to_receive</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_receive</span>(<span class="hljs-params">self</span>):
        data = <span class="hljs-variable language_">self</span>.sock.recv(<span class="hljs-number">8192</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:
            <span class="hljs-variable language_">self</span>.close()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-variable language_">self</span>.outgoing.extend(data)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
   handlers = []
   handlers.append(TCPServer((<span class="hljs-string">''</span>,<span class="hljs-number">16000</span>), TCPEchoClient, handlers))
   event_loop(handlers)
</code></pre>
<p>TCP 例子的关键点是从处理器中列表增加和删除客户端的操作。 对每一个连接，一个新的处理器被创建并加到列表中。当连接被关闭后，每个客户端负责将其从列表中删除。 如果你运行程序并试着用 Telnet 或类似工具连接，它会将你发送的消息回显给你。并且它能很轻松的处理多客户端连接。</p>
<h2 id="讨论">讨论</h2>
<p>实际上所有的事件驱动框架原理跟上面的例子相差无几。实际的实现细节和软件架构可能不一样， 但是在最核心的部分，都会有一个轮询的循环来检查活动 socket，并执行响应操作。</p>
<p>事件驱动 I/O 的一个可能好处是它能处理非常大的并发连接，而不需要使用多线程或多进程。 也就是说，<code>select()</code>调用（或其他等效的）能监听大量的 socket 并响应它们中任何一个产生事件的。 在循环中一次处理一个事件，并不需要其他的并发机制。</p>
<p>事件驱动 I/O 的缺点是没有真正的同步机制。 如果任何事件处理器方法阻塞或执行一个耗时计算，它会阻塞所有的处理进程。 调用那些并不是事件驱动风格的库函数也会有问题，同样要是某些库函数调用会阻塞，那么也会导致整个事件循环停止。</p>
<p>对于阻塞或耗时计算的问题可以通过将事件发送个其他单独的现场或进程来处理。 不过，在事件循环中引入多线程和多进程是比较棘手的， 下面的例子演示了如何使用 <code>concurrent.futures</code>模块来实现：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor
<span class="hljs-keyword">import</span> os

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolHandler</span>(<span class="hljs-title class_ inherited__">EventHandler</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, nworkers</span>):
        <span class="hljs-keyword">if</span> os.name == <span class="hljs-string">'posix'</span>:
            <span class="hljs-variable language_">self</span>.signal_done_sock, <span class="hljs-variable language_">self</span>.done_sock = socket.socketpair()
        <span class="hljs-keyword">else</span>:
            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server.bind((<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">0</span>))
            server.listen(<span class="hljs-number">1</span>)
            <span class="hljs-variable language_">self</span>.signal_done_sock = socket.socket(socket.AF_INET,
                                                  socket.SOCK_STREAM)
            <span class="hljs-variable language_">self</span>.signal_done_sock.connect(server.getsockname())
            <span class="hljs-variable language_">self</span>.done_sock, _ = server.accept()
            server.close()

        <span class="hljs-variable language_">self</span>.pending = []
        <span class="hljs-variable language_">self</span>.pool = ThreadPoolExecutor(nworkers)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fileno</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.done_sock.fileno()

    <span class="hljs-comment"># Callback that executes when the thread is done</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_complete</span>(<span class="hljs-params">self, callback, r</span>):

        <span class="hljs-variable language_">self</span>.pending.append((callback, r.result()))
        <span class="hljs-variable language_">self</span>.signal_done_sock.send(<span class="hljs-string">b'x'</span>)

    <span class="hljs-comment"># Run a function in a thread pool</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, func, args=(<span class="hljs-params"></span>), kwargs={},*,callback</span>):
        r = <span class="hljs-variable language_">self</span>.pool.submit(func, *args, **kwargs)
        r.add_done_callback(<span class="hljs-keyword">lambda</span> r: <span class="hljs-variable language_">self</span>._complete(callback, r))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wants_to_receive</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

    <span class="hljs-comment"># Run callback functions of completed work</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_receive</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># Invoke all pending callback functions</span>
        <span class="hljs-keyword">for</span> callback, result <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.pending:
            callback(result)
            <span class="hljs-variable language_">self</span>.done_sock.recv(<span class="hljs-number">1</span>)
        <span class="hljs-variable language_">self</span>.pending = []
</code></pre>
<p>在代码中，<code>run()</code>方法被用来将工作提交给回调函数池，处理完成后被激发。 实际工作被提交给 <code>ThreadPoolExecutor</code>实例。 不过一个难点是协调计算结果和事件循环，为了解决它，我们创建了一对 socket 并将其作为某种信号量机制来使用。 当线程池完成工作后，它会执行类中的 <code>_complete()</code> 方法。 这个方法再某个 socket 上写入字节之前会讲挂起的回调函数和结果放入队列中。<code>fileno()</code> 方法返回另外的那个 socket。 因此，这个字节被写入时，它会通知事件循环， 然后 <code>handle_receive()</code>方法被激活并为所有之前提交的工作执行回调函数。 坦白讲，说了这么多连我自己都晕了。 下面是一个简单的服务器，演示了如何使用线程池来实现耗时的计算：</p>
<pre><code class="lang-python"><span class="hljs-comment"># A really bad Fibonacci implementation</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UDPFibServer</span>(<span class="hljs-title class_ inherited__">UDPServer</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_receive</span>(<span class="hljs-params">self</span>):
        msg, addr = <span class="hljs-variable language_">self</span>.sock.recvfrom(<span class="hljs-number">128</span>)
        n = <span class="hljs-built_in">int</span>(msg)
        pool.run(fib, (n,), callback=<span class="hljs-keyword">lambda</span> r: <span class="hljs-variable language_">self</span>.respond(r, addr))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">respond</span>(<span class="hljs-params">self, result, addr</span>):
        <span class="hljs-variable language_">self</span>.sock.sendto(<span class="hljs-built_in">str</span>(result).encode(<span class="hljs-string">'ascii'</span>), addr)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    pool = ThreadPoolHandler(<span class="hljs-number">16</span>)
    handlers = [ pool, UDPFibServer((<span class="hljs-string">''</span>,<span class="hljs-number">16000</span>))]
    event_loop(handlers)
</code></pre>
<p>运行这个服务器，然后试着用其它 Python 程序来测试它：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *
sock = socket(AF_INET, SOCK_DGRAM)
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>):
    sock.sendto(<span class="hljs-built_in">str</span>(x).encode(<span class="hljs-string">'ascii'</span>), (<span class="hljs-string">'localhost'</span>, <span class="hljs-number">16000</span>))
    resp = sock.recvfrom(<span class="hljs-number">8192</span>)
    <span class="hljs-built_in">print</span>(resp[<span class="hljs-number">0</span>])
</code></pre>
<p>你应该能在不同窗口中重复的执行这个程序，并且不会影响到其他程序，尽管当数字便越来越大时候它会变得越来越慢。</p>
<p>已经阅读完了这一小节，那么你应该使用这里的代码吗？也许不会。你应该选择一个可以完成同样任务的高级框架。 不过，如果你理解了基本原理，你就能理解这些框架所使用的核心技术。 作为对回调函数编程的替代，事件驱动编码有时候会使用到协程，参考12.12小节的一个例子。</p>
<h1 id="1113-发送与接收大型数组">11.13 发送与接收大型数组</h1>
<h2 id="问题">问题</h2>
<p>你要通过网络连接发送和接受连续数据的大型数组，并尽量减少数据的复制操作。</p>
<h2 id="解决方案">解决方案</h2>
<p>下面的函数利用<code>memoryviews</code> 来发送和接受大数组：</p>
<pre><code class="lang-python"><span class="hljs-comment"># zerocopy.py</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">send_from</span>(<span class="hljs-params">arr, dest</span>):
    view = <span class="hljs-built_in">memoryview</span>(arr).cast(<span class="hljs-string">'B'</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(view):
        nsent = dest.send(view)
        view = view[nsent:]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">recv_into</span>(<span class="hljs-params">arr, source</span>):
    view = <span class="hljs-built_in">memoryview</span>(arr).cast(<span class="hljs-string">'B'</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(view):
        nrecv = source.recv_into(view)
        view = view[nrecv:]
</code></pre>
<p>为了测试程序，首先创建一个通过 socket 连接的服务器和客户端程序：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *
<span class="hljs-meta">&gt;&gt;&gt; </span>s = socket(AF_INET, SOCK_STREAM)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.bind((<span class="hljs-string">''</span>, <span class="hljs-number">25000</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>s.listen(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c,a = s.accept()
&gt;&gt;&gt;
</code></pre>
<p>在客户端（另外一个解释器中）：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *
<span class="hljs-meta">&gt;&gt;&gt; </span>c = socket(AF_INET, SOCK_STREAM)
<span class="hljs-meta">&gt;&gt;&gt; </span>c.connect((<span class="hljs-string">'localhost'</span>, <span class="hljs-number">25000</span>))
&gt;&gt;&gt;
</code></pre>
<p>本节的目标是你能通过连接传输一个超大数组。这种情况的话，可以通过<code>array</code>模块或<code>numpy</code> 模块来创建数组：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Server</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy
<span class="hljs-meta">&gt;&gt;&gt; </span>a = numpy.arange(<span class="hljs-number">0.0</span>, <span class="hljs-number">50000000.0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>send_from(a, c)
&gt;&gt;&gt;

<span class="hljs-comment"># Client</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy
<span class="hljs-meta">&gt;&gt;&gt; </span>a = numpy.zeros(shape=<span class="hljs-number">50000000</span>, dtype=<span class="hljs-built_in">float</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]
array([ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>recv_into(a, c)
<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]
array([ <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>,  <span class="hljs-number">3.</span>,  <span class="hljs-number">4.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">6.</span>,  <span class="hljs-number">7.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">9.</span>])
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>在数据密集型分布式计算和平行计算程序中，自己写程序来实现发送/接受大量数据并不常见。 不过，要是你确实想这样做，你可能需要将你的数据转换成原始字节，以便给低层的网络函数使用。 你可能还需要将数据切割成多个块，因为大部分和网络相关的函数并不能一次性发送或接受超大数据块。</p>
<p>一种方法是使用某种机制序列化数据——可能将其转换成一个字节字符串。 不过，这样最终会创建数据的一个复制。 就算你只是零碎的做这些，你的代码最终还是会有大量的小型复制操作。</p>
<p>本节通过使用内存视图展示了一些魔法操作。 本质上，一个内存视图就是一个已存在数组的覆盖层。不仅仅是那样， 内存视图还能以不同的方式转换成不同类型来表现数据。 这个就是下面这个语句的目的：</p>
<pre><code class="lang-python">view = <span class="hljs-built_in">memoryview</span>(arr).cast(<span class="hljs-string">'B'</span>)
</code></pre>
<p>它接受一个数组 arr 并将其转换为一个无符号字节的内存视图。这个视图能被传递给 socket 相关函数， 比如 <code>socket.send()</code> 或<code>send.recv_into()</code> 。 在内部，这些方法能够直接操作这个内存区域。例如，<code>sock.send()</code> 直接从内存中发生数据而不需要复制。<code>send.recv_into()</code> 使用这个内存区域作为接受操作的输入缓冲区。</p>
<p>剩下的一个难点就是 socket 函数可能只操作部分数据。 通常来讲，我们得使用很多不同的 <code>send()</code>和 <code>recv_into()</code>来传输整个数组。 不用担心，每次操作后，视图会通过发送或接受字节数量被切割成新的视图。 新的视图同样也是内存覆盖层。因此，还是没有任何的复制操作。</p>
<p>这里有个问题就是接受者必须事先知道有多少数据要被发送， 以便它能预分配一个数组或者确保它能将接受的数据放入一个已经存在的数组中。 如果没办法知道的话，发送者就得先将数据大小发送过来，然后再发送实际的数组数据。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="module-and-pack.html" class="navigation navigation-prev " aria-label="Previous page: 第十章：模块与包">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="concurrent-programming.html" class="navigation navigation-next " aria-label="Next page: 第十二章：并发编程">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第十一章：网络与 Web 编程","level":"1.12","depth":1,"next":{"title":"第十二章：并发编程","level":"1.13","depth":1,"path":"concurrent-programming.md","ref":"concurrent-programming.md","articles":[]},"previous":{"title":"第十章：模块与包","level":"1.11","depth":1,"path":"module-and-pack.md","ref":"module-and-pack.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"network-and-web-programming.md","mtime":"2025-01-09T21:48:32.002Z","type":"markdown"},"gitbook":{"version":"6.0.2","time":"2025-01-11T18:48:45.487Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

