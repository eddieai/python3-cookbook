
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第十二章：并发编程 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="scripting-and-systems-management.html" />
    
    
    <link rel="prev" href="network-and-web-programming.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="data-structures-and-algorithms.html">
            
                <a href="data-structures-and-algorithms.html">
            
                    
                    第一章：数据结构和算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="string-and-text.html">
            
                <a href="string-and-text.html">
            
                    
                    第二章：字符串和文本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="digital-date-and-time.html">
            
                <a href="digital-date-and-time.html">
            
                    
                    第三章：数字日期和时间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="iterators-and-generators.html">
            
                <a href="iterators-and-generators.html">
            
                    
                    第四章：迭代器与生成器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="files-and-io.html">
            
                <a href="files-and-io.html">
            
                    
                    第五章：文件与 IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="coding-and-processing-data.html">
            
                <a href="coding-and-processing-data.html">
            
                    
                    第六章：数据编码和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    第七章：函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="classes-and-objects.html">
            
                <a href="classes-and-objects.html">
            
                    
                    第八章：类与对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="metaprogramming.html">
            
                <a href="metaprogramming.html">
            
                    
                    第九章：元编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="module-and-pack.html">
            
                <a href="module-and-pack.html">
            
                    
                    第十章：模块与包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="network-and-web-programming.html">
            
                <a href="network-and-web-programming.html">
            
                    
                    第十一章：网络与 Web 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.13" data-path="concurrent-programming.html">
            
                <a href="concurrent-programming.html">
            
                    
                    第十二章：并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="scripting-and-systems-management.html">
            
                <a href="scripting-and-systems-management.html">
            
                    
                    第十三章：脚本编程与系统管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="testing-debugging-and-exception.html">
            
                <a href="testing-debugging-and-exception.html">
            
                    
                    第十四章：测试、调试和异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="c-language-extensions.html">
            
                <a href="c-language-extensions.html">
            
                    
                    第十五章：C 语言扩展
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第十二章：并发编程</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第十二章：并发编程">第十二章：并发编程</h1>
<p>对于并发编程, Python 有多种长期支持的方法, 包括多线程, 调用子进程, 以及各种各样的关于生成器函数的技巧. 这一章将会给出并发编程各种方面的技巧, 包括通用的多线程技术以及并行计算的实现方法.</p>
<p>像经验丰富的程序员所知道的那样, 大家担心并发的程序有潜在的危险. 因此, 本章的主要目标之一是给出更加可信赖和易调试的代码.</p>
<h1 id="121-启动与停止线程">12.1 启动与停止线程</h1>
<h2 id="问题">问题</h2>
<p>你要为需要并发执行的代码创建/销毁线程</p>
<h2 id="解决方案">解决方案</h2>
<p><code>threading</code>库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可以创建一个 <code>Thread</code> 对象并将你要执行的对象以 target 参数的形式提供给该对象。 下面是一个简单的例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Code to execute in an independent thread</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'T-minus'</span>, n)
        n -= <span class="hljs-number">1</span>
        time.sleep(<span class="hljs-number">5</span>)

<span class="hljs-comment"># Create and launch a thread</span>
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
t = Thread(target=countdown, args=(<span class="hljs-number">10</span>,))
t.start()
</code></pre>
<p>当你创建好一个线程对象后，该对象并不会立即执行，除非你调用它的 <code>start()</code> 方法（当你调用 <code>start()</code> 方法时，它会调用你传递进来的函数，并把你传递进来的参数传递给该函数）。Python 中的线程会在一个单独的系统级线程中执行（比如说一个 POSIX 线程或者一个 Windows 线程），这些线程将由操作系统来全权管理。线程一旦启动，将独立执行直到目标函数返回。你可以查询一个线程对象的状态，看它是否还在执行：</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> t.is_alive():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Still running'</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Completed'</span>)
</code></pre>
<p>你也可以将一个线程加入到当前线程，并等待它终止：</p>
<pre><code class="lang-python">t.join()
</code></pre>
<p>Python 解释器在所有线程都终止后才继续执行代码剩余的部分。对于需要长时间运行的线程或者需要一直运行的后台任务，你应当考虑使用后台线程。 例如：</p>
<pre><code class="lang-python">t = Thread(target=countdown, args=(<span class="hljs-number">10</span>,), daemon=<span class="hljs-literal">True</span>)
t.start()
</code></pre>
<p>后台线程无法等待，不过，这些线程会在主线程终止时自动销毁。 除了如上所示的两个操作，并没有太多可以对线程做的事情。你无法结束一个线程，无法给它发送信号，无法调整它的调度，也无法执行其他高级操作。如果需要这些特性，你需要自己添加。比如说，如果你需要终止线程，那么这个线程必须通过编程在某个特定点轮询来退出。你可以像下边这样把线程放入一个类中：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountdownTask</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._running = <span class="hljs-literal">True</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">terminate</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._running = <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, n</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>._running <span class="hljs-keyword">and</span> n &gt; <span class="hljs-number">0</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'T-minus'</span>, n)
            n -= <span class="hljs-number">1</span>
            time.sleep(<span class="hljs-number">5</span>)

    c = CountdownTask()
    t = Thread(target=c.run, args=(<span class="hljs-number">10</span>,))
    t.start()
    c.terminate() <span class="hljs-comment"># Signal termination</span>
    t.join()      <span class="hljs-comment"># Wait for actual termination (if needed)</span>
</code></pre>
<p>如果线程执行一些像 I/O 这样的阻塞操作，那么通过轮询来终止线程将使得线程之间的协调变得非常棘手。比如，如果一个线程一直阻塞在一个 I/O 操作上，它就永远无法返回，也就无法检查自己是否已经被结束了。要正确处理这些问题，你需要利用超时循环来小心操作线程。 例子如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IOTask</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">terminate</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._running = <span class="hljs-literal">False</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, sock</span>):
        <span class="hljs-comment"># sock is a socket</span>
        sock.settimeout(<span class="hljs-number">5</span>)        <span class="hljs-comment"># Set timeout period</span>
        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>._running:
            <span class="hljs-comment"># Perform a blocking I/O operation w/ timeout</span>
            <span class="hljs-keyword">try</span>:
                data = sock.recv(<span class="hljs-number">8192</span>)
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">except</span> socket.timeout:
                <span class="hljs-keyword">continue</span>
            <span class="hljs-comment"># Continued processing</span>
            ...
        <span class="hljs-comment"># Terminated</span>
        <span class="hljs-keyword">return</span>
</code></pre>
<h2 id="讨论">讨论</h2>
<p>由于全局解释锁（GIL）的原因，Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。所以，Python 的线程更适用于处理 I/O 和其他需要并发执行的阻塞操作（比如等待 I/O、等待从数据库获取数据等等），而不是需要多处理器并行的计算密集型任务。</p>
<p>有时你会看到下边这种通过继承 <code>Thread</code> 类来实现的线程：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CountdownThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-variable language_">self</span>.n = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>.n &gt; <span class="hljs-number">0</span>:

            <span class="hljs-built_in">print</span>(<span class="hljs-string">'T-minus'</span>, <span class="hljs-variable language_">self</span>.n)
            <span class="hljs-variable language_">self</span>.n -= <span class="hljs-number">1</span>
            time.sleep(<span class="hljs-number">5</span>)

c = CountdownThread(<span class="hljs-number">5</span>)
c.start()
</code></pre>
<p>尽管这样也可以工作，但这使得你的代码依赖于 <code>threading</code> 库，所以你的这些代码只能在线程上下文中使用。上文所写的那些代码、函数都是与 <code>threading</code> 库无关的，这样就使得这些代码可以被用在其他的上下文中，可能与线程有关，也可能与线程无关。比如，你可以通过 <code>multiprocessing</code> 模块在一个单独的进程中执行你的代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> multiprocessing
c = CountdownTask(<span class="hljs-number">5</span>)
p = multiprocessing.Process(target=c.run)
p.start()
</code></pre>
<p>再次重申，这段代码仅适用于 CountdownTask 类是以独立于实际的并发手段（多线程、多进程等等）实现的情况。</p>
<h1 id="122-判断线程是否已经启动">12.2 判断线程是否已经启动</h1>
<h2 id="问题">问题</h2>
<p>你已经启动了一个线程，但是你想知道它是不是真的已经开始运行了。</p>
<h2 id="解决方案">解决方案</h2>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 <code>threading</code> 库中的 <code>Event</code> 对象。 <code>Event</code> 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。 下边的代码展示了如何使用 <code>Event</code> 来协调线程的启动：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Event
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># Code to execute in an independent thread</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n, started_evt</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'countdown starting'</span>)
    started_evt.<span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'T-minus'</span>, n)
        n -= <span class="hljs-number">1</span>
        time.sleep(<span class="hljs-number">5</span>)

<span class="hljs-comment"># Create the event object that will be used to signal startup</span>
started_evt = Event()

<span class="hljs-comment"># Launch the thread and pass the startup event</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Launching countdown'</span>)
t = Thread(target=countdown, args=(<span class="hljs-number">10</span>,started_evt))
t.start()

<span class="hljs-comment"># Wait for the thread to start</span>
started_evt.wait()
<span class="hljs-built_in">print</span>(<span class="hljs-string">'countdown is running'</span>)
</code></pre>
<p>当你执行这段代码，“countdown is running” 总是显示在 “countdown starting” 之后显示。这是由于使用 event 来协调线程，使得主线程要等到 <code>countdown()</code> 函数输出启动信息后，才能继续执行。</p>
<h2 id="讨论">讨论</h2>
<p>event 对象最好单次使用，就是说，你创建一个 event 对象，让某个线程等待这个对象，一旦这个对象被设置为真，你就应该丢弃它。尽管可以通过 <code>clear()</code> 方法来重置 event 对象，但是很难确保安全地清理 event 对象并对它重新赋值。很可能会发生错过事件、死锁或者其他问题（特别是，你无法保证重置 event 对象的代码会在线程再次等待这个 event 对象之前执行）。如果一个线程需要不停地重复使用 event 对象，你最好使用 <code>Condition</code> 对象来代替。下面的代码使用 <code>Condition</code> 对象实现了一个周期定时器，每当定时器超时的时候，其他线程都可以监测到：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PeriodicTimer</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, interval</span>):
        <span class="hljs-variable language_">self</span>._interval = interval
        <span class="hljs-variable language_">self</span>._flag = <span class="hljs-number">0</span>
        <span class="hljs-variable language_">self</span>._cv = threading.Condition()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):
        t = threading.Thread(target=<span class="hljs-variable language_">self</span>.run)
        t.daemon = <span class="hljs-literal">True</span>

        t.start()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Run the timer and notify waiting threads after each interval
        '''</span>
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            time.sleep(<span class="hljs-variable language_">self</span>._interval)
            <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>._cv:
                 <span class="hljs-variable language_">self</span>._flag ^= <span class="hljs-number">1</span>
                 <span class="hljs-variable language_">self</span>._cv.notify_all()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wait_for_tick</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Wait for the next tick of the timer
        '''</span>
        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>._cv:
            last_flag = <span class="hljs-variable language_">self</span>._flag
            <span class="hljs-keyword">while</span> last_flag == <span class="hljs-variable language_">self</span>._flag:
                <span class="hljs-variable language_">self</span>._cv.wait()

<span class="hljs-comment"># Example use of the timer</span>
ptimer = PeriodicTimer(<span class="hljs-number">5</span>)
ptimer.start()

<span class="hljs-comment"># Two threads that synchronize on the timer</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">nticks</span>):
    <span class="hljs-keyword">while</span> nticks &gt; <span class="hljs-number">0</span>:
        ptimer.wait_for_tick()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'T-minus'</span>, nticks)
        nticks -= <span class="hljs-number">1</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">countup</span>(<span class="hljs-params">last</span>):
    n = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> n &lt; last:
        ptimer.wait_for_tick()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Counting'</span>, n)
        n += <span class="hljs-number">1</span>

threading.Thread(target=countdown, args=(<span class="hljs-number">10</span>,)).start()
threading.Thread(target=countup, args=(<span class="hljs-number">5</span>,)).start()
</code></pre>
<p>event 对象的一个重要特点是当它被设置为真时会唤醒所有等待它的线程。如果你只想唤醒单个线程，最好是使用信号量或者 <code>Condition</code> 对象来替代。考虑一下这段使用信号量实现的代码：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Worker thread</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">n, sema</span>):
    <span class="hljs-comment"># Wait to be signaled</span>
    sema.acquire()

    <span class="hljs-comment"># Do some work</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Working'</span>, n)

<span class="hljs-comment"># Create some threads</span>
sema = threading.Semaphore(<span class="hljs-number">0</span>)
nworkers = <span class="hljs-number">10</span>
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nworkers):
    t = threading.Thread(target=worker, args=(n, sema,))
    t.start()
</code></pre>
<p>运行上边的代码将会启动一个线程池，但是并没有什么事情发生。这是因为所有的线程都在等待获取信号量。每次信号量被释放，只有一个线程会被唤醒并执行，示例如下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>sema.release()
Working <span class="hljs-number">0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sema.release()
Working <span class="hljs-number">1</span>
&gt;&gt;&gt;
</code></pre>
<p>编写涉及到大量的线程间同步问题的代码会让你痛不欲生。比较合适的方式是使用队列来进行线程间通信或者每个把线程当作一个 Actor，利用 Actor 模型来控制并发。下一节将会介绍到队列，而 Actor 模型将在12.10节介绍。</p>
<h1 id="123-线程间通信">12.3 线程间通信</h1>
<h2 id="问题">问题</h2>
<p>你的程序中有多个线程，你需要在这些线程之间安全地交换信息或数据</p>
<h2 id="解决方案">解决方案</h2>
<p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code>queue</code> 库中的队列了。创建一个被多个线程共享的 <code>Queue</code> 对象，这些线程通过使用<code>put()</code> 和 <code>get()</code> 操作来向队列中添加或者删除元素。 例如：</p>
<p><code>Queue</code>对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。 当使用队列时，协调生产者和消费者的关闭问题可能会有一些麻烦。一个通用的解决方法是在队列中放置一个特殊的只，当消费者读到这个值的时候，终止执行。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread

<span class="hljs-comment"># Object that signals shutdown</span>
_sentinel = <span class="hljs-built_in">object</span>()

<span class="hljs-comment"># A thread that produces data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(<span class="hljs-params">out_q</span>):
    <span class="hljs-keyword">while</span> running:
        <span class="hljs-comment"># Produce some data</span>
        ...
        out_q.put(data)

    <span class="hljs-comment"># Put the sentinel on the queue to indicate completion</span>
    out_q.put(_sentinel)

<span class="hljs-comment"># A thread that consumes data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">in_q</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># Get some data</span>
        data = in_q.get()

        <span class="hljs-comment"># Check for termination</span>
        <span class="hljs-keyword">if</span> data <span class="hljs-keyword">is</span> _sentinel:
            in_q.put(_sentinel)
            <span class="hljs-keyword">break</span>

        <span class="hljs-comment"># Process the data</span>
        ...
</code></pre>
<p>本例中有一个特殊的地方：消费者在读到这个特殊值之后立即又把它放回到队列中，将之传递下去。这样，所有监听这个队列的消费者线程就可以全部关闭了。 尽管队列是最常见的线程间通信机制，但是仍然可以自己通过创建自己的数据结构并添加所需的锁和同步机制来实现线程间通信。最常见的方法是使用<code>Condition</code>变量来包装你的数据结构。下边这个例子演示了如何创建一个线程安全的优先级队列，如同1.5节中介绍的那样。</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> heapq
<span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._queue = []
        <span class="hljs-variable language_">self</span>._count = <span class="hljs-number">0</span>
        <span class="hljs-variable language_">self</span>._cv = threading.Condition()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, item, priority</span>):
        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>._cv:
            heapq.heappush(<span class="hljs-variable language_">self</span>._queue, (-priority, <span class="hljs-variable language_">self</span>._count, item))
            <span class="hljs-variable language_">self</span>._count += <span class="hljs-number">1</span>
            <span class="hljs-variable language_">self</span>._cv.notify()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>._cv:
            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._queue) == <span class="hljs-number">0</span>:
                <span class="hljs-variable language_">self</span>._cv.wait()
            <span class="hljs-keyword">return</span> heapq.heappop(<span class="hljs-variable language_">self</span>._queue)[-<span class="hljs-number">1</span>]
</code></pre>
<p>使用队列来进行线程间通信是一个单向、不确定的过程。通常情况下，你没有办法知道接收数据的线程是什么时候接收到的数据并开始工作的。不过队列对象提供一些基本完成的特性，比如下边这个例子中的<code>task_done()</code> 和<code>join()</code>：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread

<span class="hljs-comment"># A thread that produces data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(<span class="hljs-params">out_q</span>):
    <span class="hljs-keyword">while</span> running:
        <span class="hljs-comment"># Produce some data</span>
        ...
        out_q.put(data)

<span class="hljs-comment"># A thread that consumes data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">in_q</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># Get some data</span>
        data = in_q.get()

        <span class="hljs-comment"># Process the data</span>
        ...
        <span class="hljs-comment"># Indicate completion</span>
        in_q.task_done()

<span class="hljs-comment"># Create the shared queue and launch both threads</span>
q = Queue()
t1 = Thread(target=consumer, args=(q,))
t2 = Thread(target=producer, args=(q,))
t1.start()
t2.start()

<span class="hljs-comment"># Wait for all produced items to be consumed</span>
q.join()
</code></pre>
<p>如果一个线程需要在一个“消费者”线程处理完特定的数据项时立即得到通知，你可以把要发送的数据和一个 <code>Event</code> 放到一起使用，这样“生产者”就可以通过这个 Event 对象来监测处理的过程了。示例如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Event

<span class="hljs-comment"># A thread that produces data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(<span class="hljs-params">out_q</span>):
    <span class="hljs-keyword">while</span> running:
        <span class="hljs-comment"># Produce some data</span>
        ...
        <span class="hljs-comment"># Make an (data, event) pair and hand it to the consumer</span>
        evt = Event()
        out_q.put((data, evt))
        ...
        <span class="hljs-comment"># Wait for the consumer to process the item</span>
        evt.wait()

<span class="hljs-comment"># A thread that consumes data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">in_q</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># Get some data</span>
        data, evt = in_q.get()
        <span class="hljs-comment"># Process the data</span>
        ...
        <span class="hljs-comment"># Indicate completion</span>
        evt.<span class="hljs-built_in">set</span>()
</code></pre>
<h2 id="讨论">讨论</h2>
<p>基于简单队列编写多线程程序在多数情况下是一个比较明智的选择。从线程安全队列的底层实现来看，你无需在你的代码中使用锁和其他底层的同步机制，这些只会把你的程序弄得乱七八糟。此外，使用队列这种基于消息的通信机制可以被扩展到更大的应用范畴，比如，你可以把你的程序放入多个进程甚至是分布式系统而无需改变底层的队列结构。 使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递不可修改的数据结构（如：整型、字符串或者元组）或者一个对象的深拷贝。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">import</span> copy

<span class="hljs-comment"># A thread that produces data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(<span class="hljs-params">out_q</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># Produce some data</span>
        ...
        out_q.put(copy.deepcopy(data))

<span class="hljs-comment"># A thread that consumes data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">in_q</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># Get some data</span>
        data = in_q.get()
        <span class="hljs-comment"># Process the data</span>
        ...
</code></pre>
<p><code>Queue</code> 对象提供一些在当前上下文很有用的附加特性。比如在创建 Queue 对象时提供可选的<code>size</code> 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。在通信的线程之间进行“流量控制”是一个看起来容易实现起来困难的问题。如果你发现自己曾经试图通过摆弄队列大小来解决一个问题，这也许就标志着你的程序可能存在脆弱设计或者固有的可伸缩问题。 <code>get()</code>和<code>put()</code>方法都支持非阻塞方式和设定超时，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> queue
q = queue.Queue()

<span class="hljs-keyword">try</span>:
    data = q.get(block=<span class="hljs-literal">False</span>)
<span class="hljs-keyword">except</span> queue.Empty:
    ...

<span class="hljs-keyword">try</span>:
    q.put(item, block=<span class="hljs-literal">False</span>)
<span class="hljs-keyword">except</span> queue.Full:
    ...

<span class="hljs-keyword">try</span>:
    data = q.get(timeout=<span class="hljs-number">5.0</span>)
<span class="hljs-keyword">except</span> queue.Empty:
    ...
</code></pre>
<p>这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况，比如，一个非阻塞的<code>put()</code> 方法和一个固定大小的队列一起使用，这样当队列已满时就可以执行不同的代码。比如输出一条日志信息并丢弃。</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">producer</span>(<span class="hljs-params">q</span>):
    ...
    <span class="hljs-keyword">try</span>:
        q.put(item, block=<span class="hljs-literal">False</span>)
    <span class="hljs-keyword">except</span> queue.Full:
        log.warning(<span class="hljs-string">'queued item %r discarded!'</span>, item)
</code></pre>
<p>如果你试图让消费者线程在执行像 <code>q.get()</code>这样的操作时，超时自动终止以便检查终止标志，你应该使用<code>q.get()</code>的可选参数 <code>timeout</code>，如下：</p>
<pre><code class="lang-python">_running = <span class="hljs-literal">True</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">q</span>):
    <span class="hljs-keyword">while</span> _running:
        <span class="hljs-keyword">try</span>:
            item = q.get(timeout=<span class="hljs-number">5.0</span>)
            <span class="hljs-comment"># Process item</span>
            ...
        <span class="hljs-keyword">except</span> queue.Empty:
            <span class="hljs-keyword">pass</span>
</code></pre>
<p>最后，有 <code>q.qsize()</code> ， <code>q.full()</code>，<code>q.empty()</code> 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 <code>empty()</code>判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。所以，你最好不要在你的代码中使用这些方法。</p>
<h1 id="124-给关键部分加锁">12.4 给关键部分加锁</h1>
<h2 id="问题">问题</h2>
<p>你需要对多线程程序中的临界区加锁以避免竞争条件。</p>
<h2 id="解决方案">解决方案</h2>
<p>要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 <code>Lock</code> 对象，就像下边这个例子这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedCounter</span>:
    <span class="hljs-string">'''
    A counter object that can be shared by multiple threads.
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initial_value = <span class="hljs-number">0</span></span>):
        <span class="hljs-variable language_">self</span>._value = initial_value
        <span class="hljs-variable language_">self</span>._value_lock = threading.Lock()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">incr</span>(<span class="hljs-params">self,delta=<span class="hljs-number">1</span></span>):
        <span class="hljs-string">'''
        Increment the counter with locking
        '''</span>
        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>._value_lock:
             <span class="hljs-variable language_">self</span>._value += delta

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decr</span>(<span class="hljs-params">self,delta=<span class="hljs-number">1</span></span>):
        <span class="hljs-string">'''
        Decrement the counter with locking
        '''</span>
        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>._value_lock:
             <span class="hljs-variable language_">self</span>._value -= delta
</code></pre>
<p><code>Lock</code> 对象和 <code>with</code> 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p>
<h2 id="讨论">讨论</h2>
<p>线程调度本质上是不确定的，因此，在多线程程序中错误地使用锁机制可能会导致随机数据损坏或者其他的异常行为，我们称之为竞争条件。为了避免竞争条件，最好只在临界区（对临界资源进行操作的那部分代码）使用锁。 在一些“老的” Python 代码中，显式获取和释放锁是很常见的。下边是一个上一个例子的变种：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedCounter</span>:
    <span class="hljs-string">'''
    A counter object that can be shared by multiple threads.
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initial_value = <span class="hljs-number">0</span></span>):
        <span class="hljs-variable language_">self</span>._value = initial_value
        <span class="hljs-variable language_">self</span>._value_lock = threading.Lock()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">incr</span>(<span class="hljs-params">self,delta=<span class="hljs-number">1</span></span>):
        <span class="hljs-string">'''
        Increment the counter with locking
        '''</span>
        <span class="hljs-variable language_">self</span>._value_lock.acquire()
        <span class="hljs-variable language_">self</span>._value += delta
        <span class="hljs-variable language_">self</span>._value_lock.release()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decr</span>(<span class="hljs-params">self,delta=<span class="hljs-number">1</span></span>):
        <span class="hljs-string">'''
        Decrement the counter with locking
        '''</span>
        <span class="hljs-variable language_">self</span>._value_lock.acquire()
        <span class="hljs-variable language_">self</span>._value -= delta
        <span class="hljs-variable language_">self</span>._value_lock.release()
</code></pre>
<p>相比于这种显式调用的方法，with 语句更加优雅，也更不容易出错，特别是程序员可能会忘记调用 release() 方法或者程序在获得锁之后产生异常这两种情况（使用 with 语句可以保证在这两种情况下仍能正确释放锁）。 为了避免出现死锁的情况，使用锁机制的程序应该设定为每个线程一次只允许获取一个锁。如果不能这样做的话，你就需要更高级的死锁避免机制，我们将在12.5节介绍。 在 <code>threading</code>库中还提供了其他的同步原语，比如 <code>RLoct</code> 和 <code>Semaphore</code> 对象。但是根据以往经验，这些原语是用于一些特殊的情况，如果你只是需要简单地对可变对象进行锁定，那就不应该使用它们。一个 <code>RLock</code>（可重入锁）可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下，当锁被持有时，只有一个线程可以使用完整的函数或者类中的方法。比如，你可以实现一个这样的 SharedCounter 类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedCounter</span>:
    <span class="hljs-string">'''
    A counter object that can be shared by multiple threads.
    '''</span>
    _lock = threading.RLock()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initial_value = <span class="hljs-number">0</span></span>):
        <span class="hljs-variable language_">self</span>._value = initial_value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">incr</span>(<span class="hljs-params">self,delta=<span class="hljs-number">1</span></span>):
        <span class="hljs-string">'''
        Increment the counter with locking
        '''</span>
        <span class="hljs-keyword">with</span> SharedCounter._lock:
            <span class="hljs-variable language_">self</span>._value += delta

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decr</span>(<span class="hljs-params">self,delta=<span class="hljs-number">1</span></span>):
        <span class="hljs-string">'''
        Decrement the counter with locking
        '''</span>
        <span class="hljs-keyword">with</span> SharedCounter._lock:
             <span class="hljs-variable language_">self</span>.incr(-delta)
</code></pre>
<p>在上边这个例子中，没有对每一个实例中的可变对象加锁，取而代之的是一个被所有实例共享的类级锁。这个锁用来同步类方法，具体来说就是，这个锁可以保证一次只有一个线程可以调用这个类方法。不过，与一个标准的锁不同的是，已经持有这个锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 decr 方法。 这种实现方式的一个特点是，无论这个类有多少个实例都只用一个锁。因此在需要大量使用计数器的情况下内存效率更高。不过这样做也有缺点，就是在程序中使用大量线程并频繁更新计数器时会有争用锁的问题。 信号量对象是一个建立在共享计数器基础上的同步原语。如果计数器不为0，with 语句将计数器减1，线程被允许执行。with 语句执行结束后，计数器加１。如果计数器为0，线程将被阻塞，直到其他线程结束将计数器加1。尽管你可以在程序中像标准锁一样使用信号量来做线程同步，但是这种方式并不被推荐，因为使用信号量为程序增加的复杂性会影响程序性能。相对于简单地作为锁使用，信号量更适用于那些需要在线程之间引入信号或者限制的程序。比如，你需要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Semaphore
<span class="hljs-keyword">import</span> urllib.request

<span class="hljs-comment"># At most, five threads allowed to run at once</span>
_fetch_url_sema = Semaphore(<span class="hljs-number">5</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_url</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">with</span> _fetch_url_sema:
        <span class="hljs-keyword">return</span> urllib.request.urlopen(url)
</code></pre>
<p>如果你对线程同步原语的底层理论和实现感兴趣，可以参考操作系统相关书籍，绝大多数都有提及。</p>
<h1 id="125-防止死锁的加锁机制">12.5 防止死锁的加锁机制</h1>
<h2 id="问题">问题</h2>
<p>你正在写一个多线程程序，其中线程需要一次获取多个锁，此时如何避免死锁问题。</p>
<h2 id="解决方案">解决方案</h2>
<p>在多线程程序中，死锁问题很大一部分是由于线程同时获取多个锁造成的。举个例子：一个线程获取了第一个锁，然后在获取第二个锁的时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。 解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的 id，然后只允许按照升序规则来使用多个锁，这个规则使用上下文管理器 是非常容易实现的，示例如下：</p>
<p>如何使用这个上下文管理器呢？你可以按照正常途径创建一个锁对象，但不论是单个锁还是多个锁中都使用 <code>acquire()</code>函数来申请锁， 示例如下：</p>
<p>如果你执行这段代码，你会发现它即使在不同的函数中以不同的顺序获取锁也没有发生死锁。 其关键在于，在第一段代码中，我们对这些锁进行了排序。通过排序，使得不管用户以什么样的顺序来请求锁，这些锁都会按照固定的顺序被获取。 如果有多个 <code>acquire()</code> 操作被嵌套调用，可以通过线程本地存储（TLS）来检测潜在的死锁问题。 假设你的代码是这样写的：</p>
<p>如果你运行这个版本的代码，必定会有一个线程发生崩溃，异常信息可能像这样：</p>
<p>发生崩溃的原因在于，每个线程都记录着自己已经获取到的锁。<code>acquire()</code>函数会检查之前已经获取的锁列表， 由于锁是按照升序排列获取的，所以函数会认为之前已获取的锁的 id 必定小于新申请到的锁，这时就会触发异常。</p>
<h2 id="讨论">讨论</h2>
<p>死锁是每一个多线程程序都会面临的一个问题（就像它是每一本操作系统课本的共同话题一样）。根据经验来讲，尽可能保证每一个 线程只能同时保持一个锁，这样程序就不会被死锁问题所困扰。一旦有线程同时申请多个锁，一切就不可预料了。</p>
<p>死锁的检测与恢复是一个几乎没有优雅的解决方案的扩展话题。一个比较常用的死锁检测与恢复的方案是引入看门狗计数器。当线程正常 运行的时候会每隔一段时间重置计数器，在没有发生死锁的情况下，一切都正常进行。一旦发生死锁，由于无法重置计数器导致定时器 超时，这时程序会通过重启自身恢复到正常状态。</p>
<p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。证明就留给读者作为练习了。避免死锁的主要思想是，单纯地按照对象 id 递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。</p>
<p>下面以一个关于线程死锁的经典问题：“哲学家就餐问题”，作为本节最后一个例子。题目是这样的：五位哲学家围坐在一张桌子前，每个人 面前有一碗饭和一只筷子。在这里每个哲学家可以看做是一个独立的线程，而每只筷子可以看做是一个锁。每个哲学家可以处在静坐、 思考、吃饭三种状态中的一个。需要注意的是，每个哲学家吃饭是需要两只筷子的，这样问题就来了：如果每个哲学家都拿起自己左边的筷子， 那么他们五个都只能拿着一只筷子坐在那儿，直到饿死。此时他们就进入了死锁状态。 下面是一个简单的使用死锁避免机制解决“哲学家就餐问题”的实现：</p>
<p>最后，要特别注意到，为了避免死锁，所有的加锁操作必须使用 <code>acquire()</code>函数。如果代码中的某部分绕过 acquire 函数直接申请锁，那么整个死锁避免机制就不起作用了。</p>
<h1 id="126-保存线程的状态信息">12.6 保存线程的状态信息</h1>
<h2 id="问题">问题</h2>
<p>你需要保存正在运行线程的状态，这个状态对于其他的线程是不可见的。</p>
<h2 id="解决方案">解决方案</h2>
<p>有时在多线程编程中，你需要只保存当前运行线程的状态。 要这么做，可使用 <code>thread.local()</code> 创建一个本地线程存储对象。 对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p>
<p>作为使用本地存储的一个有趣的实际例子， 考虑在8.3小节定义过的 <code>LazyConnection</code> 上下文管理器类。 下面我们对它进行一些小的修改使得它可以适用于多线程：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM
<span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyConnection</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, address, family=AF_INET, <span class="hljs-built_in">type</span>=SOCK_STREAM</span>):
        <span class="hljs-variable language_">self</span>.address = address
        <span class="hljs-variable language_">self</span>.family = AF_INET
        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">type</span> = SOCK_STREAM
        <span class="hljs-variable language_">self</span>.local = threading.local()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(<span class="hljs-variable language_">self</span>.local, <span class="hljs-string">'sock'</span>):
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Already connected'</span>)
        <span class="hljs-variable language_">self</span>.local.sock = socket(<span class="hljs-variable language_">self</span>.family, <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">type</span>)
        <span class="hljs-variable language_">self</span>.local.sock.connect(<span class="hljs-variable language_">self</span>.address)
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.local.sock

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_ty, exc_val, tb</span>):
        <span class="hljs-variable language_">self</span>.local.sock.close()
        <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.local.sock
</code></pre>
<p>代码中，自己观察对于<code>self.local</code>属性的使用。 它被初始化尾一个 <code>threading.local()</code>实例。 其他方法操作被存储为 <code>self.local.sock</code>的套接字对象。 有了这些就可以在多线程中安全的使用 <code>LazyConnection</code>实例了。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial
<span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">conn</span>):
    <span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> s:
        s.send(<span class="hljs-string">b'GET /index.html HTTP/1.0\r\n'</span>)
        s.send(<span class="hljs-string">b'Host: www.python.org\r\n'</span>)

        s.send(<span class="hljs-string">b'\r\n'</span>)
        resp = <span class="hljs-string">b''</span>.join(<span class="hljs-built_in">iter</span>(partial(s.recv, <span class="hljs-number">8192</span>), <span class="hljs-string">b''</span>))

    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got {} bytes'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(resp)))

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    conn = LazyConnection((<span class="hljs-string">'www.python.org'</span>, <span class="hljs-number">80</span>))

    t1 = threading.Thread(target=test, args=(conn,))
    t2 = threading.Thread(target=test, args=(conn,))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
</code></pre>
<p>它之所以行得通的原因是每个线程会创建一个自己专属的套接字连接（存储为 self.local.sock）。 因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p>
<h2 id="讨论">讨论</h2>
<p>在大部分程序中创建和操作线程特定状态并不会有什么问题。 不过，当出了问题的时候，通常是因为某个对象被多个线程使用到，用来操作一些专用的系统资源， 比如一个套接字或文件。你不能让所有线程贡献一个单独对象， 因为多个线程同时读和写的时候会产生混乱。 本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。</p>
<p>本节中，使用 <code>thread.local()</code>可以让 <code>LazyConnection</code>类支持一个线程一个连接， 而不是对于所有的进程都只有一个连接。</p>
<p>其原理是，每个 <code>threading.local()</code> 实例为每个线程维护着一个单独的实例字典。 所有普通实例操作比如获取、修改和删除值仅仅操作这个字典。 每个线程使用一个独立的字典就可以保证数据的隔离了。</p>
<h1 id="127-创建一个线程池">12.7 创建一个线程池</h1>
<h2 id="问题">问题</h2>
<p>你创建一个工作者线程池，用来相应客户端请求或执行其他的工作。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>concurrent.futures</code> 函数库有一个<code>ThreadPoolExecutor</code> 类可以被用来完成这个任务。 下面是一个简单的 TCP 服务器，使用了一个线程池来响应客户端：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> AF_INET, SOCK_STREAM, socket
<span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_client</span>(<span class="hljs-params">sock, client_addr</span>):
    <span class="hljs-string">'''
    Handle a client connection
    '''</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from'</span>, client_addr)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        msg = sock.recv(<span class="hljs-number">65536</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
            <span class="hljs-keyword">break</span>
        sock.sendall(msg)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Client closed connection'</span>)
    sock.close()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_server</span>(<span class="hljs-params">addr</span>):
    pool = ThreadPoolExecutor(<span class="hljs-number">128</span>)
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(addr)
    sock.listen(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client_sock, client_addr = sock.accept()
        pool.submit(echo_client, client_sock, client_addr)

echo_server((<span class="hljs-string">''</span>,<span class="hljs-number">15000</span>))
</code></pre>
<p>如果你想手动创建你自己的线程池， 通常可以使用一个 Queue 来轻松实现。下面是一个稍微不同但是手动实现的例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_client</span>(<span class="hljs-params">q</span>):
    <span class="hljs-string">'''
    Handle a client connection
    '''</span>
    sock, client_addr = q.get()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from'</span>, client_addr)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        msg = sock.recv(<span class="hljs-number">65536</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
            <span class="hljs-keyword">break</span>
        sock.sendall(msg)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Client closed connection'</span>)

    sock.close()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_server</span>(<span class="hljs-params">addr, nworkers</span>):
    <span class="hljs-comment"># Launch the client workers</span>
    q = Queue()
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nworkers):
        t = Thread(target=echo_client, args=(q,))
        t.daemon = <span class="hljs-literal">True</span>
        t.start()

    <span class="hljs-comment"># Run the server</span>
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(addr)
    sock.listen(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client_sock, client_addr = sock.accept()
        q.put((client_sock, client_addr))

echo_server((<span class="hljs-string">''</span>,<span class="hljs-number">15000</span>), <span class="hljs-number">128</span>)
</code></pre>
<p>使用 <code>ThreadPoolExecutor</code> 相对于手动实现的一个好处在于它使得 任务提交者更方便的从被调用函数中获取返回值。例如，你可能会像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor
<span class="hljs-keyword">import</span> urllib.request

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_url</span>(<span class="hljs-params">url</span>):
    u = urllib.request.urlopen(url)
    data = u.read()
    <span class="hljs-keyword">return</span> data

pool = ThreadPoolExecutor(<span class="hljs-number">10</span>)
<span class="hljs-comment"># Submit work to the pool</span>
a = pool.submit(fetch_url, <span class="hljs-string">'http://www.python.org'</span>)
b = pool.submit(fetch_url, <span class="hljs-string">'http://www.pypy.org'</span>)

<span class="hljs-comment"># Get the results back</span>
x = a.result()
y = b.result()
</code></pre>
<p>例子中返回的 handle 对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，<code>a.result()</code> 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p>
<h2 id="讨论">讨论</h2>
<p>通常来讲，你应该避免编写线程数量可以无限制增长的程序。例如，看看下面这个服务器：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
<span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_client</span>(<span class="hljs-params">sock, client_addr</span>):
    <span class="hljs-string">'''
    Handle a client connection
    '''</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from'</span>, client_addr)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        msg = sock.recv(<span class="hljs-number">65536</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> msg:
            <span class="hljs-keyword">break</span>
        sock.sendall(msg)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Client closed connection'</span>)
    sock.close()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_server</span>(<span class="hljs-params">addr, nworkers</span>):
    <span class="hljs-comment"># Run the server</span>
    sock = socket(AF_INET, SOCK_STREAM)
    sock.bind(addr)
    sock.listen(<span class="hljs-number">5</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        client_sock, client_addr = sock.accept()
        t = Thread(target=echo_client, args=(client_sock, client_addr))
        t.daemon = <span class="hljs-literal">True</span>
        t.start()

echo_server((<span class="hljs-string">''</span>,<span class="hljs-number">15000</span>))
</code></pre>
<p>尽管这个也可以工作， 但是它不能抵御有人试图通过创建大量线程让你服务器资源枯竭而崩溃的攻击行为。 通过使用预先初始化的线程池，你可以设置同时运行线程的上限数量。</p>
<p>你可能会关心创建大量线程会有什么后果。 现代操作系统可以很轻松的创建几千个线程的线程池。 甚至，同时几千个线程等待工作并不会对其他代码产生性能影响。 当然了，如果所有线程同时被唤醒并立即在 CPU 上执行，那就不同了——特别是有了全局解释器锁 GIL。 通常，你应该只在 I/O 处理相关代码中使用线程池。</p>
<p>创建大的线程池的一个可能需要关注的问题是内存的使用。 例如，如果你在 OS X 系统上面创建2000个线程，系统显示 Python 进程使用了超过 9 GB 的虚拟内存。 不过，这个计算通常是有误差的。当创建一个线程时，操作系统会预留一个虚拟内存区域来 放置线程的执行栈（通常是 8 MB 大小）。但是这个内存只有一小片段被实际映射到真实内存中。 因此，Python 进程使用到的真实内存其实很小 （比如，对于2000个线程来讲，只使用到了 70 MB 的真实内存，而不是 9 GB）。 如果你担心虚拟内存大小，可以使用 <code>threading.stack_size()</code> 函数来降低它。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> threading
threading.stack_size(<span class="hljs-number">65536</span>)
</code></pre>
<p>如果你加上这条语句并再次运行前面的创建2000个线程试验， 你会发现 Python 进程只使用到了大概 210 MB 的虚拟内存，而真实内存使用量没有变。 注意线程栈大小必须至少为32768字节，通常是系统内存页大小（4096、8192等）的整数倍。</p>
<h1 id="128-简单的并行编程">12.8 简单的并行编程</h1>
<h2 id="问题">问题</h2>
<p>你有个程序要执行 CPU 密集型工作，你想让他利用多核 CPU 的优势来运行的快一点。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>concurrent.futures</code>库提供了一个 <code>ProcessPoolExecutor</code> 类， 可被用来在一个单独的 Python 解释器中执行计算密集型函数。 不过，要使用它，你首先要有一些计算密集型的任务。 我们通过一个简单而实际的例子来演示它。假定你有个 Apache web 服务器日志目录的 gzip 压缩包：</p>
<pre><code class="lang-python">logs/
   <span class="hljs-number">20120701.</span>log.gz
   <span class="hljs-number">20120702.</span>log.gz
   <span class="hljs-number">20120703.</span>log.gz
   <span class="hljs-number">20120704.</span>log.gz
   <span class="hljs-number">20120705.</span>log.gz
   <span class="hljs-number">20120706.</span>log.gz
   ...
</code></pre>
<p>进一步假设每个日志文件内容类似下面这样：</p>
<pre><code class="lang-python"><span class="hljs-number">124.115</span><span class="hljs-number">.6</span><span class="hljs-number">.12</span> - - [<span class="hljs-number">10</span>/Jul/<span class="hljs-number">2012</span>:<span class="hljs-number">00</span>:<span class="hljs-number">18</span>:<span class="hljs-number">50</span> -0500] <span class="hljs-string">"GET /robots.txt ..."</span> <span class="hljs-number">200</span> <span class="hljs-number">71</span>
<span class="hljs-number">210.212</span><span class="hljs-number">.209</span><span class="hljs-number">.67</span> - - [<span class="hljs-number">10</span>/Jul/<span class="hljs-number">2012</span>:<span class="hljs-number">00</span>:<span class="hljs-number">18</span>:<span class="hljs-number">51</span> -0500] <span class="hljs-string">"GET /ply/ ..."</span> <span class="hljs-number">200</span> <span class="hljs-number">11875</span>
<span class="hljs-number">210.212</span><span class="hljs-number">.209</span><span class="hljs-number">.67</span> - - [<span class="hljs-number">10</span>/Jul/<span class="hljs-number">2012</span>:<span class="hljs-number">00</span>:<span class="hljs-number">18</span>:<span class="hljs-number">51</span> -0500] <span class="hljs-string">"GET /favicon.ico ..."</span> <span class="hljs-number">404</span> <span class="hljs-number">369</span>
<span class="hljs-number">61.135</span><span class="hljs-number">.216</span><span class="hljs-number">.105</span> - - [<span class="hljs-number">10</span>/Jul/<span class="hljs-number">2012</span>:<span class="hljs-number">00</span>:<span class="hljs-number">20</span>:04 -0500] <span class="hljs-string">"GET /blog/atom.xml ..."</span> <span class="hljs-number">304</span> -
...
</code></pre>
<p>下面是一个脚本，在这些日志文件中查找出所有访问过 robots.txt 文件的主机：</p>
<pre><code class="lang-python"><span class="hljs-comment"># findrobots.py</span>

<span class="hljs-keyword">import</span> gzip
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">import</span> glob

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_robots</span>(<span class="hljs-params">filename</span>):
    <span class="hljs-string">'''
    Find all of the hosts that access robots.txt in a single log file
    '''</span>
    robots = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> io.TextIOWrapper(f,encoding=<span class="hljs-string">'ascii'</span>):
            fields = line.split()
            <span class="hljs-keyword">if</span> fields[<span class="hljs-number">6</span>] == <span class="hljs-string">'/robots.txt'</span>:
                robots.add(fields[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">return</span> robots

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_all_robots</span>(<span class="hljs-params">logdir</span>):
    <span class="hljs-string">'''
    Find all hosts across and entire sequence of files
    '''</span>
    files = glob.glob(logdir+<span class="hljs-string">'/*.log.gz'</span>)
    all_robots = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">for</span> robots <span class="hljs-keyword">in</span> <span class="hljs-built_in">map</span>(find_robots, files):
        all_robots.update(robots)
    <span class="hljs-keyword">return</span> all_robots

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    robots = find_all_robots(<span class="hljs-string">'logs'</span>)
    <span class="hljs-keyword">for</span> ipaddr <span class="hljs-keyword">in</span> robots:
        <span class="hljs-built_in">print</span>(ipaddr)
</code></pre>
<p>前面的程序使用了通常的 map-reduce 风格来编写。 函数 <code>find_robots()</code>在一个文件名集合上做 map 操作，并将结果汇总为一个单独的结果， 也就是 <code>find_all_robots()</code> 函数中的 <code>all_robots</code> 集合。 现在，假设你想要修改这个程序让它使用多核 CPU。 很简单——只需要将 map()操作替换为一个 <code>concurrent.futures</code> 库中生成的类似操作即可。 下面是一个简单修改版本：</p>
<pre><code class="lang-python"><span class="hljs-comment"># findrobots.py</span>

<span class="hljs-keyword">import</span> gzip
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">import</span> glob
<span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_robots</span>(<span class="hljs-params">filename</span>):
    <span class="hljs-string">'''
    Find all of the hosts that access robots.txt in a single log file

    '''</span>
    robots = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> io.TextIOWrapper(f,encoding=<span class="hljs-string">'ascii'</span>):
            fields = line.split()
            <span class="hljs-keyword">if</span> fields[<span class="hljs-number">6</span>] == <span class="hljs-string">'/robots.txt'</span>:
                robots.add(fields[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">return</span> robots

<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_all_robots</span>(<span class="hljs-params">logdir</span>):
    <span class="hljs-string">'''
    Find all hosts across and entire sequence of files
    '''</span>
    files = glob.glob(logdir+<span class="hljs-string">'/*.log.gz'</span>)
    all_robots = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">with</span> futures.ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:
        <span class="hljs-keyword">for</span> robots <span class="hljs-keyword">in</span> pool.<span class="hljs-built_in">map</span>(find_robots, files):
            all_robots.update(robots)
    <span class="hljs-keyword">return</span> all_robots

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    robots = find_all_robots(<span class="hljs-string">'logs'</span>)
    <span class="hljs-keyword">for</span> ipaddr <span class="hljs-keyword">in</span> robots:
        <span class="hljs-built_in">print</span>(ipaddr)
</code></pre>
<p>通过这个修改后，运行这个脚本产生同样的结果，但是在四核机器上面比之前快了3.5倍。 实际的性能优化效果根据你的机器 CPU 数量的不同而不同。</p>
<h2 id="讨论">讨论</h2>
<p><code>ProcessPoolExecutor</code> 的典型用法如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ProcessPoolExecutor

<span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:
    ...
    do work <span class="hljs-keyword">in</span> parallel using pool
    ...
</code></pre>
<p>其原理是，一个 <code>ProcessPoolExecutor</code> 创建 N 个独立的 Python 解释器， N 是系统上面可用 CPU 的个数。你可以通过提供可选参数给<code>ProcessPoolExecutor(N)</code> 来修改 处理器数量。这个处理池会一直运行到 with 块中最后一个语句执行完成， 然后处理池被关闭。不过，程序会一直等待直到所有提交的工作被处理完成。</p>
<p>被提交到池中的工作必须被定义为一个函数。有两种方法去提交。 如果你想让一个列表推导或一个 <code>map()</code> 操作并行执行的话，可使用<code>pool.map()</code> :</p>
<pre><code class="lang-python"><span class="hljs-comment"># A function that performs a lot of work</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">x</span>):
    ...
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># Nonparallel code</span>
results = <span class="hljs-built_in">map</span>(work, data)

<span class="hljs-comment"># Parallel implementation</span>
<span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:
    results = pool.<span class="hljs-built_in">map</span>(work, data)
</code></pre>
<p>另外，你可以使用<code>pool.submit()</code> 来手动的提交单个任务：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Some function</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">x</span>):
    ...
    <span class="hljs-keyword">return</span> result

<span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:
    ...
    <span class="hljs-comment"># Example of submitting work to the pool</span>
    future_result = pool.submit(work, arg)

    <span class="hljs-comment"># Obtaining the result (blocks until done)</span>
    r = future_result.result()
    ...
</code></pre>
<p>如果你手动提交一个任务，结果是一个<code>Future</code> 实例。 要获取最终结果，你需要调用它的 <code>result()</code>方法。 它会阻塞进程直到结果被返回来。</p>
<p>如果不想阻塞，你还可以使用一个回调函数，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">when_done</span>(<span class="hljs-params">r</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got:'</span>, r.result())

<span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:
     future_result = pool.submit(work, arg)
     future_result.add_done_callback(when_done)
</code></pre>
<p>回调函数接受一个 <code>Future</code> 实例，被用来获取最终的结果（比如通过调用它的 result()方法）。 尽管处理池很容易使用，在设计大程序的时候还是有很多需要注意的地方，如下几点：</p>
<ul>
<li>这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</li>
<li>被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不支持。</li>
<li>函数参数和返回值必须兼容 pickle，因为要使用到进程间的通信，所有解释器之间的交换数据必须被序列化</li>
<li><p>被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，
一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁——函数不要去修改环境。</p>
</li>
<li><p>在 Unix 上进程池通过调用 <code>fork()</code>系统调用被创建，
它会克隆 Python 解释器，包括 fork 时的所有程序状态。 而在 Windows 上，克隆解释器时不会克隆状态。 实际的 fork 操作会在第一次调用<code>pool.map()</code> 或 <code>pool.submit()</code>后发生。</p>
</li>
<li><p>当你混合使用进程池和多线程的时候要特别小心。
你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的 main 线程中创建进程池）。</p>
</li>
</ul>
<h1 id="129-python-的全局锁问题">12.9 Python 的全局锁问题</h1>
<h2 id="问题">问题</h2>
<p>你已经听说过全局解释器锁 GIL，担心它会影响到多线程程序的执行性能。</p>
<h2 id="解决方案">解决方案</h2>
<p>尽管 Python 完全支持多线程编程， 但是解释器的 C 语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个 Python 线程执行。 GIL 最大的问题就是 Python 的多线程程序并不能利用多核 CPU 的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单 CPU 上面运行）。</p>
<p>在讨论普通的 GIL 之前，有一点要强调的是 GIL 只会影响到那些严重依赖 CPU 的程序（比如计算型的）。 如果你的程序大部分只会设计到 I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个 Python 线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p>
<p>而对于依赖 CPU 的程序，你需要弄清楚执行的计算的特点。 例如，优化底层算法要比使用多线程运行快得多。 类似的，由于 Python 是解释执行的，如果你将那些性能瓶颈代码移到一个 C 语言扩展模块中， 速度也会提升的很快。如果你要操作数组，那么使用 NumPy 这样的扩展会非常的高效。 最后，你还可以考虑下其他可选实现方案，比如 PyPy，它通过一个 JIT 编译器来优化执行效率 （不过在写这本书的时候它还不能支持 Python 3）。</p>
<p>还有一点要注意的是，线程不是专门用来优化性能的。 一个 CPU 依赖型程序可能会使用线程来管理一个图形用户界面、一个网络连接或其他服务。 这时候，GIL 会产生一些问题，因为如果一个线程长期持有 GIL 的话会导致其他非 CPU 型线程一直等待。 事实上，一个写的不好的 C 语言扩展会导致这个问题更加严重， 尽管代码的计算部分会比之前运行的更快些。</p>
<p>说了这么多，现在想说的是我们有两种策略来解决 GIL 的缺点。 首先，如果你完全工作于 Python 环境中，你可以使用 <code>multiprocessing</code>模块来创建一个进程池， 并像协同处理器一样的使用它。例如，加入你有如下的线程代码：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Performs a large calculation (CPU bound)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">some_work</span>(<span class="hljs-params">args</span>):
    ...
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># A thread that calls the above function</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">some_thread</span>():
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        ...
        r = some_work(args)
    ...
</code></pre>
<p>修改代码，使用进程池：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Processing pool (see below for initiazation)</span>
pool = <span class="hljs-literal">None</span>

<span class="hljs-comment"># Performs a large calculation (CPU bound)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">some_work</span>(<span class="hljs-params">args</span>):
    ...
    <span class="hljs-keyword">return</span> result

<span class="hljs-comment"># A thread that calls the above function</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">some_thread</span>():
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        ...
        r = pool.apply(some_work, (args))
        ...

<span class="hljs-comment"># Initiaze the pool</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">import</span> multiprocessing
    pool = multiprocessing.Pool()
</code></pre>
<p>这个通过使用一个技巧利用进程池解决了 GIL 的问题。 当一个线程想要执行 CPU 密集型工作时，会将任务发给进程池。 然后进程池会在另外一个进程中启动一个单独的 Python 解释器来工作。 当线程等待结果的时候会释放 GIL。 并且，由于计算任务在单独解释器中执行，那么就不会受限于 GIL 了。 在一个多核系统上面，你会发现这个技术可以让你很好的利用多 CPU 的优势。</p>
<p>另外一个解决 GIL 的策略是使用 C 扩展编程技术。 主要思想是将计算密集型任务转移给 C，跟 Python 独立，在工作的时候在 C 代码中释放 GIL。 这可以通过在 C 代码中插入下面这样的特殊宏来完成：</p>
<pre><code class="lang-python"><span class="hljs-comment">#include "Python.h"</span>
...

PyObject *pyfunc(PyObject *<span class="hljs-variable language_">self</span>, PyObject *args) {
   ...
   Py_BEGIN_ALLOW_THREADS
   // Threaded C code
   ...
   Py_END_ALLOW_THREADS
   ...
}
</code></pre>
<p>如果你使用其他工具访问 C 语言，比如对于 Cython 的 ctypes 库，你不需要做任何事。 例如，ctypes 在调用 C 时会自动释放 GIL。</p>
<h2 id="讨论">讨论</h2>
<p>许多程序员在面对线程性能问题的时候，马上就会怪罪 GIL，什么都是它的问题。 其实这样子太不厚道也太天真了点。 作为一个真实的例子，在多线程的网络编程中神秘的 <code>stalls</code>可能是因为其他原因比如一个 DNS 查找延时，而跟 GIL 毫无关系。 最后你真的需要先去搞懂你的代码是否真的被 GIL 影响到。 同时还要明白 GIL 大部分都应该只关注 CPU 的处理而不是 I/O.</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同 Python 解释器通信。 被执行的操作需要放在一个通过 def 语句定义的 Python 函数中，不能是 lambda、闭包可调用实例等， 并且函数参数和返回值必须要兼容 pickle。 同样，要执行的任务量必须足够大以弥补额外的通宵开销。</p>
<p>另外一个难点是当混合使用线程和进程池的时候会让你很头疼。 如果你要同时使用两者，最好在程序启动时，创建任何线程之前先创建一个单例的进程池。 然后线程使用同样的进程池来进行它们的计算密集型工作。</p>
<p>C 扩展最重要的特征是它们和 Python 解释器是保持独立的。 也就是说，如果你准备将 Python 中的任务分配到 C 中去执行， 你需要确保 C 代码的操作跟 Python 保持独立， 这就意味着不要使用 Python 数据结构以及不要调用 Python 的 C API。 另外一个就是你要确保 C 扩展所做的工作是足够的，值得你这样做。 也就是说 C 扩展担负起了大量的计算任务，而不是少数几个计算。</p>
<p>这些解决 GIL 的方案并不能适用于所有问题。 例如，某些类型的应用程序如果被分解为多个进程处理的话并不能很好的工作， 也不能将它的部分代码改成C语言执行。 对于这些应用程序，你就要自己需求解决方案了 （比如多进程访问共享内存区，多解析器运行于同一个进程等）。 或者，你还可以考虑下其他的解释器实现，比如 PyPy。</p>
<p>了解更多关于在 C 扩展中释放 GIL，请参考15.7和15.10小节。</p>
<h1 id="1210-定义一个-actor-任务">12.10 定义一个 Actor 任务</h1>
<h2 id="问题">问题</h2>
<p>你想定义跟 actor 模式中类似“actors”角色的任务</p>
<h2 id="解决方案">解决方案</h2>
<p>actore 模式是一种最古老的也是最简单的并行和分布式计算解决方案。 事实上，它天生的简单性是它如此受欢迎的重要原因之一。 简单来讲，一个 actor 就是一个并发执行的任务，只是简单的执行发送给它的消息任务。 响应这些消息时，它可能还会给其他 actor 发送更进一步的消息。 actor 之间的通信是单向和异步的。因此，消息发送者不知道消息是什么时候被发送， 也不会接收到一个消息已被处理的回应或通知。</p>
<p>结合使用一个线程和一个队列可以很容易的定义 actor，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Event

<span class="hljs-comment"># Sentinel used for shutdown</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActorExit</span>(<span class="hljs-title class_ inherited__">Exception</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Actor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._mailbox = Queue()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, msg</span>):
        <span class="hljs-string">'''
        Send a message to the actor
        '''</span>
        <span class="hljs-variable language_">self</span>._mailbox.put(msg)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">recv</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Receive an incoming message
        '''</span>
        msg = <span class="hljs-variable language_">self</span>._mailbox.get()
        <span class="hljs-keyword">if</span> msg <span class="hljs-keyword">is</span> ActorExit:
            <span class="hljs-keyword">raise</span> ActorExit()
        <span class="hljs-keyword">return</span> msg

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Close the actor, thus shutting it down
        '''</span>
        <span class="hljs-variable language_">self</span>.send(ActorExit)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Start concurrent execution
        '''</span>
        <span class="hljs-variable language_">self</span>._terminated = Event()
        t = Thread(target=<span class="hljs-variable language_">self</span>._bootstrap)

        t.daemon = <span class="hljs-literal">True</span>
        t.start()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_bootstrap</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">try</span>:
            <span class="hljs-variable language_">self</span>.run()
        <span class="hljs-keyword">except</span> ActorExit:
            <span class="hljs-keyword">pass</span>
        <span class="hljs-keyword">finally</span>:
            <span class="hljs-variable language_">self</span>._terminated.<span class="hljs-built_in">set</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._terminated.wait()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Run method to be implemented by the user
        '''</span>
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            msg = <span class="hljs-variable language_">self</span>.recv()

<span class="hljs-comment"># Sample ActorTask</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintActor</span>(<span class="hljs-title class_ inherited__">Actor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            msg = <span class="hljs-variable language_">self</span>.recv()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got:'</span>, msg)

<span class="hljs-comment"># Sample use</span>
p = PrintActor()
p.start()
p.send(<span class="hljs-string">'Hello'</span>)
p.send(<span class="hljs-string">'World'</span>)
p.close()
p.join()
</code></pre>
<p>这个例子中，你使用 actor 实例的<code>send()</code> 方法发送消息给它们。 其机制是，这个方法会将消息放入一个队里中， 然后将其转交给处理被接受消息的一个内部线程。 <code>close()</code> 方法通过在队列中放入一个特殊的哨兵值（ActorExit）来关闭这个 actor。 用户可以通过继承 Actor 并定义实现自己处理逻辑 run()方法来定义新的 actor。 <code>ActorExit</code> 异常的使用就是用户自定义代码可以在需要的时候来捕获终止请求 （异常被 get()方法抛出并传播出去）。</p>
<p>如果你放宽对于同步和异步消息发送的要求， 类 actor 对象还可以通过生成器来简化定义。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_actor</span>():
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:

        <span class="hljs-keyword">try</span>:
            msg = <span class="hljs-keyword">yield</span>      <span class="hljs-comment"># Get a message</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got:'</span>, msg)
        <span class="hljs-keyword">except</span> GeneratorExit:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Actor terminating'</span>)

<span class="hljs-comment"># Sample use</span>
p = print_actor()
<span class="hljs-built_in">next</span>(p)     <span class="hljs-comment"># Advance to the yield (ready to receive)</span>
p.send(<span class="hljs-string">'Hello'</span>)
p.send(<span class="hljs-string">'World'</span>)
p.close()
</code></pre>
<h2 id="讨论">讨论</h2>
<p>actor 模式的魅力就在于它的简单性。 实际上，这里仅仅只有一个核心操作 <code>send()</code> . 甚至，对于在基于 actor 系统中的“消息”的泛化概念可以已多种方式被扩展。 例如，你可以以元组形式传递标签消息，让 actor 执行不同的操作，如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaggedActor</span>(<span class="hljs-title class_ inherited__">Actor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
             tag, *payload = <span class="hljs-variable language_">self</span>.recv()
             <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>,<span class="hljs-string">'do_'</span>+tag)(*payload)

    <span class="hljs-comment"># Methods correponding to different message tags</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_A</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Running A'</span>, x)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_B</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Running B'</span>, x, y)

<span class="hljs-comment"># Example</span>
a = TaggedActor()
a.start()
a.send((<span class="hljs-string">'A'</span>, <span class="hljs-number">1</span>))      <span class="hljs-comment"># Invokes do_A(1)</span>
a.send((<span class="hljs-string">'B'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))   <span class="hljs-comment"># Invokes do_B(2,3)</span>
</code></pre>
<p>作为另外一个例子，下面的 actor 允许在一个工作者中运行任意的函数， 并且通过一个特殊的 Result 对象返回结果：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Event
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._evt = Event()
        <span class="hljs-variable language_">self</span>._result = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_result</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-variable language_">self</span>._result = value

        <span class="hljs-variable language_">self</span>._evt.<span class="hljs-built_in">set</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">result</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._evt.wait()
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._result

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-title class_ inherited__">Actor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">submit</span>(<span class="hljs-params">self, func, *args, **kwargs</span>):
        r = Result()
        <span class="hljs-variable language_">self</span>.send((func, args, kwargs, r))
        <span class="hljs-keyword">return</span> r

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            func, args, kwargs, r = <span class="hljs-variable language_">self</span>.recv()
            r.set_result(func(*args, **kwargs))

<span class="hljs-comment"># Example use</span>
worker = Worker()
worker.start()
r = worker.submit(<span class="hljs-built_in">pow</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(r.result())
</code></pre>
<p>最后，“发送”一个任务消息的概念可以被扩展到多进程甚至是大型分布式系统中去。 例如，一个类 actor 对象的 <code>send()</code>方法可以被编程让它能在一个套接字连接上传输数据 或通过某些消息中间件（比如 AMQP、ZMQ 等）来发送。</p>
<h1 id="1211-实现消息发布订阅模型">12.11 实现消息发布/订阅模型</h1>
<h2 id="问题">问题</h2>
<p>你有一个基于线程通信的程序，想让它们实现发布/订阅模式的消息通信。</p>
<h2 id="解决方案">解决方案</h2>
<p>要实现发布/订阅的消息通信模式， 你通常要引入一个单独的“交换机”或“网关”对象作为所有消息的中介。 也就是说，不直接将消息从一个任务发送到另一个，而是将其发送给交换机， 然后由交换机将它发送给一个或多个被关联任务。下面是一个非常简单的交换机实现例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Exchange</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._subscribers = <span class="hljs-built_in">set</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">attach</span>(<span class="hljs-params">self, task</span>):
        <span class="hljs-variable language_">self</span>._subscribers.add(task)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detach</span>(<span class="hljs-params">self, task</span>):
        <span class="hljs-variable language_">self</span>._subscribers.remove(task)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, msg</span>):
        <span class="hljs-keyword">for</span> subscriber <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._subscribers:
            subscriber.send(msg)

<span class="hljs-comment"># Dictionary of all created exchanges</span>
_exchanges = defaultdict(Exchange)

<span class="hljs-comment"># Return the Exchange instance associated with a given name</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_exchange</span>(<span class="hljs-params">name</span>):
    <span class="hljs-keyword">return</span> _exchanges[name]
</code></pre>
<p>一个交换机就是一个普通对象，负责维护一个活跃的订阅者集合，并为绑定、解绑和发送消息提供相应的方法。 每个交换机通过一个名称定位，<code>get_exchange()</code> 通过给定一个名称返回相应的<code>Exchange</code>实例。</p>
<p>下面是一个简单例子，演示了如何使用一个交换机：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example of a task.  Any object with a send() method</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span>:
    ...
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, msg</span>):
        ...

task_a = Task()
task_b = Task()

<span class="hljs-comment"># Example of getting an exchange</span>
exc = get_exchange(<span class="hljs-string">'name'</span>)

<span class="hljs-comment"># Examples of subscribing tasks to it</span>
exc.attach(task_a)
exc.attach(task_b)

<span class="hljs-comment"># Example of sending messages</span>
exc.send(<span class="hljs-string">'msg1'</span>)
exc.send(<span class="hljs-string">'msg2'</span>)

<span class="hljs-comment"># Example of unsubscribing</span>
exc.detach(task_a)
exc.detach(task_b)
</code></pre>
<p>尽管对于这个问题有很多的变种，不过万变不离其宗。 消息会被发送给一个交换机，然后交换机会将它们发送给被绑定的订阅者。</p>
<h2 id="讨论">讨论</h2>
<p>通过队列发送消息的任务或线程的模式很容易被实现并且也非常普遍。 不过，使用发布/订阅模式的好处更加明显。</p>
<p>首先，使用一个交换机可以简化大部分涉及到线程通信的工作。 无需去写通过多进程模块来操作多个线程，你只需要使用这个交换机来连接它们。 某种程度上，这个就跟日志模块的工作原理类似。 实际上，它可以轻松的解耦程序中多个任务。</p>
<p>其次，交换机广播消息给多个订阅者的能力带来了一个全新的通信模式。 例如，你可以使用多任务系统、广播或扇出。 你还可以通过以普通订阅者身份绑定来构建调试和诊断工具。 例如，下面是一个简单的诊断类，可以显示被发送的消息：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayMessages</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, msg</span>):
        <span class="hljs-variable language_">self</span>.count += <span class="hljs-number">1</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'msg[{}]: {!r}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.count, msg))

exc = get_exchange(<span class="hljs-string">'name'</span>)
d = DisplayMessages()
exc.attach(d)
</code></pre>
<p>最后，该实现的一个重要特点是它能兼容多个“task-like”对象。 例如，消息接受者可以是 actor（12.10小节介绍）、协程、网络连接或任何实现了正确的 <code>send()</code>方法的东西。</p>
<p>关于交换机的一个可能问题是对于订阅者的正确绑定和解绑。 为了正确的管理资源，每一个绑定的订阅者必须最终要解绑。 在代码中通常会是像下面这样的模式：</p>
<pre><code class="lang-python">exc = get_exchange(<span class="hljs-string">'name'</span>)
exc.attach(some_task)
<span class="hljs-keyword">try</span>:
    ...
<span class="hljs-keyword">finally</span>:
    exc.detach(some_task)
</code></pre>
<p>某种意义上，这个和使用文件、锁和类似对象很像。 通常很容易会忘记最后的<code>detach()</code> 步骤。 为了简化这个，你可以考虑使用上下文管理器协议。 例如，在交换机对象上增加一个 <code>subscribe()</code>方法，如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Exchange</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._subscribers = <span class="hljs-built_in">set</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">attach</span>(<span class="hljs-params">self, task</span>):
        <span class="hljs-variable language_">self</span>._subscribers.add(task)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detach</span>(<span class="hljs-params">self, task</span>):
        <span class="hljs-variable language_">self</span>._subscribers.remove(task)

<span class="hljs-meta">    @contextmanager</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">self, *tasks</span>):
        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:
            <span class="hljs-variable language_">self</span>.attach(task)
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">yield</span>
        <span class="hljs-keyword">finally</span>:
            <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:
                <span class="hljs-variable language_">self</span>.detach(task)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, msg</span>):
        <span class="hljs-keyword">for</span> subscriber <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._subscribers:
            subscriber.send(msg)

<span class="hljs-comment"># Dictionary of all created exchanges</span>
_exchanges = defaultdict(Exchange)

<span class="hljs-comment"># Return the Exchange instance associated with a given name</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_exchange</span>(<span class="hljs-params">name</span>):
    <span class="hljs-keyword">return</span> _exchanges[name]

<span class="hljs-comment"># Example of using the subscribe() method</span>
exc = get_exchange(<span class="hljs-string">'name'</span>)
<span class="hljs-keyword">with</span> exc.subscribe(task_a, task_b):
     ...
     exc.send(<span class="hljs-string">'msg1'</span>)
     exc.send(<span class="hljs-string">'msg2'</span>)
     ...

<span class="hljs-comment"># task_a and task_b detached here</span>
</code></pre>
<p>最后还应该注意的是关于交换机的思想有很多种的扩展实现。 例如，交换机可以实现一整个消息通道集合或提供交换机名称的模式匹配规则。 交换机还可以被扩展到分布式计算程序中（比如，将消息路由到不同机器上面的任务中去）。</p>
<h1 id="1212-使用生成器代替线程">12.12 使用生成器代替线程</h1>
<h2 id="问题">问题</h2>
<p>你想使用生成器（协程）替代系统线程来实现并发。这个有时又被称为用户级线程或绿色线程。</p>
<h2 id="解决方案">解决方案</h2>
<p>要使用生成器实现自己的并发，你首先要对生成器函数和<code>yield</code> 语句有深刻理解。 <code>yield</code> 语句会让一个生成器挂起它的执行，这样就可以编写一个调度器， 将生成器当做某种“任务”并使用任务协作切换来替换它们的执行。 要演示这种思想，考虑下面两个使用简单的<code>yield</code> 语句的生成器函数：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Two simple generator functions</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'T-minus'</span>, n)
        <span class="hljs-keyword">yield</span>
        n -= <span class="hljs-number">1</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Blastoff!'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">countup</span>(<span class="hljs-params">n</span>):
    x = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> x &lt; n:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Counting up'</span>, x)
        <span class="hljs-keyword">yield</span>
        x += <span class="hljs-number">1</span>
</code></pre>
<p>这些函数在内部使用 yield 语句，下面是一个实现了简单任务调度器的代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskScheduler</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._task_queue = deque()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_task</span>(<span class="hljs-params">self, task</span>):
        <span class="hljs-string">'''
        Admit a newly started task to the scheduler

        '''</span>
        <span class="hljs-variable language_">self</span>._task_queue.append(task)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Run until there are no more tasks
        '''</span>
        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>._task_queue:
            task = <span class="hljs-variable language_">self</span>._task_queue.popleft()
            <span class="hljs-keyword">try</span>:
                <span class="hljs-comment"># Run until the next yield statement</span>
                <span class="hljs-built_in">next</span>(task)
                <span class="hljs-variable language_">self</span>._task_queue.append(task)
            <span class="hljs-keyword">except</span> StopIteration:
                <span class="hljs-comment"># Generator is no longer executing</span>
                <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># Example use</span>
sched = TaskScheduler()
sched.new_task(countdown(<span class="hljs-number">10</span>))
sched.new_task(countdown(<span class="hljs-number">5</span>))
sched.new_task(countup(<span class="hljs-number">15</span>))
sched.run()
</code></pre>
<p><code>TaskScheduler</code> 类在一个循环中运行生成器集合——每个都运行到碰到 yield 语句为止。 运行这个例子，输出如下：</p>
<pre><code class="lang-python">T-minus <span class="hljs-number">10</span>
T-minus <span class="hljs-number">5</span>
Counting up <span class="hljs-number">0</span>
T-minus <span class="hljs-number">9</span>
T-minus <span class="hljs-number">4</span>
Counting up <span class="hljs-number">1</span>
T-minus <span class="hljs-number">8</span>
T-minus <span class="hljs-number">3</span>
Counting up <span class="hljs-number">2</span>
T-minus <span class="hljs-number">7</span>
T-minus <span class="hljs-number">2</span>
...
</code></pre>
<p>到此为止，我们实际上已经实现了一个“操作系统”的最小核心部分。 生成器函数就是认为，而 yield 语句是任务挂起的信号。 调度器循环检查任务列表直到没有任务要执行为止。</p>
<p>实际上，你可能想要使用生成器来实现简单的并发。 那么，在实现 actor 或网络服务器的时候你可以使用生成器来替代线程的使用。</p>
<p>下面的代码演示了使用生成器来实现一个不依赖线程的 actor：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ActorScheduler</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._actors = { }          <span class="hljs-comment"># Mapping of names to actors</span>
        <span class="hljs-variable language_">self</span>._msg_queue = deque()   <span class="hljs-comment"># Message queue</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_actor</span>(<span class="hljs-params">self, name, actor</span>):
        <span class="hljs-string">'''
        Admit a newly started actor to the scheduler and give it a name
        '''</span>
        <span class="hljs-variable language_">self</span>._msg_queue.append((actor,<span class="hljs-literal">None</span>))
        <span class="hljs-variable language_">self</span>._actors[name] = actor

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, name, msg</span>):
        <span class="hljs-string">'''
        Send a message to a named actor
        '''</span>
        actor = <span class="hljs-variable language_">self</span>._actors.get(name)
        <span class="hljs-keyword">if</span> actor:
            <span class="hljs-variable language_">self</span>._msg_queue.append((actor,msg))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Run as long as there are pending messages.
        '''</span>
        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>._msg_queue:
            actor, msg = <span class="hljs-variable language_">self</span>._msg_queue.popleft()
            <span class="hljs-keyword">try</span>:
                 actor.send(msg)
            <span class="hljs-keyword">except</span> StopIteration:
                 <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>():
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            msg = <span class="hljs-keyword">yield</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got:'</span>, msg)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">sched</span>):
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-comment"># Receive the current count</span>
            n = <span class="hljs-keyword">yield</span>
            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
            <span class="hljs-comment"># Send to the printer task</span>
            sched.send(<span class="hljs-string">'printer'</span>, n)
            <span class="hljs-comment"># Send the next count to the counter task (recursive)</span>

            sched.send(<span class="hljs-string">'counter'</span>, n-<span class="hljs-number">1</span>)

    sched = ActorScheduler()
    <span class="hljs-comment"># Create the initial actors</span>
    sched.new_actor(<span class="hljs-string">'printer'</span>, printer())
    sched.new_actor(<span class="hljs-string">'counter'</span>, counter(sched))

    <span class="hljs-comment"># Send an initial message to the counter to initiate</span>
    sched.send(<span class="hljs-string">'counter'</span>, <span class="hljs-number">10000</span>)
    sched.run()
</code></pre>
<p>完全弄懂这段代码需要更深入的学习，但是关键点在于收集消息的队列。 本质上，调度器在有需要发送的消息时会一直运行着。 计数生成器会给自己发送消息并在一个递归循环中结束。</p>
<p>下面是一个更加高级的例子，演示了使用生成器来实现一个并发网络应用程序：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque
<span class="hljs-keyword">from</span> select <span class="hljs-keyword">import</span> select

<span class="hljs-comment"># This class represents a generic yield event in the scheduler</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldEvent</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_yield</span>(<span class="hljs-params">self, sched, task</span>):
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_resume</span>(<span class="hljs-params">self, sched, task</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-comment"># Task Scheduler</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._numtasks = <span class="hljs-number">0</span>       <span class="hljs-comment"># Total num of tasks</span>
        <span class="hljs-variable language_">self</span>._ready = deque()    <span class="hljs-comment"># Tasks ready to run</span>
        <span class="hljs-variable language_">self</span>._read_waiting = {}  <span class="hljs-comment"># Tasks waiting to read</span>
        <span class="hljs-variable language_">self</span>._write_waiting = {} <span class="hljs-comment"># Tasks waiting to write</span>

    <span class="hljs-comment"># Poll for I/O events and restart waiting tasks</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_iopoll</span>(<span class="hljs-params">self</span>):
        rset,wset,eset = select(<span class="hljs-variable language_">self</span>._read_waiting,
                                <span class="hljs-variable language_">self</span>._write_waiting,[])
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rset:
            evt, task = <span class="hljs-variable language_">self</span>._read_waiting.pop(r)
            evt.handle_resume(<span class="hljs-variable language_">self</span>, task)
        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> wset:
            evt, task = <span class="hljs-variable language_">self</span>._write_waiting.pop(w)
            evt.handle_resume(<span class="hljs-variable language_">self</span>, task)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">new</span>(<span class="hljs-params">self,task</span>):
        <span class="hljs-string">'''
        Add a newly started task to the scheduler
        '''</span>

        <span class="hljs-variable language_">self</span>._ready.append((task, <span class="hljs-literal">None</span>))
        <span class="hljs-variable language_">self</span>._numtasks += <span class="hljs-number">1</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_ready</span>(<span class="hljs-params">self, task, msg=<span class="hljs-literal">None</span></span>):
        <span class="hljs-string">'''
        Append an already started task to the ready queue.
        msg is what to send into the task when it resumes.
        '''</span>
        <span class="hljs-variable language_">self</span>._ready.append((task, msg))

    <span class="hljs-comment"># Add a task to the reading set</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_read_wait</span>(<span class="hljs-params">self, fileno, evt, task</span>):
        <span class="hljs-variable language_">self</span>._read_waiting[fileno] = (evt, task)

    <span class="hljs-comment"># Add a task to the write set</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_write_wait</span>(<span class="hljs-params">self, fileno, evt, task</span>):
        <span class="hljs-variable language_">self</span>._write_waiting[fileno] = (evt, task)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        Run the task scheduler until there are no tasks
        '''</span>
        <span class="hljs-keyword">while</span> <span class="hljs-variable language_">self</span>._numtasks:
             <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>._ready:
                  <span class="hljs-variable language_">self</span>._iopoll()
             task, msg = <span class="hljs-variable language_">self</span>._ready.popleft()
             <span class="hljs-keyword">try</span>:
                 <span class="hljs-comment"># Run the coroutine to the next yield</span>
                 r = task.send(msg)
                 <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(r, YieldEvent):
                     r.handle_yield(<span class="hljs-variable language_">self</span>, task)
                 <span class="hljs-keyword">else</span>:
                     <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'unrecognized yield event'</span>)
             <span class="hljs-keyword">except</span> StopIteration:
                 <span class="hljs-variable language_">self</span>._numtasks -= <span class="hljs-number">1</span>

<span class="hljs-comment"># Example implementation of coroutine-based socket I/O</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadSocket</span>(<span class="hljs-title class_ inherited__">YieldEvent</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sock, nbytes</span>):
        <span class="hljs-variable language_">self</span>.sock = sock
        <span class="hljs-variable language_">self</span>.nbytes = nbytes
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_yield</span>(<span class="hljs-params">self, sched, task</span>):
        sched._read_wait(<span class="hljs-variable language_">self</span>.sock.fileno(), <span class="hljs-variable language_">self</span>, task)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_resume</span>(<span class="hljs-params">self, sched, task</span>):
        data = <span class="hljs-variable language_">self</span>.sock.recv(<span class="hljs-variable language_">self</span>.nbytes)
        sched.add_ready(task, data)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteSocket</span>(<span class="hljs-title class_ inherited__">YieldEvent</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sock, data</span>):
        <span class="hljs-variable language_">self</span>.sock = sock
        <span class="hljs-variable language_">self</span>.data = data
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_yield</span>(<span class="hljs-params">self, sched, task</span>):

        sched._write_wait(<span class="hljs-variable language_">self</span>.sock.fileno(), <span class="hljs-variable language_">self</span>, task)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_resume</span>(<span class="hljs-params">self, sched, task</span>):
        nsent = <span class="hljs-variable language_">self</span>.sock.send(<span class="hljs-variable language_">self</span>.data)
        sched.add_ready(task, nsent)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AcceptSocket</span>(<span class="hljs-title class_ inherited__">YieldEvent</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sock</span>):
        <span class="hljs-variable language_">self</span>.sock = sock
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_yield</span>(<span class="hljs-params">self, sched, task</span>):
        sched._read_wait(<span class="hljs-variable language_">self</span>.sock.fileno(), <span class="hljs-variable language_">self</span>, task)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_resume</span>(<span class="hljs-params">self, sched, task</span>):
        r = <span class="hljs-variable language_">self</span>.sock.accept()
        sched.add_ready(task, r)

<span class="hljs-comment"># Wrapper around a socket object for use with yield</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sock</span>):
        <span class="hljs-variable language_">self</span>._sock = sock
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">recv</span>(<span class="hljs-params">self, maxbytes</span>):
        <span class="hljs-keyword">return</span> ReadSocket(<span class="hljs-variable language_">self</span>._sock, maxbytes)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">return</span> WriteSocket(<span class="hljs-variable language_">self</span>._sock, data)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> AcceptSocket(<span class="hljs-variable language_">self</span>._sock)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>._sock, name)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM
    <span class="hljs-keyword">import</span> time

    <span class="hljs-comment"># Example of a function involving generators.  This should</span>
    <span class="hljs-comment"># be called using line = yield from readline(sock)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">readline</span>(<span class="hljs-params">sock</span>):
        chars = []
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            c = <span class="hljs-keyword">yield</span> sock.recv(<span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c:
                <span class="hljs-keyword">break</span>
            chars.append(c)
            <span class="hljs-keyword">if</span> c == <span class="hljs-string">b'\n'</span>:
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">b''</span>.join(chars)

    <span class="hljs-comment"># Echo server using generators</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span>:
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,addr,sched</span>):
            <span class="hljs-variable language_">self</span>.sched = sched
            sched.new(<span class="hljs-variable language_">self</span>.server_loop(addr))

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">server_loop</span>(<span class="hljs-params">self,addr</span>):
            s = Socket(socket(AF_INET,SOCK_STREAM))

            s.bind(addr)
            s.listen(<span class="hljs-number">5</span>)
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                c,a = <span class="hljs-keyword">yield</span> s.accept()
                <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got connection from '</span>, a)
                <span class="hljs-variable language_">self</span>.sched.new(<span class="hljs-variable language_">self</span>.client_handler(Socket(c)))

        <span class="hljs-keyword">def</span> <span class="hljs-title function_">client_handler</span>(<span class="hljs-params">self,client</span>):
            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
                line = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> readline(client)
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
                    <span class="hljs-keyword">break</span>
                line = <span class="hljs-string">b'GOT:'</span> + line
                <span class="hljs-keyword">while</span> line:
                    nsent = <span class="hljs-keyword">yield</span> client.send(line)
                    line = line[nsent:]
            client.close()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Client closed'</span>)

    sched = Scheduler()
    EchoServer((<span class="hljs-string">''</span>,<span class="hljs-number">16000</span>),sched)
    sched.run()
</code></pre>
<p>这段代码有点复杂。不过，它实现了一个小型的操作系统。 有一个就绪的任务队列，并且还有因 I/O 休眠的任务等待区域。 还有很多调度器负责在就绪队列和 I/O 等待区域之间移动任务。</p>
<h2 id="讨论">讨论</h2>
<p>在构建基于生成器的并发框架时，通常会使用更常见的 yield 形式：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">some_generator</span>():
    ...
    result = <span class="hljs-keyword">yield</span> data
    ...
</code></pre>
<p>使用这种形式的 yield 语句的函数通常被称为“协程”。 通过调度器，yield 语句在一个循环中被处理，如下：</p>
<pre><code class="lang-python">f = some_generator()

<span class="hljs-comment"># Initial result. Is None to start since nothing has been computed</span>
result = <span class="hljs-literal">None</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    <span class="hljs-keyword">try</span>:
        data = f.send(result)
        result = ... do some calculation ...
    <span class="hljs-keyword">except</span> StopIteration:
        <span class="hljs-keyword">break</span>
</code></pre>
<p>这里的逻辑稍微有点复杂。不过，被传给 <code>send()</code>的值定义了在 yield 语句醒来时的返回值。 因此，如果一个 yield 准备在对之前 yield 数据的回应中返回结果时，会在下一次 <code>send()</code> 操作返回。 如果一个生成器函数刚开始运行，发送一个 None 值会让它排在第一个 yield 语句前面。</p>
<p>除了发送值外，还可以在一个生成器上面执行一个 <code>close()</code>方法。 它会导致在执行 yield 语句时抛出一个<code>GeneratorExit</code> 异常，从而终止执行。 如果进一步设计，一个生成器可以捕获这个异常并执行清理操作。 同样还可以使用生成器的<code>throw()</code> 方法在 yield 语句执行时生成一个任意的执行指令。 一个任务调度器可利用它来在运行的生成器中处理错误。</p>
<p>最后一个例子中使用的 <code>yield from</code> 语句被用来实现协程，可以被其它生成器作为子程序或过程来调用。 本质上就是将控制权透明的传输给新的函数。 不像普通的生成器，一个使用 <code>yield from</code>被调用的函数可以返回一个作为<code>yield from</code> 语句结果的值。 关于<code>yield from</code> 的更多信息可以在 <a href="http://www.python.org/dev/peps/pep-0380" target="_blank">PEP 380</a> 中找到。</p>
<p>最后，如果使用生成器编程，要提醒你的是它还是有很多缺点的。 特别是，你得不到任何线程可以提供的好处。例如，如果你执行 CPU 依赖或 I/ O阻塞程序， 它会将整个任务挂起知道操作完成。为了解决这个问题， 你只能选择将操作委派给另外一个可以独立运行的线程或进程。 另外一个限制是大部分 Python 库并不能很好的兼容基于生成器的线程。 如果你选择这个方案，你会发现你需要自己改写很多标准库函数。 作为本节提到的协程和相关技术的一个基础背景，可以查看 <a href="http://www.python.org/dev/peps/pep-0342" target="_blank">PEP 342</a> 和<a href="http://www.dabeaz.com/coroutines" target="_blank">“协程和并发的一门有趣课程”</a></p>
<p>PEP 3156 同样有一个关于使用协程的异步 I/O 模型。 特别的，你不可能自己去实现一个底层的协程调度器。 不过，关于协程的思想是很多流行库的基础， 包括 <a href="http://www.gevent.org/" target="_blank">gevent</a>, <a href="http://pypi.python.org/pypi/greenlet" target="_blank">greenlet</a>, <a href="http://www.stackless.com/" target="_blank">Stackless Python</a> 以及其他类似工程。</p>
<h1 id="1213-多个线程队列轮询">12.13 多个线程队列轮询</h1>
<h2 id="问题">问题</h2>
<p>你有一个线程队列集合，想为到来的元素轮询它们， 就跟你为一个客户端请求去轮询一个网络连接集合的方式一样。</p>
<h2 id="解决方案">解决方案</h2>
<p>对于轮询问题的一个常见解决方案中有个很少有人知道的技巧，包含了一个隐藏的回路网络连接。 本质上讲其思想就是：对于每个你想要轮询的队列，你创建一对连接的套接字。 然后你在其中一个套接字上面编写代码来标识存在的数据， 另外一个套接字被传给 <code>select()</code> 或类似的一个轮询数据到达的函数。下面的例子演示了这个思想：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> queue
<span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> os

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PollableQueue</span>(queue.Queue):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-comment"># Create a pair of connected sockets</span>
        <span class="hljs-keyword">if</span> os.name == <span class="hljs-string">'posix'</span>:
            <span class="hljs-variable language_">self</span>._putsocket, <span class="hljs-variable language_">self</span>._getsocket = socket.socketpair()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># Compatibility on non-POSIX systems</span>
            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server.bind((<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">0</span>))
            server.listen(<span class="hljs-number">1</span>)
            <span class="hljs-variable language_">self</span>._putsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            <span class="hljs-variable language_">self</span>._putsocket.connect(server.getsockname())
            <span class="hljs-variable language_">self</span>._getsocket, _ = server.accept()
            server.close()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fileno</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._getsocket.fileno()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, item</span>):
        <span class="hljs-built_in">super</span>().put(item)
        <span class="hljs-variable language_">self</span>._putsocket.send(<span class="hljs-string">b'x'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._getsocket.recv(<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get()
</code></pre>
<p>在这个代码中，一个新的<code>Queue</code>实例类型被定义，底层是一个被连接套接字对。 在 Unix 机器上的<code>socketpair()</code>函数能轻松的创建这样的套接字。 在 Windows 上面，你必须使用类似代码来模拟它。 然后定义普通的 <code>get()</code>和<code>put()</code> 方法在这些套接字上面来执行 I/O 操作。 <code>put()</code> 方法再将数据放入队列后会写一个单字节到某个套接字中去。 而 <code>get()</code>方法在从队列中移除一个元素时会从另外一个套接字中读取到这个单字节数据。</p>
<p><code>fileno()</code> 方法使用一个函数比如 <code>select()</code> 来让这个队列可以被轮询。 它仅仅只是暴露了底层被 <code>get()</code> 函数使用到的socket的文件描述符而已。</p>
<p>下面是一个例子，定义了一个为到来的元素监控多个队列的消费者：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> select
<span class="hljs-keyword">import</span> threading

<span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">queues</span>):
    <span class="hljs-string">'''
    Consumer that reads data on multiple queues simultaneously
    '''</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        can_read, _, _ = select.select(queues,[],[])
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> can_read:
            item = r.get()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got:'</span>, item)

q1 = PollableQueue()
q2 = PollableQueue()
q3 = PollableQueue()
t = threading.Thread(target=consumer, args=([q1,q2,q3],))
t.daemon = <span class="hljs-literal">True</span>
t.start()

<span class="hljs-comment"># Feed data to the queues</span>
q1.put(<span class="hljs-number">1</span>)
q2.put(<span class="hljs-number">10</span>)
q3.put(<span class="hljs-string">'hello'</span>)
q2.put(<span class="hljs-number">15</span>)
...
</code></pre>
<p>如果你试着运行它，你会发现这个消费者会接受到所有的被放入的元素，不管元素被放进了哪个队列中。</p>
<h2 id="讨论">讨论</h2>
<p>对于轮询非类文件对象，比如队列通常都是比较棘手的问题。 例如，如果你不使用上面的套接字技术， 你唯一的选择就是编写代码来循环遍历这些队列并使用一个定时器。像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>(<span class="hljs-params">queues</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> queues:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> q.empty():
                item = q.get()
                <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got:'</span>, item)

        <span class="hljs-comment"># Sleep briefly to avoid 100% CPU</span>
        time.sleep(<span class="hljs-number">0.01</span>)
</code></pre>
<p>这样做其实不合理，还会引入其他的性能问题。 例如，如果新的数据被加入到一个队列中，至少要花10毫秒才能被发现。 如果你之前的轮询还要去轮询其他对象，比如网络套接字那还会有更多问题。 例如，如果你想同时轮询套接字和队列，你可能要像下面这样使用：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> select

<span class="hljs-keyword">def</span> <span class="hljs-title function_">event_loop</span>(<span class="hljs-params">sockets, queues</span>):
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-comment"># polling with a timeout</span>
        can_read, _, _ = select.select(sockets, [], [], <span class="hljs-number">0.01</span>)
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> can_read:
            handle_read(r)
        <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> queues:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> q.empty():
                item = q.get()
                <span class="hljs-built_in">print</span>(<span class="hljs-string">'Got:'</span>, item)
</code></pre>
<p>这个方案通过将队列和套接字等同对待来解决了大部分的问题。 一个单独的 <code>select()</code> 调用可被同时用来轮询。 使用超时或其他基于时间的机制来执行周期性检查并没有必要。 甚至，如果数据被加入到一个队列，消费者几乎可以实时的被通知。 尽管会有一点点底层的 I/O 损耗，使用它通常会获得更好的响应时间并简化编程。</p>
<h1 id="1214-在-unix-系统上面启动守护进程">12.14 在 Unix 系统上面启动守护进程</h1>
<h2 id="问题">问题</h2>
<p>你想编写一个作为一个在 Unix 或类 Unix 系统上面运行的守护进程运行的程序。</p>
<h2 id="解决方案">解决方案</h2>
<p>创建一个正确的守护进程需要一个精确的系统调用序列以及对于细节的控制。 下面的代码展示了怎样定义一个守护进程，可以启动后很容易的停止它。</p>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env python3</span>
<span class="hljs-comment"># daemon.py</span>

<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> sys

<span class="hljs-keyword">import</span> atexit
<span class="hljs-keyword">import</span> signal

<span class="hljs-keyword">def</span> <span class="hljs-title function_">daemonize</span>(<span class="hljs-params">pidfile, *, stdin=<span class="hljs-string">'/dev/null'</span>,
                          stdout=<span class="hljs-string">'/dev/null'</span>,
                          stderr=<span class="hljs-string">'/dev/null'</span></span>):

    <span class="hljs-keyword">if</span> os.path.exists(pidfile):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Already running'</span>)

    <span class="hljs-comment"># First fork (detaches from parent)</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">if</span> os.fork() &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">0</span>)   <span class="hljs-comment"># Parent exit</span>
    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'fork #1 failed.'</span>)

    os.chdir(<span class="hljs-string">'/'</span>)
    os.umask(<span class="hljs-number">0</span>)
    os.setsid()
    <span class="hljs-comment"># Second fork (relinquish session leadership)</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">if</span> os.fork() &gt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'fork #2 failed.'</span>)

    <span class="hljs-comment"># Flush I/O buffers</span>
    sys.stdout.flush()
    sys.stderr.flush()

    <span class="hljs-comment"># Replace file descriptors for stdin, stdout, and stderr</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(stdin, <span class="hljs-string">'rb'</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> f:
        os.dup2(f.fileno(), sys.stdin.fileno())
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(stdout, <span class="hljs-string">'ab'</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> f:
        os.dup2(f.fileno(), sys.stdout.fileno())
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(stderr, <span class="hljs-string">'ab'</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> f:
        os.dup2(f.fileno(), sys.stderr.fileno())

    <span class="hljs-comment"># Write the PID file</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(pidfile,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-built_in">print</span>(os.getpid(),file=f)

    <span class="hljs-comment"># Arrange to have the PID file removed on exit/signal</span>
    atexit.register(<span class="hljs-keyword">lambda</span>: os.remove(pidfile))

    <span class="hljs-comment"># Signal handler for termination (required)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sigterm_handler</span>(<span class="hljs-params">signo, frame</span>):
        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

    signal.signal(signal.SIGTERM, sigterm_handler)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():
    <span class="hljs-keyword">import</span> time
    sys.stdout.write(<span class="hljs-string">'Daemon started with pid {}\n'</span>.<span class="hljs-built_in">format</span>(os.getpid()))
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        sys.stdout.write(<span class="hljs-string">'Daemon Alive! {}\n'</span>.<span class="hljs-built_in">format</span>(time.ctime()))
        time.sleep(<span class="hljs-number">10</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    PIDFILE = <span class="hljs-string">'/tmp/daemon.pid'</span>

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">2</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Usage: {} [start|stop]'</span>.<span class="hljs-built_in">format</span>(sys.argv[<span class="hljs-number">0</span>]), file=sys.stderr)
        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

    <span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">'start'</span>:
        <span class="hljs-keyword">try</span>:
            daemonize(PIDFILE,
                      stdout=<span class="hljs-string">'/tmp/daemon.log'</span>,
                      stderr=<span class="hljs-string">'/tmp/dameon.log'</span>)
        <span class="hljs-keyword">except</span> RuntimeError <span class="hljs-keyword">as</span> e:
            <span class="hljs-built_in">print</span>(e, file=sys.stderr)
            <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

        main()

    <span class="hljs-keyword">elif</span> sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">'stop'</span>:
        <span class="hljs-keyword">if</span> os.path.exists(PIDFILE):
            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(PIDFILE) <span class="hljs-keyword">as</span> f:
                os.kill(<span class="hljs-built_in">int</span>(f.read()), signal.SIGTERM)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'Not running'</span>, file=sys.stderr)
            <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)

    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Unknown command {!r}'</span>.<span class="hljs-built_in">format</span>(sys.argv[<span class="hljs-number">1</span>]), file=sys.stderr)
        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)
</code></pre>
<p>要启动这个守护进程，用户需要使用如下的命令：</p>
<pre><code class="lang-python">bash % daemon.py start
bash % cat /tmp/daemon.pid
<span class="hljs-number">2882</span>
bash % tail -f /tmp/daemon.log
Daemon started <span class="hljs-keyword">with</span> pid <span class="hljs-number">2882</span>
Daemon Alive! Fri Oct <span class="hljs-number">12</span> <span class="hljs-number">13</span>:<span class="hljs-number">45</span>:<span class="hljs-number">37</span> <span class="hljs-number">2012</span>
Daemon Alive! Fri Oct <span class="hljs-number">12</span> <span class="hljs-number">13</span>:<span class="hljs-number">45</span>:<span class="hljs-number">47</span> <span class="hljs-number">2012</span>
...
</code></pre>
<p>守护进程可以完全在后台运行，因此这个命令会立即返回。 不过，你可以像上面那样查看与它相关的 pid 文件和日志。要停止这个守护进程，使用：</p>
<pre><code class="lang-python">bash % daemon.py stop
bash %
</code></pre>
<h2 id="讨论">讨论</h2>
<p>本节定义了一个函数 <code>daemonize()</code> ，在程序启动时被调用使得程序以一个守护进程来运行。 <code>daemonize()</code>函数只接受关键字参数，这样的话可选参数在被使用时就更清晰了。 它会强制用户像下面这样使用它：</p>
<pre><code class="lang-python">daemonize(<span class="hljs-string">'daemon.pid'</span>,
          stdin=<span class="hljs-string">'/dev/null,
          stdout='</span>/tmp/daemon.log<span class="hljs-string">',
          stderr='</span>/tmp/daemon.log<span class="hljs-string">')
</span></code></pre>
<p>而不是像下面这样含糊不清的调用：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Illegal. Must use keyword arguments</span>
daemonize(<span class="hljs-string">'daemon.pid'</span>,
          <span class="hljs-string">'/dev/null'</span>, <span class="hljs-string">'/tmp/daemon.log'</span>,<span class="hljs-string">'/tmp/daemon.log'</span>)
</code></pre>
<p>创建一个守护进程的步骤看上去不是很易懂，但是大体思想是这样的， 首先，一个守护进程必须要从父进程中脱离。 这是由 <code>os.fork()</code>操作来完成的，并立即被父进程终止。</p>
<p>在子进程变成孤儿后，调用 <code>os.setsid()</code> 创建了一个全新的进程会话，并设置子进程为首领。 它会设置这个子进程为新的进程组的首领，并确保不会再有控制终端。 如果这些听上去太魔幻，因为它需要将守护进程同终端分离开并确保信号机制对它不起作用。 调用<code>os.chdir()</code> 和<code>os.umask(0)</code> 改变了当前工作目录并重置文件权限掩码。 修改目录通常是个好主意，因为这样可以使得它不再工作在被启动时的目录。</p>
<p>另外一个调用<code>os.fork()</code> 在这里更加神秘点。 这一步使得守护进程失去了获取新的控制终端的能力并且让它更加独立 （本质上，该 daemon 放弃了它的会话首领低位，因此再也没有权限去打开控制终端了）。 尽管你可以忽略这一步，但是最好不要这么做。</p>
<p>一旦守护进程被正确的分离，它会重新初始化标准 I/O 流指向用户指定的文件。 这一部分有点难懂。跟标准 I/O 流相关的文件对象的引用在解释器中多个地方被找到 （sys.stdout, sys.<strong>stdout</strong>等）。 仅仅简单的关闭<code>sys.stdout</code> 并重新指定它是行不通的， 因为没办法知道它是否全部都是用的是<code>sys.stdout</code> 。 这里，我们打开了一个单独的文件对象，并调用 <code>os.dup2()</code> ， 用它来代替被 <code>sys.stdout</code> 使用的文件描述符。 这样，<code>sys.stdout</code>使用的原始文件会被关闭并由新的来替换。 还要强调的是任何用于文件编码或文本处理的标准 I/O 流还会保留原状。</p>
<p>守护进程的一个通常实践是在一个文件中写入进程 ID，可以被其他程序后面使用到。 <code>daemonize()</code>函数的最后部分写了这个文件，但是在程序终止时删除了它。 <code>atexit.register()</code> 函数注册了一个函数在 Python 解释器终止时执行。 一个对于 SIGTERM 的信号处理器的定义同样需要被优雅的关闭。 信号处理器简单的抛出了<code>SystemExit()</code>异常。 或许这一步看上去没必要，但是没有它， 终止信号会使得不执行 <code>atexit.register()</code>注册的清理操作的时候就杀掉了解释器。 一个杀掉进程的例子代码可以在程序最后的 <code>stop</code> 命令的操作中看到。</p>
<p>更多关于编写守护进程的信息可以查看《UNIX 环境高级编程》, 第二版 by W. Richard Stevens and Stephen A. Rago (Addison-Wesley, 2005)。 尽管它是关注与 C 语言编程，但是所有的内容都适用于 Python， 因为所有需要的 POSIX 函数都可以在标准库中找到。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="network-and-web-programming.html" class="navigation navigation-prev " aria-label="Previous page: 第十一章：网络与 Web 编程">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="scripting-and-systems-management.html" class="navigation navigation-next " aria-label="Next page: 第十三章：脚本编程与系统管理">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第十二章：并发编程","level":"1.13","depth":1,"next":{"title":"第十三章：脚本编程与系统管理","level":"1.14","depth":1,"path":"scripting-and-systems-management.md","ref":"scripting-and-systems-management.md","articles":[]},"previous":{"title":"第十一章：网络与 Web 编程","level":"1.12","depth":1,"path":"network-and-web-programming.md","ref":"network-and-web-programming.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"concurrent-programming.md","mtime":"2025-01-09T21:48:31.984Z","type":"markdown"},"gitbook":{"version":"6.0.2","time":"2025-01-11T18:48:45.487Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

