
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第十章：模块与包 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="network-and-web-programming.html" />
    
    
    <link rel="prev" href="metaprogramming.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="data-structures-and-algorithms.html">
            
                <a href="data-structures-and-algorithms.html">
            
                    
                    第一章：数据结构和算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="string-and-text.html">
            
                <a href="string-and-text.html">
            
                    
                    第二章：字符串和文本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="digital-date-and-time.html">
            
                <a href="digital-date-and-time.html">
            
                    
                    第三章：数字日期和时间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="iterators-and-generators.html">
            
                <a href="iterators-and-generators.html">
            
                    
                    第四章：迭代器与生成器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="files-and-io.html">
            
                <a href="files-and-io.html">
            
                    
                    第五章：文件与 IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="coding-and-processing-data.html">
            
                <a href="coding-and-processing-data.html">
            
                    
                    第六章：数据编码和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    第七章：函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="classes-and-objects.html">
            
                <a href="classes-and-objects.html">
            
                    
                    第八章：类与对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="metaprogramming.html">
            
                <a href="metaprogramming.html">
            
                    
                    第九章：元编程
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.11" data-path="module-and-pack.html">
            
                <a href="module-and-pack.html">
            
                    
                    第十章：模块与包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="network-and-web-programming.html">
            
                <a href="network-and-web-programming.html">
            
                    
                    第十一章：网络与 Web 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="concurrent-programming.html">
            
                <a href="concurrent-programming.html">
            
                    
                    第十二章：并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="scripting-and-systems-management.html">
            
                <a href="scripting-and-systems-management.html">
            
                    
                    第十三章：脚本编程与系统管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="testing-debugging-and-exception.html">
            
                <a href="testing-debugging-and-exception.html">
            
                    
                    第十四章：测试、调试和异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="c-language-extensions.html">
            
                <a href="c-language-extensions.html">
            
                    
                    第十五章：C 语言扩展
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第十章：模块与包</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第十章：模块与包">第十章：模块与包</h1>
<p>模块与包是任何大型程序的核心，就连 Python 安装程序本身也是一个包。本章重点涉及有关模块和包的常用编程技术，例如如何组织包、把大型模块分割成多个文件、创建命名空间包。同时，也给出了让你自定义导入语句的秘籍。</p>
<h1 id="101-构建一个模块的层级包">10.1 构建一个模块的层级包</h1>
<h2 id="问题">问题</h2>
<p>你想将你的代码组织成由很多分层模块构成的包。</p>
<h2 id="解决方案">解决方案</h2>
<p>封装成包是很简单的。在文件系统上组织你的代码，并确保每个目录都定义了一个<strong>init</strong>.py 文件。 例如：</p>
<pre><code class="lang-python">graphics/
    __init__.py
    primitive/
        __init__.py
        line.py
        fill.py
        text.py
    formats/
        __init__.py
        png.py
        jpg.py
</code></pre>
<p>一旦你做到了这一点，你应该能够执行各种 import 语句，如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> graphics.primitive.line
<span class="hljs-keyword">from</span> graphics.primitive <span class="hljs-keyword">import</span> line
<span class="hljs-keyword">import</span> graphics.formats.jpg <span class="hljs-keyword">as</span> jpg
</code></pre>
<h2 id="讨论">讨论</h2>
<p>定义模块的层次结构就像在文件系统上建立目录结构一样容易。 文件<strong>init</strong>.py 的目的是要包含不同运行级别的包的可选的初始化代码。 举个例子，如果你执行了语句 import graphics， 文件 graphics/<strong>init</strong>.py 将被导入,建立 graphics 命名空间的内容。像 import graphics.format.jpg 这样导入，文件 graphics/<strong>init</strong>.py 和文件 graphics/graphics/formats/<strong>init</strong>.py 将在文件 graphics/formats/jpg.py 导入之前导入。</p>
<p>绝大部分时候让<strong>init</strong>.py 空着就好。但是有些情况下可能包含代码。 举个例子，<strong>init</strong>.py 能够用来自动加载子模块:</p>
<pre><code class="lang-python"><span class="hljs-comment"># graphics/formats/__init__.py</span>
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> jpg
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> png
</code></pre>
<p>像这样一个文件,用户可以仅仅通过 import grahpics.formats 来代替 import graphics.formats.jpg 以及 import graphics.formats.png。</p>
<p><strong>init</strong>.py 的其他常用用法包括将多个文件合并到一个逻辑命名空间，这将在10.4小节讨论。</p>
<p>敏锐的程序员会发现，即使没有<strong>init</strong>.py 文件存在，python 仍然会导入包。如果你没有定义<strong>init</strong>.py 时，实际上创建了一个所谓的“命名空间包”，这将在10.5小节讨论。万物平等，如果你着手创建一个新的包的话，包含一个<strong>init</strong>.py 文件吧。</p>
<h1 id="102-控制模块被全部导入的内容">10.2 控制模块被全部导入的内容</h1>
<h2 id="问题">问题</h2>
<p>当使用’from module import *‘ 语句时，希望对从模块或包导出的符号进行精确控制。</p>
<h2 id="解决方案">解决方案</h2>
<p>在你的模块中定义一个变量 <strong>all</strong> 来明确地列出需要导出的内容。</p>
<p>举个例子:</p>
<pre><code class="lang-python"><span class="hljs-comment"># somemodule.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">grok</span>():
    <span class="hljs-keyword">pass</span>

blah = <span class="hljs-number">42</span>
<span class="hljs-comment"># Only export 'spam' and 'grok'</span>
__all__ = [<span class="hljs-string">'spam'</span>, <span class="hljs-string">'grok'</span>]
</code></pre>
<h2 id="讨论">讨论</h2>
<p>尽管强烈反对使用 ‘from module import *‘, 但是在定义了大量变量名的模块中频繁使用。 如果你不做任何事, 这样的导入将会导入所有不以下划线开头的。 另一方面,如果定义了 <strong>all</strong> , 那么只有被列举出的东西会被导出。</p>
<p>如果你将 <strong>all</strong> 定义成一个空列表, 没有东西将被导出。 如果 <strong>all</strong> 包含未定义的名字, 在导入时引起 AttributeError。</p>
<h1 id="103-使用相对路径名导入包中子模块">10.3 使用相对路径名导入包中子模块</h1>
<h2 id="问题">问题</h2>
<p>将代码组织成包,想用 import 语句从另一个包名没有硬编码过的包的中导入子模块。</p>
<h2 id="解决方案">解决方案</h2>
<p>使用包的相对导入，使一个的模块导入同一个包的另一个模块 举个例子，假设在你的文件系统上有 mypackage 包，组织如下：</p>
<pre><code class="lang-python">mypackage/
    __init__.py
    A/
        __init__.py
        spam.py
        grok.py
    B/
        __init__.py
        bar.py
</code></pre>
<p>如果模块 mypackage.A.spam 要导入同目录下的模块 grok，它应该包括的 import 语句如下：</p>
<pre><code class="lang-python"><span class="hljs-comment"># mypackage/A/spam.py</span>
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> grok
</code></pre>
<p>如果模块 mypackage.A.spam 要导入不同目录下的模块 B.bar，它应该使用的 import 语句如下：</p>
<pre><code class="lang-python"><span class="hljs-comment"># mypackage/A/spam.py</span>
<span class="hljs-keyword">from</span> ..B <span class="hljs-keyword">import</span> bar
</code></pre>
<p>两个 import 语句都没包含顶层包名，而是使用了 spam.py 的相对路径。</p>
<h2 id="讨论">讨论</h2>
<p>在包内，既可以使用相对路径也可以使用绝对路径来导入。 举个例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># mypackage/A/spam.py</span>
<span class="hljs-keyword">from</span> mypackage.A <span class="hljs-keyword">import</span> grok <span class="hljs-comment"># OK</span>
<span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> grok <span class="hljs-comment"># OK</span>
<span class="hljs-keyword">import</span> grok <span class="hljs-comment"># Error (not found)</span>
</code></pre>
<p>像 mypackage.A 这样使用绝对路径名的不利之处是这将顶层包名硬编码到你的源码中。如果你想重新组织它，你的代码将更脆，很难工作。 举个例子，如果你改变了包名，你就必须检查所有文件来修正源码。 同样，硬编码的名称会使移动代码变得困难。举个例子，也许有人想安装两个不同版本的软件包，只通过名称区分它们。 如果使用相对导入，那一切都 ok，然而使用绝对路径名很可能会出问题。</p>
<p>import 语句的 . 和 <code>..</code>看起来很滑稽, 但它指定目录名.为当前目录，..B 为目录../B。这种语法只适用于 import。 举个例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> grok <span class="hljs-comment"># OK</span>
<span class="hljs-keyword">import</span> .grok <span class="hljs-comment"># ERROR</span>
</code></pre>
<p>尽管使用相对导入看起来像是浏览文件系统，但是不能到定义包的目录之外。也就是说，使用点的这种模式从不是包的目录中导入将会引发错误。</p>
<p>最后，相对导入只适用于在合适的包中的模块。尤其是在顶层的脚本的简单模块中，它们将不起作用。如果包的部分被作为脚本直接执行，那它们将不起作用 例如：</p>
<pre><code class="lang-python">% python3 mypackage/A/spam.py <span class="hljs-comment"># Relative imports fail</span>
</code></pre>
<p>另一方面，如果你使用 Python 的-m 选项来执行先前的脚本，相对导入将会正确运行。 例如：</p>
<pre><code class="lang-python">% python3 -m mypackage.A.spam <span class="hljs-comment"># Relative imports work</span>
</code></pre>
<p>更多的包的相对导入的背景知识,请看 <a href="http://www.python.org/dev/peps/pep-0328" target="_blank">PEP 328</a> .</p>
<h1 id="104-将模块分割成多个文件">10.4 将模块分割成多个文件</h1>
<h2 id="问题">问题</h2>
<p>你想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。</p>
<h2 id="解决方案">解决方案</h2>
<p>程序模块可以通过变成包来分割成多个独立的文件。考虑下下面简单的模块：</p>
<pre><code class="lang-python"><span class="hljs-comment"># mymodule.py</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.spam'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.bar'</span>)
</code></pre>
<p>假设你想 mymodule.py 分为两个文件，每个定义的一个类。要做到这一点，首先用 mymodule 目录来替换文件 mymodule.py。 这这个目录下，创建以下文件：</p>
<pre><code class="lang-python">mymodule/
    __init__.py
    a.py
    b.py
</code></pre>
<p>在 a.py 文件中插入以下代码：</p>
<pre><code class="lang-python"><span class="hljs-comment"># a.py</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.spam'</span>)
</code></pre>
<p>在 b.py 文件中插入以下代码：</p>
<pre><code class="lang-python"><span class="hljs-comment"># b.py</span>
<span class="hljs-keyword">from</span> .a <span class="hljs-keyword">import</span> A
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.bar'</span>)
</code></pre>
<p>最后，在 <strong>init</strong>.py 中，将2个文件粘合在一起：</p>
<pre><code class="lang-python"><span class="hljs-comment"># __init__.py</span>
<span class="hljs-keyword">from</span> .a <span class="hljs-keyword">import</span> A
<span class="hljs-keyword">from</span> .b <span class="hljs-keyword">import</span> B
</code></pre>
<p>如果按照这些步骤，所产生的包 MyModule 将作为一个单一的逻辑模块：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> mymodule
<span class="hljs-meta">&gt;&gt;&gt; </span>a = mymodule.A()
<span class="hljs-meta">&gt;&gt;&gt; </span>a.spam()
A.spam
<span class="hljs-meta">&gt;&gt;&gt; </span>b = mymodule.B()
<span class="hljs-meta">&gt;&gt;&gt; </span>b.bar()
B.bar
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>在这个章节中的主要问题是一个设计问题，不管你是否希望用户使用很多小模块或只是一个模块。举个例子，在一个大型的代码库中，你可以将这一切都分割成独立的文件，让用户使用大量的 import 语句，就像这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> mymodule.a <span class="hljs-keyword">import</span> A
<span class="hljs-keyword">from</span> mymodule.b <span class="hljs-keyword">import</span> B
...
</code></pre>
<p>这样能工作，但这让用户承受更多的负担，用户要知道不同的部分位于何处。通常情况下，将这些统一起来，使用一条 import 将更加容易，就像这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> mymodule <span class="hljs-keyword">import</span> A, B
</code></pre>
<p>对后者而言，让 mymodule 成为一个大的源文件是最常见的。但是，这一章节展示了如何合并多个文件合并成一个单一的逻辑命名空间。 这样做的关键是创建一个包目录，使用 <strong>init</strong>.py 文件来将每部分粘合在一起。</p>
<p>当一个模块被分割，你需要特别注意交叉引用的文件名。举个例子，在这一章节中，B类需要访问A类作为基类。用包的相对导入 from .a import A 来获取。</p>
<p>整个章节都使用包的相对导入来避免将顶层模块名硬编码到源代码中。这使得重命名模块或者将它移动到别的位置更容易。（见10.3小节）</p>
<p>作为这一章节的延伸，将介绍延迟导入。如图所示，<strong>init</strong>.py 文件一次导入所有必需的组件的。但是对于一个很大的模块，可能你只想组件在需要时被加载。 要做到这一点，<strong>init</strong>.py 有细微的变化：</p>
<pre><code class="lang-python"><span class="hljs-comment"># __init__.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">A</span>():
    <span class="hljs-keyword">from</span> .a <span class="hljs-keyword">import</span> A
    <span class="hljs-keyword">return</span> A()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">B</span>():
    <span class="hljs-keyword">from</span> .b <span class="hljs-keyword">import</span> B
    <span class="hljs-keyword">return</span> B()
</code></pre>
<p>在这个版本中，类 A 和类 B 被替换为在第一次访问时加载所需的类的函数。对于用户，这看起来不会有太大的不同。 例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> mymodule
<span class="hljs-meta">&gt;&gt;&gt; </span>a = mymodule.A()
<span class="hljs-meta">&gt;&gt;&gt; </span>a.spam()
A.spam
&gt;&gt;&gt;
</code></pre>
<p>延迟加载的主要缺点是继承和类型检查可能会中断。你可能会稍微改变你的代码，例如:</p>
<pre><code class="lang-python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, mymodule.A): <span class="hljs-comment"># Error</span>
...

<span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, mymodule.a.A): <span class="hljs-comment"># Ok</span>
...
</code></pre>
<p>延迟加载的真实例子, 见标准库 multiprocessing/<strong>init</strong>.py 的源码.</p>
<h1 id="105-利用命名空间导入目录分散的代码">10.5 利用命名空间导入目录分散的代码</h1>
<h2 id="问题">问题</h2>
<p>你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作为独立的包来安装。</p>
<h2 id="解决方案">解决方案</h2>
<p>从本质上讲，你要定义一个顶级 Python 包，作为一个大集合分开维护子包的命名空间。这个问题经常出现在大的应用框架中，框架开发者希望鼓励用户发布插件或附加包。</p>
<p>在统一不同的目录里统一相同的命名空间，但是要删去用来将组件联合起来的<strong>init</strong>.py 文件。假设你有 Python 代码的两个不同的目录如下：</p>
<pre><code class="lang-python">foo-package/
    spam/
        blah.py

bar-package/
    spam/
        grok.py
</code></pre>
<p>在这2个目录里，都有着共同的命名空间 spam。在任何一个目录里都没有<strong>init</strong>.py 文件。</p>
<p>让我们看看，如果将 foo-package 和 bar-package 都加到 python 模块路径并尝试导入会发生什么</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.extend([<span class="hljs-string">'foo-package'</span>, <span class="hljs-string">'bar-package'</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.blah
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.grok
&gt;&gt;&gt;
</code></pre>
<p>两个不同的包目录被合并到一起，你可以导入 spam.blah 和 spam.grok，并且它们能够工作。</p>
<h2 id="讨论">讨论</h2>
<p>在这里工作的机制被称为“包命名空间”的一个特征。从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p>
<p>包命名空间的关键是确保顶级目录中没有<strong>init</strong>.py 文件来作为共同的命名空间。缺失<strong>init</strong>.py 文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其<strong>path</strong>变量中。 举个例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam
<span class="hljs-meta">&gt;&gt;&gt; </span>spam.__path__
_NamespacePath([<span class="hljs-string">'foo-package/spam'</span>, <span class="hljs-string">'bar-package/spam'</span>])
&gt;&gt;&gt;
</code></pre>
<p>在定位包的子组件时，目录<strong>path</strong>将被用到(例如, 当导入 spam.grok 或者 spam.blah 的时候).</p>
<p>包命名空间的一个重要特点是任何人都可以用自己的代码来扩展命名空间。举个例子，假设你自己的代码目录像这样：</p>
<pre><code class="lang-python">my-package/
    spam/
        custom.py
</code></pre>
<p>如果你将你的代码目录和其他包一起添加到 sys.path，这将无缝地合并到别的 spam 包目录中：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.custom
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.grok
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.blah
&gt;&gt;&gt;
</code></pre>
<p>一个包是否被作为一个包命名空间的主要方法是检查其<strong>file</strong>属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的“namespace”这个词体现出来。</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>spam.__file__
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
AttributeError: <span class="hljs-string">'module'</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">'__file__'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>spam
&lt;module <span class="hljs-string">'spam'</span> (namespace)&gt;
&gt;&gt;&gt;
</code></pre>
<p>更多的包命名空间信息可以查看 <a href="https://www.python.org/dev/peps/pep-0420/" target="_blank">PEP 420</a>.</p>
<h1 id="106-重新加载模块">10.6 重新加载模块</h1>
<h2 id="问题">问题</h2>
<p>你想重新加载已经加载的模块，因为你对其源码进行了修改。</p>
<h2 id="解决方案">解决方案</h2>
<p>使用 imp.reload()来重新加载先前加载的模块。举个例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> imp
<span class="hljs-meta">&gt;&gt;&gt; </span>imp.reload(spam)
&lt;module <span class="hljs-string">'spam'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./spam.py'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>重新加载模块在开发和调试过程中常常很有用。但在生产环境中的代码使用会不安全，因为它并不总是像您期望的那样工作。</p>
<p>reload()擦除了模块底层字典的内容，并通过重新执行模块的源代码来刷新它。模块对象本身的身份保持不变。因此，该操作在程序中所有已经被导入了的地方更新了模块。</p>
<p>尽管如此，reload()没有更新像”from module import name”这样使用 import 语句导入的定义。举个例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># spam.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'bar'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">grok</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'grok'</span>)
</code></pre>
<p>现在启动交互式会话：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> spam <span class="hljs-keyword">import</span> grok
<span class="hljs-meta">&gt;&gt;&gt; </span>spam.bar()
bar
<span class="hljs-meta">&gt;&gt;&gt; </span>grok()
grok
&gt;&gt;&gt;
</code></pre>
<p>不退出 Python 修改 spam.py 的源码，将 grok()函数改成这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">grok</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'New grok'</span>)
</code></pre>
<p>现在回到交互式会话，重新加载模块，尝试下这个实验：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> imp
<span class="hljs-meta">&gt;&gt;&gt; </span>imp.reload(spam)
&lt;module <span class="hljs-string">'spam'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./spam.py'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>spam.bar()
bar
<span class="hljs-meta">&gt;&gt;&gt; </span>grok() <span class="hljs-comment"># Notice old output</span>
grok
<span class="hljs-meta">&gt;&gt;&gt; </span>spam.grok() <span class="hljs-comment"># Notice new output</span>
New grok
&gt;&gt;&gt;
</code></pre>
<p>在这个例子中，你看到有2个版本的 grok()函数被加载。通常来说，这不是你想要的，而是令人头疼的事。</p>
<p>因此，在生产环境中可能需要避免重新加载模块。在交互环境下调试，解释程序并试图弄懂它。</p>
<h1 id="107-运行目录或压缩文件">10.7 运行目录或压缩文件</h1>
<h2 id="问题">问题</h2>
<p>您有已经一个复杂的脚本到涉及多个文件的应用程序。你想有一些简单的方法让用户运行程序。</p>
<h2 id="解决方案">解决方案</h2>
<p>如果你的应用程序已经有多个文件，你可以把你的应用程序放进它自己的目录并添加一个<strong>main</strong>.py 文件。 举个例子，你可以像这样创建目录：</p>
<pre><code class="lang-python">myapplication/
    spam.py
    bar.py
    grok.py
    __main__.py
</code></pre>
<p>如果<strong>main</strong>.py 存在，你可以简单地在顶级目录运行 Python 解释器：</p>
<pre><code class="lang-python">bash % python3 myapplication
</code></pre>
<p>解释器将执行<strong>main</strong>.py 文件作为主程序。</p>
<p>如果你将你的代码打包成 zip 文件，这种技术同样也适用，举个例子：</p>
<pre><code class="lang-python">bash % ls
spam.py bar.py grok.py __main__.py
bash % <span class="hljs-built_in">zip</span> -r myapp.<span class="hljs-built_in">zip</span> *.py
bash % python3 myapp.<span class="hljs-built_in">zip</span>
<span class="hljs-meta">... </span>output <span class="hljs-keyword">from</span> __main__.py ...
</code></pre>
<h2 id="讨论">讨论</h2>
<p>创建一个目录或 zip 文件并添加<strong>main</strong>.py 文件来将一个更大的 Python 应用打包是可行的。这和作为标准库被安装到 Python 库的代码包是有一点区别的。相反，这只是让别人执行的代码包。</p>
<p>由于目录和 zip 文件与正常文件有一点不同，你可能还需要增加一个 shell 脚本，使执行更加容易。例如，如果代码文件名为 myapp.zip，你可以创建这样一个顶级脚本：</p>
<pre><code class="lang-python"><span class="hljs-comment">#!/usr/bin/env python3 /usr/local/bin/myapp.zip</span>
</code></pre>
<h1 id="108-读取位于包中的数据文件">10.8 读取位于包中的数据文件</h1>
<h2 id="问题">问题</h2>
<p>你的包中包含代码需要去读取的数据文件。你需要尽可能地用最便捷的方式来做这件事。</p>
<h2 id="解决方案">解决方案</h2>
<p>假设你的包中的文件组织成如下：</p>
<pre><code class="lang-python">mypackage/
    __init__.py
    somedata.dat
    spam.py
</code></pre>
<p>现在假设 spam.py 文件需要读取 somedata.dat 文件中的内容。你可以用以下代码来完成：</p>
<pre><code class="lang-python"><span class="hljs-comment"># spam.py</span>
<span class="hljs-keyword">import</span> pkgutil
data = pkgutil.get_data(__package__, <span class="hljs-string">'somedata.dat'</span>)
</code></pre>
<p>由此产生的变量是包含该文件的原始内容的字节字符串。</p>
<h2 id="讨论">讨论</h2>
<p>要读取数据文件，你可能会倾向于编写使用内置的 I/O 功能的代码，如 open()。但是这种方法也有一些问题。</p>
<p>首先，一个包对解释器的当前工作目录几乎没有控制权。因此，编程时任何 I/O 操作都必须使用绝对文件名。由于每个模块包含有完整路径的<strong>file</strong>变量，这弄清楚它的路径不是不可能，但它很凌乱。</p>
<p>第二，包通常安装作为.zip 或.egg 文件，这些文件像文件系统上的一个普通目录一样不会被保留。因此，你试图用 open()对一个包含数据文件的归档文件进行操作，它根本不会工作。</p>
<p>pkgutil.get_data()函数是一个读取数据文件的高级工具，不用管包是如何安装以及安装在哪。它只是工作并将文件内容以字节字符串返回给你</p>
<p>get<em>data()的第一个参数是包含包名的字符串。你可以直接使用包名，也可以使用特殊的变量，比如<em>_package</em></em>。第二个参数是包内文件的相对名称。如果有必要，可以使用标准的 Unix 命名规范到不同的目录，只有最后的目录仍然位于包中。</p>
<h1 id="109-将文件夹加入到-syspath">10.9 将文件夹加入到 sys.path</h1>
<h2 id="问题">问题</h2>
<p>你无法导入你的 Python 代码因为它所在的目录不在 sys.path 里。你想将添加新目录到 Python 路径，但是不想硬链接到你的代码。</p>
<h2 id="解决方案">解决方案</h2>
<p>有两种常用的方式将新目录添加到 sys.path。第一种，你可以使用 PYTHONPATH 环境变量来添加。例如：</p>
<pre><code class="lang-python">bash % env PYTHONPATH=/some/<span class="hljs-built_in">dir</span>:/other/<span class="hljs-built_in">dir</span> python3
Python <span class="hljs-number">3.3</span><span class="hljs-number">.0</span> (default, Oct <span class="hljs-number">4</span> <span class="hljs-number">2012</span>, <span class="hljs-number">10</span>:<span class="hljs-number">17</span>:<span class="hljs-number">33</span>)
[GCC <span class="hljs-number">4.2</span><span class="hljs-number">.1</span> (Apple Inc. build <span class="hljs-number">5666</span>) (dot <span class="hljs-number">3</span>)] on darwin
<span class="hljs-type">Type</span> <span class="hljs-string">"help"</span>, <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path
[<span class="hljs-string">''</span>, <span class="hljs-string">'/some/dir'</span>, <span class="hljs-string">'/other/dir'</span>, ...]
&gt;&gt;&gt;
</code></pre>
<p>在自定义应用程序中，这样的环境变量可在程序启动时设置或通过 shell 脚本。</p>
<p>第二种方法是创建一个.pth 文件，将目录列举出来，像这样：</p>
<pre><code class="lang-python"><span class="hljs-comment"># myapplication.pth</span>
/some/<span class="hljs-built_in">dir</span>
/other/<span class="hljs-built_in">dir</span>
</code></pre>
<p>这个.pth 文件需要放在某个 Python 的 site-packages 目录，通常位于/usr/local/lib/python3.3/site-packages 或者 ~/.local/lib/python3.3/sitepackages。当解释器启动时，.pth 文件里列举出来的存在于文件系统的目录将被添加到 sys.path。安装一个.pth 文件可能需要管理员权限，如果它被添加到系统级的 Python 解释器。</p>
<h2 id="讨论">讨论</h2>
<p>比起费力地找文件，你可能会倾向于写一个代码手动调节 sys.path 的值。例如:</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> sys
sys.path.insert(<span class="hljs-number">0</span>, <span class="hljs-string">'/some/dir'</span>)
sys.path.insert(<span class="hljs-number">0</span>, <span class="hljs-string">'/other/dir'</span>)
</code></pre>
<p>虽然这能“工作”，它是在实践中极为脆弱，应尽量避免使用。这种方法的问题是，它将目录名硬编码到了你的源。如果你的代码被移到一个新的位置，这会导致维护问题。更好的做法是在不修改源代码的情况下，将path配置到其他地方。如果您使用模块级的变量来精心构造一个适当的绝对路径，有时你可以解决硬编码目录的问题，比如<strong>file</strong>。举个例子：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> os.path <span class="hljs-keyword">import</span> abspath, join, dirname
sys.path.insert(<span class="hljs-number">0</span>, abspath(dirname(<span class="hljs-string">'__file__'</span>), <span class="hljs-string">'src'</span>))
</code></pre>
<p>这将 src 目录添加到 path 里，和执行插入步骤的代码在同一个目录里。</p>
<p>site-packages 目录是第三方包和模块安装的目录。如果你手动安装你的代码，它将被安装到 site-packages 目录。虽然.pth 文件配置的 path 必须出现在 site-packages 里，但代码可以在系统上任何你想要的目录。因此，你可以把你的代码放在一系列不同的目录，只要那些目录包含在.pth 文件里。</p>
<h1 id="1010-通过字符串名导入模块">10.10 通过字符串名导入模块</h1>
<h2 id="问题">问题</h2>
<p>你想导入一个模块，但是模块的名字在字符串里。你想对字符串调用导入命令。</p>
<h2 id="解决方案">解决方案</h2>
<p>使用 importlib.import_module()函数来手动导入名字为字符串给出的一个模块或者包的一部分。举个例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> importlib
<span class="hljs-meta">&gt;&gt;&gt; </span>math = importlib.import_module(<span class="hljs-string">'math'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>math.sin(<span class="hljs-number">2</span>)
<span class="hljs-number">0.9092974268256817</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mod = importlib.import_module(<span class="hljs-string">'urllib.request'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>u = mod.urlopen(<span class="hljs-string">'http://www.python.org'</span>)
&gt;&gt;&gt;
</code></pre>
<p>import_module 只是简单地执行和 import 相同的步骤，但是返回生成的模块对象。你只需要将其存储在一个变量，然后像正常的模块一样使用。</p>
<p>如果你正在使用的包，import_module()也可用于相对导入。但是，你需要给它一个额外的参数。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> importlib
<span class="hljs-comment"># Same as 'from . import b'</span>
b = importlib.import_module(<span class="hljs-string">'.b'</span>, __package__)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>使用 import_module()手动导入模块的问题通常出现在以某种方式编写修改或覆盖模块的代码时候。例如，也许你正在执行某种自定义导入机制，需要通过名称来加载一个模块，通过补丁加载代码。</p>
<p>在旧的代码，有时你会看到用于导入的内建函数<strong>import</strong>()。尽管它能工作，但是 importlib.import_module() 通常更容易使用。</p>
<p>自定义导入过程的高级实例见10.11小节</p>
<h1 id="1011-通过钩子远程加载模块">10.11 通过钩子远程加载模块</h1>
<h2 id="问题">问题</h2>
<p>你想自定义 Python 的 import 语句，使得它能从远程机器上面透明的加载模块。</p>
<h2 id="解决方案">解决方案</h2>
<p>首先要提出来的是安全问题。本届讨论的思想如果没有一些额外的安全和认知机制的话会很糟糕。 也就是说，我们的主要目的是深入分析 Python 的 import 语句机制。 如果你理解了本节内部原理，你就能够为其他任何目的而自定义 import。 有了这些，让我们继续向前走。</p>
<p>本节核心是设计导入语句的扩展功能。有很多种方法可以做这个， 不过为了演示的方便，我们开始先构造下面这个 Python 代码结构：</p>
<pre><code class="lang-python">testcode/
    spam.py
    fib.py
    grok/
        __init__.py
        blah.py
</code></pre>
<p>这些文件的内容并不重要，不过我们在每个文件中放入了少量的简单语句和函数， 这样你可以测试它们并查看当它们被导入时的输出。例如：</p>
<pre><code class="lang-python"><span class="hljs-comment"># spam.py</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I'm spam"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Hello %s'</span> % name)

<span class="hljs-comment"># fib.py</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I'm fib"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)

<span class="hljs-comment"># grok/__init__.py</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I'm grok.__init__"</span>)

<span class="hljs-comment"># grok/blah.py</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I'm grok.blah"</span>)
</code></pre>
<p>这里的目的是允许这些文件作为模块被远程访问。 也许最简单的方式就是将它们发布到一个 web 服务器上面。在 testcode 目录中像下面这样运行 Python：</p>
<pre><code class="lang-python">bash % cd testcode
bash % python3 -m http.server <span class="hljs-number">15000</span>
Serving HTTP on <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> port <span class="hljs-number">15000</span> ...
</code></pre>
<p>服务器运行起来后再启动一个单独的 Python 解释器。 确保你可以使用 <code>urllib</code>访问到远程文件。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen
<span class="hljs-meta">&gt;&gt;&gt; </span>u = urlopen(<span class="hljs-string">'http://localhost:15000/fib.py'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>data = u.read().decode(<span class="hljs-string">'utf-8'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(data)
<span class="hljs-comment"># fib.py</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I'm fib"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)
&gt;&gt;&gt;
</code></pre>
<p>从这个服务器加载源代码是接下来本节的基础。 为了替代手动的通过 <code>urlopen()</code> 来收集源文件， 我们通过自定义 import 语句来在后台自动帮我们做到。</p>
<p>加载远程模块的第一种方法是创建一个显示的加载函数来完成它。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> imp
<span class="hljs-keyword">import</span> urllib.request
<span class="hljs-keyword">import</span> sys

<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_module</span>(<span class="hljs-params">url</span>):
    u = urllib.request.urlopen(url)
    source = u.read().decode(<span class="hljs-string">'utf-8'</span>)
    mod = sys.modules.setdefault(url, imp.new_module(url))
    code = <span class="hljs-built_in">compile</span>(source, url, <span class="hljs-string">'exec'</span>)
    mod.__file__ = url
    mod.__package__ = <span class="hljs-string">''</span>
    <span class="hljs-built_in">exec</span>(code, mod.__dict__)
    <span class="hljs-keyword">return</span> mod
</code></pre>
<p>这个函数会下载源代码，并使用 <code>compile()</code> 将其编译到一个代码对象中， 然后在一个新创建的模块对象的字典中来执行它。下面是使用这个函数的方式：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>fib = load_module(<span class="hljs-string">'http://localhost:15000/fib.py'</span>)
I<span class="hljs-string">'m fib
&gt;&gt;&gt; fib.fib(10)
89
&gt;&gt;&gt; spam = load_module('</span>http://localhost:<span class="hljs-number">15000</span>/spam.py<span class="hljs-string">')
I'</span>m spam
<span class="hljs-meta">&gt;&gt;&gt; </span>spam.hello(<span class="hljs-string">'Guido'</span>)
Hello Guido
<span class="hljs-meta">&gt;&gt;&gt; </span>fib
&lt;module <span class="hljs-string">'http://localhost:15000/fib.py'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'http://localhost:15000/fib.py'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>spam
&lt;module <span class="hljs-string">'http://localhost:15000/spam.py'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'http://localhost:15000/spam.py'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>正如你所见，对于简单的模块这个是行得通的。 不过它并没有嵌入到通常的 import 语句中，如果要支持更高级的结构比如包就需要更多的工作了。</p>
<p>一个更酷的做法是创建一个自定义导入器。第一种方法是创建一个元路径导入器。如下：</p>
<pre><code class="lang-python"><span class="hljs-comment"># urlimport.py</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> importlib.abc
<span class="hljs-keyword">import</span> imp
<span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen
<span class="hljs-keyword">from</span> urllib.error <span class="hljs-keyword">import</span> HTTPError, URLError
<span class="hljs-keyword">from</span> html.parser <span class="hljs-keyword">import</span> HTMLParser

<span class="hljs-comment"># Debugging</span>
<span class="hljs-keyword">import</span> logging
log = logging.getLogger(__name__)

<span class="hljs-comment"># Get links from a given URL</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_links</span>(<span class="hljs-params">url</span>):
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkParser</span>(<span class="hljs-title class_ inherited__">HTMLParser</span>):
        <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_starttag</span>(<span class="hljs-params">self, tag, attrs</span>):
            <span class="hljs-keyword">if</span> tag == <span class="hljs-string">'a'</span>:
                attrs = <span class="hljs-built_in">dict</span>(attrs)
                links.add(attrs.get(<span class="hljs-string">'href'</span>).rstrip(<span class="hljs-string">'/'</span>))
    links = <span class="hljs-built_in">set</span>()
    <span class="hljs-keyword">try</span>:
        log.debug(<span class="hljs-string">'Getting links from %s'</span> % url)
        u = urlopen(url)
        parser = LinkParser()
        parser.feed(u.read().decode(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        log.debug(<span class="hljs-string">'Could not get links. %s'</span>, e)
    log.debug(<span class="hljs-string">'links: %r'</span>, links)
    <span class="hljs-keyword">return</span> links

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaFinder</span>(importlib.abc.MetaPathFinder):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):
        <span class="hljs-variable language_">self</span>._baseurl = baseurl
        <span class="hljs-variable language_">self</span>._links = { }
        <span class="hljs-variable language_">self</span>._loaders = { baseurl : UrlModuleLoader(baseurl) }

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_module</span>(<span class="hljs-params">self, fullname, path=<span class="hljs-literal">None</span></span>):
        log.debug(<span class="hljs-string">'find_module: fullname=%r, path=%r'</span>, fullname, path)
        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            baseurl = <span class="hljs-variable language_">self</span>._baseurl
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path[<span class="hljs-number">0</span>].startswith(<span class="hljs-variable language_">self</span>._baseurl):
                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
            baseurl = path[<span class="hljs-number">0</span>]
        parts = fullname.split(<span class="hljs-string">'.'</span>)
        basename = parts[-<span class="hljs-number">1</span>]
        log.debug(<span class="hljs-string">'find_module: baseurl=%r, basename=%r'</span>, baseurl, basename)

        <span class="hljs-comment"># Check link cache</span>
        <span class="hljs-keyword">if</span> basename <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._links:
            <span class="hljs-variable language_">self</span>._links[baseurl] = _get_links(baseurl)

        <span class="hljs-comment"># Check if it's a package</span>
        <span class="hljs-keyword">if</span> basename <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._links[baseurl]:
            log.debug(<span class="hljs-string">'find_module: trying package %r'</span>, fullname)
            fullurl = <span class="hljs-variable language_">self</span>._baseurl + <span class="hljs-string">'/'</span> + basename
            <span class="hljs-comment"># Attempt to load the package (which accesses __init__.py)</span>
            loader = UrlPackageLoader(fullurl)
            <span class="hljs-keyword">try</span>:
                loader.load_module(fullname)
                <span class="hljs-variable language_">self</span>._links[fullurl] = _get_links(fullurl)
                <span class="hljs-variable language_">self</span>._loaders[fullurl] = UrlModuleLoader(fullurl)
                log.debug(<span class="hljs-string">'find_module: package %r loaded'</span>, fullname)
            <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> e:
                log.debug(<span class="hljs-string">'find_module: package failed. %s'</span>, e)
                loader = <span class="hljs-literal">None</span>
            <span class="hljs-keyword">return</span> loader
        <span class="hljs-comment"># A normal module</span>
        filename = basename + <span class="hljs-string">'.py'</span>
        <span class="hljs-keyword">if</span> filename <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._links[baseurl]:
            log.debug(<span class="hljs-string">'find_module: module %r found'</span>, fullname)
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._loaders[baseurl]
        <span class="hljs-keyword">else</span>:
            log.debug(<span class="hljs-string">'find_module: module %r not found'</span>, fullname)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invalidate_caches</span>(<span class="hljs-params">self</span>):
        log.debug(<span class="hljs-string">'invalidating link cache'</span>)
        <span class="hljs-variable language_">self</span>._links.clear()

<span class="hljs-comment"># Module Loader for a URL</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlModuleLoader</span>(importlib.abc.SourceLoader):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):
        <span class="hljs-variable language_">self</span>._baseurl = baseurl
        <span class="hljs-variable language_">self</span>._source_cache = {}

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">module_repr</span>(<span class="hljs-params">self, module</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;urlmodule %r from %r&gt;'</span> % (module.__name__, module.__file__)

    <span class="hljs-comment"># Required method</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_module</span>(<span class="hljs-params">self, fullname</span>):
        code = <span class="hljs-variable language_">self</span>.get_code(fullname)
        mod = sys.modules.setdefault(fullname, imp.new_module(fullname))
        mod.__file__ = <span class="hljs-variable language_">self</span>.get_filename(fullname)
        mod.__loader__ = <span class="hljs-variable language_">self</span>
        mod.__package__ = fullname.rpartition(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>]
        <span class="hljs-built_in">exec</span>(code, mod.__dict__)
        <span class="hljs-keyword">return</span> mod

    <span class="hljs-comment"># Optional extensions</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_code</span>(<span class="hljs-params">self, fullname</span>):
        src = <span class="hljs-variable language_">self</span>.get_source(fullname)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compile</span>(src, <span class="hljs-variable language_">self</span>.get_filename(fullname), <span class="hljs-string">'exec'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">self, path</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_filename</span>(<span class="hljs-params">self, fullname</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._baseurl + <span class="hljs-string">'/'</span> + fullname.split(<span class="hljs-string">'.'</span>)[-<span class="hljs-number">1</span>] + <span class="hljs-string">'.py'</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_source</span>(<span class="hljs-params">self, fullname</span>):
        filename = <span class="hljs-variable language_">self</span>.get_filename(fullname)
        log.debug(<span class="hljs-string">'loader: reading %r'</span>, filename)
        <span class="hljs-keyword">if</span> filename <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._source_cache:
            log.debug(<span class="hljs-string">'loader: cached %r'</span>, filename)
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._source_cache[filename]
        <span class="hljs-keyword">try</span>:
            u = urlopen(filename)
            source = u.read().decode(<span class="hljs-string">'utf-8'</span>)
            log.debug(<span class="hljs-string">'loader: %r loaded'</span>, filename)
            <span class="hljs-variable language_">self</span>._source_cache[filename] = source
            <span class="hljs-keyword">return</span> source
        <span class="hljs-keyword">except</span> (HTTPError, URLError) <span class="hljs-keyword">as</span> e:
            log.debug(<span class="hljs-string">'loader: %r failed. %s'</span>, filename, e)
            <span class="hljs-keyword">raise</span> ImportError(<span class="hljs-string">"Can't load %s"</span> % filename)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_package</span>(<span class="hljs-params">self, fullname</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-comment"># Package loader for a URL</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlPackageLoader</span>(<span class="hljs-title class_ inherited__">UrlModuleLoader</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_module</span>(<span class="hljs-params">self, fullname</span>):
        mod = <span class="hljs-built_in">super</span>().load_module(fullname)
        mod.__path__ = [ <span class="hljs-variable language_">self</span>._baseurl ]
        mod.__package__ = fullname

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_filename</span>(<span class="hljs-params">self, fullname</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._baseurl + <span class="hljs-string">'/'</span> + <span class="hljs-string">'__init__.py'</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_package</span>(<span class="hljs-params">self, fullname</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

<span class="hljs-comment"># Utility functions for installing/uninstalling the loader</span>
_installed_meta_cache = { }
<span class="hljs-keyword">def</span> <span class="hljs-title function_">install_meta</span>(<span class="hljs-params">address</span>):
    <span class="hljs-keyword">if</span> address <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _installed_meta_cache:
        finder = UrlMetaFinder(address)
        _installed_meta_cache[address] = finder
        sys.meta_path.append(finder)
        log.debug(<span class="hljs-string">'%r installed on sys.meta_path'</span>, finder)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_meta</span>(<span class="hljs-params">address</span>):
    <span class="hljs-keyword">if</span> address <span class="hljs-keyword">in</span> _installed_meta_cache:
        finder = _installed_meta_cache.pop(address)
        sys.meta_path.remove(finder)
        log.debug(<span class="hljs-string">'%r removed from sys.meta_path'</span>, finder)
</code></pre>
<p>下面是一个交互会话，演示了如何使用前面的代码：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># importing currently fails</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
Traceback (most recent call last):
File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'fib'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Load the importer and retry (it works)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> urlimport
<span class="hljs-meta">&gt;&gt;&gt; </span>urlimport.install_meta(<span class="hljs-string">'http://localhost:15000'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
I<span class="hljs-string">'m fib
&gt;&gt;&gt; import spam
I'</span>m spam
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> grok.blah
I<span class="hljs-string">'m grok.__init__
I'</span>m grok.blah
<span class="hljs-meta">&gt;&gt;&gt; </span>grok.blah.__file__
<span class="hljs-string">'http://localhost:15000/grok/blah.py'</span>
&gt;&gt;&gt;
</code></pre>
<p>这个特殊的方案会安装一个特别的查找器 <code>UrlMetaFinder</code> 实例， 作为 <code>sys.meta_path</code>中最后的实体。 当模块被导入时，会依据 <code>sys.meta_path</code> 中的查找器定位模块。 在这个例子中，<code>UrlMetaFinder</code>实例是最后一个查找器方案， 当模块在任何一个普通地方都找不到的时候就触发它。</p>
<p>作为常见的实现方案，<code>UrlMetaFinder</code> 类包装在一个用户指定的URL上。 在内部，查找器通过抓取指定URL的内容构建合法的链接集合。 导入的时候，模块名会跟已有的链接作对比。如果找到了一个匹配的， 一个单独的 <code>UrlModuleLoader</code> 类被用来从远程机器上加载源代码并创建最终的模块对象。 这里缓存链接的一个原因是避免不必要的 HTTP 请求重复导入。</p>
<p>自定义导入的第二种方法是编写一个钩子直接嵌入到<code>sys.path</code>变量中去， 识别某些目录命名模式。 在 <code>urlimport.py</code>中添加如下的类和支持函数：</p>
<pre><code class="lang-python"><span class="hljs-comment"># urlimport.py</span>
<span class="hljs-comment"># ... include previous code above ...</span>
<span class="hljs-comment"># Path finder class for a URL</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlPathFinder</span>(importlib.abc.PathEntryFinder):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):
        <span class="hljs-variable language_">self</span>._links = <span class="hljs-literal">None</span>
        <span class="hljs-variable language_">self</span>._loader = UrlModuleLoader(baseurl)
        <span class="hljs-variable language_">self</span>._baseurl = baseurl

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_loader</span>(<span class="hljs-params">self, fullname</span>):
        log.debug(<span class="hljs-string">'find_loader: %r'</span>, fullname)
        parts = fullname.split(<span class="hljs-string">'.'</span>)
        basename = parts[-<span class="hljs-number">1</span>]
        <span class="hljs-comment"># Check link cache</span>
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._links <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-variable language_">self</span>._links = [] <span class="hljs-comment"># See discussion</span>
            <span class="hljs-variable language_">self</span>._links = _get_links(<span class="hljs-variable language_">self</span>._baseurl)

        <span class="hljs-comment"># Check if it's a package</span>
        <span class="hljs-keyword">if</span> basename <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._links:
            log.debug(<span class="hljs-string">'find_loader: trying package %r'</span>, fullname)
            fullurl = <span class="hljs-variable language_">self</span>._baseurl + <span class="hljs-string">'/'</span> + basename
            <span class="hljs-comment"># Attempt to load the package (which accesses __init__.py)</span>
            loader = UrlPackageLoader(fullurl)
            <span class="hljs-keyword">try</span>:
                loader.load_module(fullname)
                log.debug(<span class="hljs-string">'find_loader: package %r loaded'</span>, fullname)
            <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> e:
                log.debug(<span class="hljs-string">'find_loader: %r is a namespace package'</span>, fullname)
                loader = <span class="hljs-literal">None</span>
            <span class="hljs-keyword">return</span> (loader, [fullurl])

        <span class="hljs-comment"># A normal module</span>
        filename = basename + <span class="hljs-string">'.py'</span>
        <span class="hljs-keyword">if</span> filename <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._links:
            log.debug(<span class="hljs-string">'find_loader: module %r found'</span>, fullname)
            <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">self</span>._loader, [])
        <span class="hljs-keyword">else</span>:
            log.debug(<span class="hljs-string">'find_loader: module %r not found'</span>, fullname)
            <span class="hljs-keyword">return</span> (<span class="hljs-literal">None</span>, [])

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invalidate_caches</span>(<span class="hljs-params">self</span>):
        log.debug(<span class="hljs-string">'invalidating link cache'</span>)
        <span class="hljs-variable language_">self</span>._links = <span class="hljs-literal">None</span>

<span class="hljs-comment"># Check path to see if it looks like a URL</span>
_url_path_cache = {}
<span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_url</span>(<span class="hljs-params">path</span>):
    <span class="hljs-keyword">if</span> path.startswith((<span class="hljs-string">'http://'</span>, <span class="hljs-string">'https://'</span>)):
        log.debug(<span class="hljs-string">'Handle path? %s. [Yes]'</span>, path)
        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">in</span> _url_path_cache:
            finder = _url_path_cache[path]
        <span class="hljs-keyword">else</span>:
            finder = UrlPathFinder(path)
            _url_path_cache[path] = finder
        <span class="hljs-keyword">return</span> finder
    <span class="hljs-keyword">else</span>:
        log.debug(<span class="hljs-string">'Handle path? %s. [No]'</span>, path)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">install_path_hook</span>():
    sys.path_hooks.append(handle_url)
    sys.path_importer_cache.clear()
    log.debug(<span class="hljs-string">'Installing handle_url'</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_path_hook</span>():
    sys.path_hooks.remove(handle_url)
    sys.path_importer_cache.clear()
    log.debug(<span class="hljs-string">'Removing handle_url'</span>)
</code></pre>
<p>要使用这个路径查找器，你只需要在 <code>sys.path</code> 中加入 URL 链接。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initial import fails</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'fib'</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Install the path hook</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> urlimport
<span class="hljs-meta">&gt;&gt;&gt; </span>urlimport.install_path_hook()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Imports still fail (not on path)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'fib'</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Add an entry to sys.path and watch it work</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.append(<span class="hljs-string">'http://localhost:15000'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
I<span class="hljs-string">'m fib
&gt;&gt;&gt; import grok.blah
I'</span>m grok.__init__
I<span class="hljs-string">'m grok.blah
&gt;&gt;&gt; grok.blah.__file__
'</span>http://localhost:<span class="hljs-number">15000</span>/grok/blah.py<span class="hljs-string">'
&gt;&gt;&gt;
</span></code></pre>
<p>关键点就是 <code>handle_url()</code>函数，它被添加到了 <code>sys.path_hooks</code>变量中。 当 <code>sys.path</code>的实体被处理时，会调用 <code>sys.path_hooks</code>中的函数。 如果任何一个函数返回了一个查找器对象，那么这个对象就被用来为 <code>sys.path</code>实体加载模块。</p>
<p>远程模块加载跟其他的加载使用方法几乎是一样的。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>fib
&lt;urlmodule <span class="hljs-string">'fib'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'http://localhost:15000/fib.py'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>fib.__name__
<span class="hljs-string">'fib'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>fib.__file__
<span class="hljs-string">'http://localhost:15000/fib.py'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> inspect
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(inspect.getsource(fib))
<span class="hljs-comment"># fib.py</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I'm fib"</span>)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):
    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>) + fib(n-<span class="hljs-number">2</span>)
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>在详细讨论之前，有点要强调的是，Python 的模块、包和导入机制是整个语言中最复杂的部分， 即使经验丰富的 Python 程序员也很少能精通它们。 我在这里推荐一些值的去读的文档和书籍，包括 <a href="https://docs.python.org/3/library/importlib.html" target="_blank">importlib module</a> 和 <a href="http://www.python.org/dev/peps/pep-0302" target="_blank">PEP 302</a>. 文档内容在这里不会被重复提到，不过我在这里会讨论一些最重要的部分。</p>
<p>首先，如果你想创建一个新的模块对象，使用 <code>imp.new_module()</code> 函数：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> imp
<span class="hljs-meta">&gt;&gt;&gt; </span>m = imp.new_module(<span class="hljs-string">'spam'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>m
&lt;module <span class="hljs-string">'spam'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>m.__name__
<span class="hljs-string">'spam'</span>
&gt;&gt;&gt;
</code></pre>
<p>模块对象通常有一些期望属性，包括 <code>__file__</code> （运行模块加载语句的文件名） 和 <code>__package__</code> (包名)。</p>
<p>其次，模块会被解释器缓存起来。模块缓存可以在字典 <code>sys.modules</code> 中被找到。 因为有了这个缓存机制，通常可以将缓存和模块的创建通过一个步骤完成：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> imp
<span class="hljs-meta">&gt;&gt;&gt; </span>m = sys.modules.setdefault(<span class="hljs-string">'spam'</span>, imp.new_module(<span class="hljs-string">'spam'</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>m
&lt;module <span class="hljs-string">'spam'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>如果给定模块已经存在那么就会直接获得已经被创建过的模块，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> math
<span class="hljs-meta">&gt;&gt;&gt; </span>m = sys.modules.setdefault(<span class="hljs-string">'math'</span>, imp.new_module(<span class="hljs-string">'math'</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>m
&lt;module <span class="hljs-string">'math'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'/usr/local/lib/python3.3/lib-dynload/math.so'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>m.sin(<span class="hljs-number">2</span>)
<span class="hljs-number">0.9092974268256817</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>m.cos(<span class="hljs-number">2</span>)
-<span class="hljs-number">0.4161468365471424</span>
&gt;&gt;&gt;
</code></pre>
<p>由于创建模块很简单，很容易编写简单函数比如第一部分的 <code>load_module()</code> 函数。 这个方案的一个缺点是很难处理复杂情况比如包的导入。 为了处理一个包，你要重新实现普通 import 语句的底层逻辑（比如检查目录，查找<strong>init</strong>.py 文件， 执行那些文件，设置路径等）。这个复杂性就是为什么最好直接扩展 import 语句而不是自定义函数的一个原因。</p>
<p>扩展 import 语句很简单，但是会有很多移动操作。 最高层上，导入操作被一个位于 sys.meta_path 列表中的“元路径”查找器处理。 如果你输出它的值，会看到下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint
<span class="hljs-meta">&gt;&gt;&gt; </span>pprint(sys.meta_path)
[&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'_frozen_importlib.BuiltinImporter'</span>&gt;,
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'_frozen_importlib.FrozenImporter'</span>&gt;,
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'_frozen_importlib.PathFinder'</span>&gt;]
&gt;&gt;&gt;
</code></pre>
<p>当执行一个语句比如 <code>import fib</code> 时，解释器会遍历 sys.mata_path 中的查找器对象， 调用它们的<code>find_module()</code>方法定位正确的模块加载器。 可以通过实验来看看：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Finder</span>:
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_module</span>(<span class="hljs-params">self, fullname, path</span>):
<span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Looking for'</span>, fullname, path)
<span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.meta_path.insert(<span class="hljs-number">0</span>, Finder()) <span class="hljs-comment"># Insert as first entry</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> math
Looking <span class="hljs-keyword">for</span> math <span class="hljs-literal">None</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> types
Looking <span class="hljs-keyword">for</span> types <span class="hljs-literal">None</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> threading
Looking <span class="hljs-keyword">for</span> threading <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> time <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> traceback <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> linecache <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> tokenize <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> token <span class="hljs-literal">None</span>
&gt;&gt;&gt;
</code></pre>
<p>注意看 <code>find_module()</code>方法是怎样在每一个导入就被触发的。 这个方法中的 path 参数的作用是处理包。 多个包被导入，就是一个可在包的<code>__path__</code> 属性中找到的路径列表。 要找到包的子组件就要检查这些路径。 比如注意对于 <code>xml.etree</code> 和 <code>xml.etree.ElementTree</code> 的路径配置：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> xml.etree.ElementTree
Looking <span class="hljs-keyword">for</span> xml <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> xml.etree [<span class="hljs-string">'/usr/local/lib/python3.3/xml'</span>]
Looking <span class="hljs-keyword">for</span> xml.etree.ElementTree [<span class="hljs-string">'/usr/local/lib/python3.3/xml/etree'</span>]
Looking <span class="hljs-keyword">for</span> warnings <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> contextlib <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> xml.etree.ElementPath [<span class="hljs-string">'/usr/local/lib/python3.3/xml/etree'</span>]
Looking <span class="hljs-keyword">for</span> _elementtree <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> copy <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> org <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> pyexpat <span class="hljs-literal">None</span>
Looking <span class="hljs-keyword">for</span> ElementC14N <span class="hljs-literal">None</span>
&gt;&gt;&gt;
</code></pre>
<p>在 <code>sys.meta_path</code>上查找器的位置很重要，将它从队头移到队尾，然后再试试导入看：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> sys.meta_path[<span class="hljs-number">0</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.meta_path.append(Finder())
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> urllib.request
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> datetime
</code></pre>
<p>现在你看不到任何输出了，因为导入被 sys.meta_path 中的其他实体处理。 这时候，你只有在导入不存在模块的时候才能看到它被触发：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
Looking <span class="hljs-keyword">for</span> fib <span class="hljs-literal">None</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'fib'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> xml.superfast
Looking <span class="hljs-keyword">for</span> xml.superfast [<span class="hljs-string">'/usr/local/lib/python3.3/xml'</span>]
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'xml.superfast'</span>
&gt;&gt;&gt;
</code></pre>
<p>你之前安装过一个捕获未知模块的查找器，这个是 <code>UrlMetaFinder</code> 类的关键。 一个 <code>UrlMetaFinder</code> 实例被添加到 <code>sys.meta_path</code> 的末尾，作为最后一个查找器方案。 如果被请求的模块名不能定位，就会被这个查找器处理掉。 处理包的时候需要注意，在 path 参数中指定的值需要被检查，看它是否以查找器中注册的 URL 开头。 如果不是，该子模块必须归属于其他查找器并被忽略掉。</p>
<p>对于包的其他处理可在 <code>UrlPackageLoader</code> 类中被找到。 这个类不会导入包名，而是去加载对应的 <code>__init__.py</code> 文件。 它也会设置模块的 <code>__path__</code> 属性，这一步很重要， 因为在加载包的子模块时这个值会被传给后面的 <code>find_module()</code> 调用。 基于路径的导入钩子是这些思想的一个扩展，但是采用了另外的方法。 我们都知道，<code>sys.path</code> 是一个 Python 查找模块的目录列表，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>pprint(sys.path)
[<span class="hljs-string">''</span>,
<span class="hljs-string">'/usr/local/lib/python33.zip'</span>,
<span class="hljs-string">'/usr/local/lib/python3.3'</span>,
<span class="hljs-string">'/usr/local/lib/python3.3/plat-darwin'</span>,
<span class="hljs-string">'/usr/local/lib/python3.3/lib-dynload'</span>,
<span class="hljs-string">'/usr/local/lib/...3.3/site-packages'</span>]
&gt;&gt;&gt;
</code></pre>
<p>在 <code>sys.path</code> 中的每一个实体都会被额外的绑定到一个查找器对象上。 你可以通过查看 <code>sys.path_importer_cache</code> 去看下这些查找器：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>pprint(sys.path_importer_cache)
{<span class="hljs-string">'.'</span>: FileFinder(<span class="hljs-string">'.'</span>),
<span class="hljs-string">'/usr/local/lib/python3.3'</span>: FileFinder(<span class="hljs-string">'/usr/local/lib/python3.3'</span>),
<span class="hljs-string">'/usr/local/lib/python3.3/'</span>: FileFinder(<span class="hljs-string">'/usr/local/lib/python3.3/'</span>),
<span class="hljs-string">'/usr/local/lib/python3.3/collections'</span>: FileFinder(<span class="hljs-string">'...python3.3/collections'</span>),
<span class="hljs-string">'/usr/local/lib/python3.3/encodings'</span>: FileFinder(<span class="hljs-string">'...python3.3/encodings'</span>),
<span class="hljs-string">'/usr/local/lib/python3.3/lib-dynload'</span>: FileFinder(<span class="hljs-string">'...python3.3/lib-dynload'</span>),
<span class="hljs-string">'/usr/local/lib/python3.3/plat-darwin'</span>: FileFinder(<span class="hljs-string">'...python3.3/plat-darwin'</span>),
<span class="hljs-string">'/usr/local/lib/python3.3/site-packages'</span>: FileFinder(<span class="hljs-string">'...python3.3/site-packages'</span>),
<span class="hljs-string">'/usr/local/lib/python33.zip'</span>: <span class="hljs-literal">None</span>}
&gt;&gt;&gt;
</code></pre>
<p><code>sys.path_importer_cache</code>比 <code>sys.path</code>会更大点， 因为它会为所有被加载代码的目录记录它们的查找器。 这包括包的子目录，这些通常在 <code>sys.path</code>中是不存在的。</p>
<p>要执行 <code>import fib</code> ，会顺序检查<code>sys.path</code>中的目录。 对于每个目录，名称“fib”会被传给相应的 <code>sys.path_importer_cache</code> 中的查找器。 这个可以让你创建自己的查找器并在缓存中放入一个实体。试试这个：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Finder</span>:
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_loader</span>(<span class="hljs-params">self, name</span>):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Looking for'</span>, name)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> (<span class="hljs-literal">None</span>, [])
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Add a "debug" entry to the importer cache</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path_importer_cache[<span class="hljs-string">'debug'</span>] = Finder()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Add a "debug" directory to sys.path</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.insert(<span class="hljs-number">0</span>, <span class="hljs-string">'debug'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> threading
Looking <span class="hljs-keyword">for</span> threading
Looking <span class="hljs-keyword">for</span> time
Looking <span class="hljs-keyword">for</span> traceback
Looking <span class="hljs-keyword">for</span> linecache
Looking <span class="hljs-keyword">for</span> tokenize
Looking <span class="hljs-keyword">for</span> token
&gt;&gt;&gt;
</code></pre>
<p>在这里，你可以为名字“debug”创建一个新的缓存实体并将它设置成<code>sys.path</code> 上的第一个。 在所有接下来的导入中，你会看到你的查找器被触发了。 不过，由于它返回 (None, [])，那么处理进程会继续处理下一个实体。</p>
<p><code>sys.path_importer_cache</code>的使用被一个存储在 <code>sys.path_hooks</code>中的函数列表控制。 试试下面的例子，它会清除缓存并给 <code>sys.path_hooks</code> 添加一个新的路径检查函数</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>sys.path_importer_cache.clear()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_path</span>(<span class="hljs-params">path</span>):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Checking'</span>, path)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">raise</span> ImportError()
...
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path_hooks.insert(<span class="hljs-number">0</span>, check_path)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
Checked debug
Checking .
Checking /usr/local/lib/python33.<span class="hljs-built_in">zip</span>
Checking /usr/local/lib/python3<span class="hljs-number">.3</span>
Checking /usr/local/lib/python3<span class="hljs-number">.3</span>/plat-darwin
Checking /usr/local/lib/python3<span class="hljs-number">.3</span>/lib-dynload
Checking /Users/beazley/.local/lib/python3<span class="hljs-number">.3</span>/site-packages
Checking /usr/local/lib/python3<span class="hljs-number">.3</span>/site-packages
Looking <span class="hljs-keyword">for</span> fib
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'fib'</span>
&gt;&gt;&gt;
</code></pre>
<p>正如你所见，<code>check_path()</code>函数被每个 <code>sys.path</code>中的实体调用。 不顾，由于抛出了 <code>ImportError</code> 异常， 啥都不会发生了（仅仅将检查转移到 sys.path_hooks 的下一个函数）。</p>
<p>知道了怎样 sys.path 是怎样被处理的，你就能构建一个自定义路径检查函数来查找文件名，不然 URL。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_url</span>(<span class="hljs-params">path</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> path.startswith(<span class="hljs-string">'http://'</span>):
<span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> Finder()
<span class="hljs-meta">... </span>    <span class="hljs-keyword">else</span>:
<span class="hljs-meta">... </span>        <span class="hljs-keyword">raise</span> ImportError()
...
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.append(<span class="hljs-string">'http://localhost:15000'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path_hooks[<span class="hljs-number">0</span>] = check_url
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
Looking <span class="hljs-keyword">for</span> fib <span class="hljs-comment"># Finder output!</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'fib'</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Notice installation of Finder in sys.path_importer_cache</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path_importer_cache[<span class="hljs-string">'http://localhost:15000'</span>]
&lt;__main__.Finder <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10064c850</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>这就是本节最后部分的关键点。事实上，一个用来在 sys.path 中查找 URL 的自定义路径检查函数已经构建完毕。 当它们被碰到的时候，一个新的<code>UrlPathFinder</code> 实例被创建并被放入 <code>sys.path_importer_cache</code>. 之后，所有需要检查 <code>sys.path</code> 的导入语句都会使用你的自定义查找器。</p>
<p>基于路径导入的包处理稍微有点复杂，并且跟 <code>find_loader()</code> 方法返回值有关。 对于简单模块，<code>find_loader()</code> 返回一个元组(loader, None)， 其中的 loader 是一个用于导入模块的加载器实例。</p>
<p>对于一个普通的包，<code>find_loader()</code> 返回一个元组(loader, path)， 其中的 loader 是一个用于导入包（并执行<strong>init</strong>.py）的加载器实例， path 是一个会初始化包的<code>__path__</code>属性的目录列表。 例如，如果基础 URL 是 <a href="http://localhost:15000" target="_blank">http://localhost:15000</a> 并且一个用户执行<code>import grok</code>, 那么 <code>find_loader()</code>返回的 path 就会是 [ ‘<a href="http://localhost:15000/grok‘" target="_blank">http://localhost:15000/grok‘</a> ]</p>
<p><code>find_loader()</code> 还要能处理一个命名空间包。 一个命名空间包中有一个合法的包目录名，但是不存在<strong>init</strong>.py 文件。 这样的话，<code>find_loader()</code>必须返回一个元组(None, path)， path 是一个目录列表，由它来构建包的定义有<strong>init</strong>.py 文件的<strong>path</strong>属性。 对于这种情况，导入机制会继续前行去检查 sys.path 中的目录。 如果找到了命名空间包，所有的结果路径被加到一起来构建最终的命名空间包。 关于命名空间包的更多信息请参考10.5小节。</p>
<p>所有的包都包含了一个内部路径设置，可以在<strong>path</strong>属性中看到，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> xml.etree.ElementTree
<span class="hljs-meta">&gt;&gt;&gt; </span>xml.__path__
[<span class="hljs-string">'/usr/local/lib/python3.3/xml'</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>xml.etree.__path__
[<span class="hljs-string">'/usr/local/lib/python3.3/xml/etree'</span>]
&gt;&gt;&gt;
</code></pre>
<p>之前提到，<strong>path</strong>的设置是通过 <code>find_loader()</code> 方法返回值控制的。 不过，<strong>path</strong>接下来也被 sys.path<em>hooks 中的函数处理。 因此，但包的子组件被加载后，位于<em>_path</em></em>中的实体会被 <code>handle_url()</code> 函数检查。 这会导致新的 <code>UrlPathFinder</code>实例被创建并且被加入到 <code>sys.path_importer_cache</code> 中。</p>
<p>还有个难点就是 <code>handle_url()</code> 函数以及它跟内部使用的<code>_get_links()</code> 函数之间的交互。 如果你的查找器实现需要使用到其他模块（比如 urllib.request）， 有可能这些模块会在查找器操作期间进行更多的导入。 它可以导致 <code>handle_url()</code> 和其他查找器部分陷入一种递归循环状态。 为了解释这种可能性，实现中有一个被创建的查找器缓存（每一个 URL 一个）。 它可以避免创建重复查找器的问题。 另外，下面的代码片段可以确保查找器不会在初始化链接集合的时候响应任何导入请求：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Check link cache</span>
<span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._links <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
    <span class="hljs-variable language_">self</span>._links = [] <span class="hljs-comment"># See discussion</span>
    <span class="hljs-variable language_">self</span>._links = _get_links(<span class="hljs-variable language_">self</span>._baseurl)
</code></pre>
<p>最后，查找器的 <code>invalidate_caches()</code> 方法是一个工具方法，用来清理内部缓存。 这个方法再用户调用<code>importlib.invalidate_caches()</code>的时候被触发。 如果你想让 URL 导入者重新读取链接列表的话可以使用它。</p>
<p>对比下两种方案（修改 sys.meta_path 或使用一个路径钩子）。 使用 sys.meta_path 的导入者可以按照自己的需要自由处理模块。 例如，它们可以从数据库中导入或以不同于一般模块/包处理方式导入。 这种自由同样意味着导入者需要自己进行内部的一些管理。 另外，基于路径的钩子只是适用于对 sys.path 的处理。 通过这种扩展加载的模块跟普通方式加载的特性是一样的。</p>
<p>如果到现在为止你还是不是很明白，那么可以通过增加一些日志打印来测试下本节。像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> logging
<span class="hljs-meta">&gt;&gt;&gt; </span>logging.basicConfig(level=logging.DEBUG)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> urlimport
<span class="hljs-meta">&gt;&gt;&gt; </span>urlimport.install_path_hook()
DEBUG:urlimport:Installing handle_url
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
DEBUG:urlimport:Handle path? /usr/local/lib/python33.<span class="hljs-built_in">zip</span>. [No]
Traceback (most recent call last):
File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
ImportError: No module named <span class="hljs-string">'fib'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.append(<span class="hljs-string">'http://localhost:15000'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fib
DEBUG:urlimport:Handle path? http://localhost:<span class="hljs-number">15000.</span> [Yes]
DEBUG:urlimport:Getting links <span class="hljs-keyword">from</span> http://localhost:<span class="hljs-number">15000</span>
DEBUG:urlimport:links: {<span class="hljs-string">'spam.py'</span>, <span class="hljs-string">'fib.py'</span>, <span class="hljs-string">'grok'</span>}
DEBUG:urlimport:find_loader: <span class="hljs-string">'fib'</span>
DEBUG:urlimport:find_loader: module <span class="hljs-string">'fib'</span> found
DEBUG:urlimport:loader: reading <span class="hljs-string">'http://localhost:15000/fib.py'</span>
DEBUG:urlimport:loader: <span class="hljs-string">'http://localhost:15000/fib.py'</span> loaded
I<span class="hljs-string">'m fib
&gt;&gt;&gt;
</span></code></pre>
<p>最后，建议你花点时间看看 <a href="http://www.python.org/dev/peps/pep-0302" target="_blank">PEP 302</a> 以及 importlib 的文档。</p>
<h1 id="1012-导入模块的同时修改模块">10.12 导入模块的同时修改模块</h1>
<h2 id="问题">问题</h2>
<p>你想给某个已存在模块中的函数添加装饰器。 不过，前提是这个模块已经被导入并且被使用过。</p>
<h2 id="解决方案">解决方案</h2>
<p>这里问题的本质就是你想在模块被加载时执行某个动作。 可能是你想在一个模块被加载时触发某个回调函数来通知你。</p>
<p>这个问题可以使用10.11小节中同样的导入钩子机制来实现。下面是一个可能的方案：</p>
<pre><code class="lang-python"><span class="hljs-comment"># postimport.py</span>
<span class="hljs-keyword">import</span> importlib
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict

_post_import_hooks = defaultdict(<span class="hljs-built_in">list</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PostImportFinder</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._skip = <span class="hljs-built_in">set</span>()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_module</span>(<span class="hljs-params">self, fullname, path=<span class="hljs-literal">None</span></span>):
        <span class="hljs-keyword">if</span> fullname <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._skip:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-variable language_">self</span>._skip.add(fullname)
        <span class="hljs-keyword">return</span> PostImportLoader(<span class="hljs-variable language_">self</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PostImportLoader</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, finder</span>):
        <span class="hljs-variable language_">self</span>._finder = finder

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_module</span>(<span class="hljs-params">self, fullname</span>):
        importlib.import_module(fullname)
        module = sys.modules[fullname]
        <span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> _post_import_hooks[fullname]:
            func(module)
        <span class="hljs-variable language_">self</span>._finder._skip.remove(fullname)
        <span class="hljs-keyword">return</span> module

<span class="hljs-keyword">def</span> <span class="hljs-title function_">when_imported</span>(<span class="hljs-params">fullname</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):
        <span class="hljs-keyword">if</span> fullname <span class="hljs-keyword">in</span> sys.modules:
            func(sys.modules[fullname])
        <span class="hljs-keyword">else</span>:
            _post_import_hooks[fullname].append(func)
        <span class="hljs-keyword">return</span> func
    <span class="hljs-keyword">return</span> decorate

sys.meta_path.insert(<span class="hljs-number">0</span>, PostImportFinder())
</code></pre>
<p>这样，你就可以使用 <code>when_imported()</code> 装饰器了，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> postimport <span class="hljs-keyword">import</span> when_imported
<span class="hljs-meta">&gt;&gt;&gt; </span>@when_imported(<span class="hljs-string">'threading'</span>)
<span class="hljs-meta">... </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">warn_threads</span>(<span class="hljs-params">mod</span>):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Threads? Are you crazy?'</span>)
...
&gt;&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> threading
Threads? Are you crazy?
&gt;&gt;&gt;
</code></pre>
<p>作为一个更实际的例子，你可能想在已存在的定义上面添加装饰器，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps
<span class="hljs-keyword">from</span> postimport <span class="hljs-keyword">import</span> when_imported

<span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">func</span>):
<span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Calling'</span>, func.__name__, args, kwargs)
        <span class="hljs-keyword">return</span> func(*args, **kwargs)
    <span class="hljs-keyword">return</span> wrapper

<span class="hljs-comment"># Example</span>
<span class="hljs-meta">@when_imported(<span class="hljs-params"><span class="hljs-string">'math'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">add_logging</span>(<span class="hljs-params">mod</span>):
    mod.cos = logged(mod.cos)
    mod.sin = logged(mod.sin)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>本节技术依赖于10.11小节中讲述过的导入钩子，并稍作修改。</p>
<p><code>@when_imported</code> 装饰器的作用是注册在导入时被激活的处理器函数。 该装饰器检查 sys.modules 来查看模块是否真的已经被加载了。 如果是的话，该处理器被立即调用。不然，处理器被添加到 <code>_post_import_hooks</code> 字典中的一个列表中去。 <code>_post_import_hooks</code> 的作用就是收集所有的为每个模块注册的处理器对象。 一个模块可以注册多个处理器。</p>
<p>要让模块导入后触发添加的动作，<code>PostImportFinder</code> 类被设置为 sys.meta_path 第一个元素。 它会捕获所有模块导入操作。</p>
<p>本节中的<code>PostImportFinder</code> 的作用并不是加载模块，而是自带导入完成后触发相应的动作。 实际的导入被委派给位于 sys.meta_path 中的其他查找器。 <code>PostImportLoader</code> 类中的 <code>imp.import_module()</code> 函数被递归的调用。 为了避免陷入无线循环，<code>PostImportFinder</code>保持了一个所有被加载过的模块集合。 如果一个模块名存在就会直接被忽略掉。</p>
<p>当一个模块被 <code>imp.import_module()</code> 加载后， 所有在_post_import_hooks 被注册的处理器被调用，使用新加载模块作为一个参数。</p>
<p>有一点需要注意的是本机不适用于那些通过<code>imp.reload()</code>被显式加载的模块。 也就是说，如果你加载一个之前已被加载过的模块，那么导入处理器将不会再被触发。 另外，要是你从 sys.modules 中删除模块然后再重新导入，处理器又会再一次触发。</p>
<p>更多关于导入后钩子信息请参考 <a href="https://www.python.org/dev/peps/pep-0369" target="_blank">PEP 369</a>.</p>
<h1 id="1013-安装私有的包">10.13 安装私有的包</h1>
<h2 id="问题">问题</h2>
<p>你想要安装一个第三方包，但是没有权限将它安装到系统 Python 库中去。 或者，你可能想要安装一个供自己使用的包，而不是系统上面所有用户。</p>
<h2 id="解决方案">解决方案</h2>
<p>Python 有一个用户安装目录，通常类似”~/.local/lib/python3.3/site-packages”。 要强制在这个目录中安装包，可使用安装选项“–user”。例如：</p>
<pre><code class="lang-python">python3 setup.py install --user
</code></pre>
<p>或者</p>
<pre><code class="lang-python">pip install --user packagename
</code></pre>
<p>在 sys.path 中用户的“site-packages”目录位于系统的“site-packages”目录之前。 因此，你安装在里面的包就比系统已安装的包优先级高 （尽管并不总是这样，要取决于第三方包管理器，比如 distribute 或 pip）。</p>
<h2 id="讨论">讨论</h2>
<p>通常包会被安装到系统的 site-packages 目录中去，路径类似“/usr/local/lib/python3.3/site-packages”。 不过，这样做需要有管理员权限并且使用 sudo 命令。 就算你有这样的权限去执行命令，使用 sudo 去安装一个新的，可能没有被验证过的包有时候也不安全。</p>
<p>安装包到用户目录中通常是一个有效的方案，它允许你创建一个自定义安装。</p>
<p>另外，你还可以创建一个虚拟环境，这个我们在下一节会讲到。</p>
<h1 id="1014-创建新的-python-环境">10.14 创建新的 Python 环境</h1>
<h2 id="问题">问题</h2>
<p>你想创建一个新的 Python 环境，用来安装模块和包。 不过，你不想安装一个新的 Python 克隆，也不想对系统 Python 环境产生影响。</p>
<h2 id="解决方案">解决方案</h2>
<p>你可以使用 <code>pyvenv</code> 命令创建一个新的“虚拟”环境。 这个命令被安装在 Python 解释器同一目录，或 Windows 上面的 Scripts 目录中。下面是一个例子：</p>
<pre><code class="lang-python">bash % pyvenv Spam
bash %
</code></pre>
<p>传给<code>pyvenv</code>命令的名字是将要被创建的目录名。当被创建后，Span 目录像下面这样：</p>
<pre><code class="lang-python">bash % cd Spam
bash % ls
<span class="hljs-built_in">bin</span> include lib pyvenv.cfg
bash %
</code></pre>
<p>在 bin 目录中，你会找到一个可以使用的 Python 解释器：</p>
<pre><code class="lang-python">bash % Spam/<span class="hljs-built_in">bin</span>/python3
Python <span class="hljs-number">3.3</span><span class="hljs-number">.0</span> (default, Oct <span class="hljs-number">6</span> <span class="hljs-number">2012</span>, <span class="hljs-number">15</span>:<span class="hljs-number">45</span>:<span class="hljs-number">22</span>)
[GCC <span class="hljs-number">4.2</span><span class="hljs-number">.1</span> (Apple Inc. build <span class="hljs-number">5666</span>) (dot <span class="hljs-number">3</span>)] on darwin
<span class="hljs-type">Type</span> <span class="hljs-string">"help"</span>, <span class="hljs-string">"copyright"</span>, <span class="hljs-string">"credits"</span> <span class="hljs-keyword">or</span> <span class="hljs-string">"license"</span> <span class="hljs-keyword">for</span> more information.
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys
<span class="hljs-meta">&gt;&gt;&gt; </span>pprint(sys.path)
[<span class="hljs-string">''</span>,
<span class="hljs-string">'/usr/local/lib/python33.zip'</span>,
<span class="hljs-string">'/usr/local/lib/python3.3'</span>,
<span class="hljs-string">'/usr/local/lib/python3.3/plat-darwin'</span>,
<span class="hljs-string">'/usr/local/lib/python3.3/lib-dynload'</span>,
<span class="hljs-string">'/Users/beazley/Spam/lib/python3.3/site-packages'</span>]
&gt;&gt;&gt;
</code></pre>
<p>这个解释器的特点就是他的 site-packages 目录被设置为新创建的环境。 如果你要安装第三方包，它们会被安装在那里，而不是通常系统的 site-packages 目录。</p>
<h2 id="讨论">讨论</h2>
<p>创建虚拟环境通常是为了安装和管理第三方包。 正如你在例子中看到的那样，<code>sys.path</code> 变量包含来自于系统 Python 的目录， 而 site-packages 目录已经被重定位到一个新的目录。</p>
<p>有了一个新的虚拟环境，下一步就是安装一个包管理器，比如 distribute 或 pip。 但安装这样的工具和包的时候，你需要确保你使用的是虚拟环境的解释器。 它会将包安装到新创建的 site-packages 目录中去。</p>
<p>尽管一个虚拟环境看上去是 Python 安装的一个复制， 不过它实际上只包含了少量几个文件和一些符号链接。 素有标准库函文件和可执行解释器都来自原来的 Python 安装。 因此，创建这样的环境是很容易的，并且几乎不会消耗机器资源。</p>
<p>默认情况下，虚拟环境是空的，不包含任何额外的第三方库。如果你想将一个已经安装的包作为虚拟环境的一部分， 可以使用“–system-site-packages”选项来创建虚拟环境，例如：</p>
<pre><code class="lang-python">bash % pyvenv --system-site-packages Spam
bash %
</code></pre>
<p>跟多关于 <code>pyvenv</code>和虚拟环境的信息可以参考 <a href="https://www.python.org/dev/peps/pep-0405/" target="_blank">PEP 405</a>.</p>
<h1 id="1015-分发包">10.15 分发包</h1>
<h2 id="问题">问题</h2>
<p>你已经编写了一个有用的库，想将它分享给其他人。</p>
<h2 id="解决方案">解决方案</h2>
<p>如果你想分发你的代码，第一件事就是给它一个唯一的名字，并且清理它的目录结构。 例如，一个典型的函数库包会类似下面这样：</p>
<pre><code class="lang-python">projectname/
    README.txt
    Doc/
        documentation.txt
    projectname/
        __init__.py
        foo.py
        bar.py
        utils/
            __init__.py
            spam.py
            grok.py
    examples/
        helloworld.py
        ...
</code></pre>
<p>要让你的包可以发布出去，首先你要编写一个 <code>setup.py</code> ，类似下面这样：</p>
<pre><code class="lang-python"><span class="hljs-comment"># setup.py</span>
<span class="hljs-keyword">from</span> distutils.core <span class="hljs-keyword">import</span> setup

setup(name=<span class="hljs-string">'projectname'</span>,
    version=<span class="hljs-string">'1.0'</span>,
    author=<span class="hljs-string">'Your Name'</span>,
    author_email=<span class="hljs-string">'you@youraddress.com'</span>,
    url=<span class="hljs-string">'http://www.you.com/projectname'</span>,
    packages=[<span class="hljs-string">'projectname'</span>, <span class="hljs-string">'projectname.utils'</span>],
)
</code></pre>
<p>下一步，就是创建一个 <code>MANIFEST.in</code>文件，列出所有在你的包中需要包含进来的非源码文件：</p>
<pre><code class="lang-python"><span class="hljs-comment"># MANIFEST.in</span>
include *.txt
recursive-include examples *
recursive-include Doc *
</code></pre>
<p>确保 <code>setup.py</code> 和 <code>MANIFEST.in</code> 文件放在你的包的最顶级目录中。 一旦你已经做了这些，你就可以像下面这样执行命令来创建一个源码分发包了：</p>
<pre><code class="lang-python">% bash python3 setup.py sdist
</code></pre>
<p>它会创建一个文件比如”projectname-1.0.zip” 或 “projectname-1.0.tar.gz”, 具体依赖于你的系统平台。如果一切正常， 这个文件就可以发送给别人使用或者上传至 <a href="http://pypi.python.org/" target="_blank">Python Package Index</a>.</p>
<h2 id="讨论">讨论</h2>
<p>对于纯 Python 代码，编写一个普通的 <code>setup.py</code> 文件通常很简单。 一个可能的问题是你必须手动列出所有构成包源码的子目录。 一个常见错误就是仅仅只列出一个包的最顶级目录，忘记了包含包的子组件。 这也是为什么在<code>setup.py</code> 中对于包的说明包含了列表 <code>packages=['projectname', 'projectname.utils']</code></p>
<p>大部分 Python 程序员都知道，有很多第三方包管理器供选择，包括 setuptools、distribute 等等。 有些是为了替代标准库中的 distutils。注意如果你依赖这些包， 用户可能不能安装你的软件，除非他们已经事先安装过所需要的包管理器。 正因如此，你更应该时刻记住越简单越好的道理。 最好让你的代码使用标准的 Python 3 安装。 如果其他包也需要的话，可以通过一个可选项来支持。</p>
<p>对于涉及到 C 扩展的代码打包与分发就更复杂点了。 第15章对关于 C 扩展的这方面知识有一些详细讲解，特别是在15.2小节中。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="metaprogramming.html" class="navigation navigation-prev " aria-label="Previous page: 第九章：元编程">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="network-and-web-programming.html" class="navigation navigation-next " aria-label="Next page: 第十一章：网络与 Web 编程">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第十章：模块与包","level":"1.11","depth":1,"next":{"title":"第十一章：网络与 Web 编程","level":"1.12","depth":1,"path":"network-and-web-programming.md","ref":"network-and-web-programming.md","articles":[]},"previous":{"title":"第九章：元编程","level":"1.10","depth":1,"path":"metaprogramming.md","ref":"metaprogramming.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"module-and-pack.md","mtime":"2025-01-09T21:48:32.002Z","type":"markdown"},"gitbook":{"version":"6.0.2","time":"2025-01-11T18:48:45.487Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

