
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第十三章：脚本编程与系统管理 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="testing-debugging-and-exception.html" />
    
    
    <link rel="prev" href="concurrent-programming.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="data-structures-and-algorithms.html">
            
                <a href="data-structures-and-algorithms.html">
            
                    
                    第一章：数据结构和算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="string-and-text.html">
            
                <a href="string-and-text.html">
            
                    
                    第二章：字符串和文本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="digital-date-and-time.html">
            
                <a href="digital-date-and-time.html">
            
                    
                    第三章：数字日期和时间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="iterators-and-generators.html">
            
                <a href="iterators-and-generators.html">
            
                    
                    第四章：迭代器与生成器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="files-and-io.html">
            
                <a href="files-and-io.html">
            
                    
                    第五章：文件与 IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="coding-and-processing-data.html">
            
                <a href="coding-and-processing-data.html">
            
                    
                    第六章：数据编码和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    第七章：函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="classes-and-objects.html">
            
                <a href="classes-and-objects.html">
            
                    
                    第八章：类与对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="metaprogramming.html">
            
                <a href="metaprogramming.html">
            
                    
                    第九章：元编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="module-and-pack.html">
            
                <a href="module-and-pack.html">
            
                    
                    第十章：模块与包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="network-and-web-programming.html">
            
                <a href="network-and-web-programming.html">
            
                    
                    第十一章：网络与 Web 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="concurrent-programming.html">
            
                <a href="concurrent-programming.html">
            
                    
                    第十二章：并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.14" data-path="scripting-and-systems-management.html">
            
                <a href="scripting-and-systems-management.html">
            
                    
                    第十三章：脚本编程与系统管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="testing-debugging-and-exception.html">
            
                <a href="testing-debugging-and-exception.html">
            
                    
                    第十四章：测试、调试和异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="c-language-extensions.html">
            
                <a href="c-language-extensions.html">
            
                    
                    第十五章：C 语言扩展
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第十三章：脚本编程与系统管理</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第十三章：脚本编程与系统管理">第十三章：脚本编程与系统管理</h1>
<p>许多人使用 Python 作为一个 shell 脚本的替代，用来实现常用系统任务的自动化，如文件的操作，系统的配置等。本章的主要目标是描述光宇编写脚本时候经常遇到的一些功能。例如，解析命令行选项、获取有用的系统配置数据等等。第5章也包含了与文件和目录相关的一般信息。</p>
<h1 id="131-通过重定向管道文件接受输入">13.1 通过重定向/管道/文件接受输入</h1>
<h2 id="问题">问题</h2>
<p>你希望你的脚本接受任何用户认为最简单的输入方式。包括将命令行的输出通过管道传递给该脚本、 重定向文件到该脚本，或在命令行中传递一个文件名或文件名列表给该脚本。</p>
<h2 id="解决方案">解决方案</h2>
<p>Python 内置的 <code>fileinput</code> 模块让这个变得简单。如果你有一个下面这样的脚本：</p>
<pre><code>#!/usr/bin/env python3
import fileinput

with fileinput.input() as f_input:
    for line in f_input:
        print(line, end='')
</code></pre><p>那么你就能以前面提到的所有方式来为此脚本提供输入。假设你将此脚本保存为 <code>filein.py</code>并将其变为可执行文件， 那么你可以像下面这样调用它，得到期望的输出：</p>
<pre><code>$ ls | ./filein.py          # Prints a directory listing to stdout.
$ ./filein.py /etc/passwd   # Reads /etc/passwd to stdout.
$ ./filein.py &lt; /etc/passwd # Reads /etc/passwd to stdout.
</code></pre><h2 id="讨论">讨论</h2>
<p><code>fileinput.input()</code>创建并返回一个 <code>FileInput</code>类的实例。 该实例除了拥有一些有用的帮助方法外，它还可被当做一个上下文管理器使用。 因此，整合起来，如果我们要写一个打印多个文件输出的脚本，那么我们需要在输出中包含文件名和行号，如下所示：</p>
<pre><code>&gt;&gt;&gt; import fileinput
&gt;&gt;&gt; with fileinput.input('/etc/passwd') as f:
&gt;&gt;&gt;     for line in f:
...         print(f.filename(), f.lineno(), line, end='')
...
/etc/passwd 1 ##
/etc/passwd 2 # User Database
/etc/passwd 3 #

&lt;other output omitted&gt;
</code></pre><p>通过将它作为一个上下文管理器使用，可以确保它不再使用时文件能自动关闭， 而且我们在之类还演示了 <code>FileInput</code> 的一些有用的帮助方法来获取输出中的一些其他信息。</p>
<h1 id="132-终止程序并给出错误信息">13.2 终止程序并给出错误信息</h1>
<h2 id="问题">问题</h2>
<p>你想向标准错误打印一条消息并返回某个非零状态码来终止程序运行</p>
<h2 id="解决方案">解决方案</h2>
<p>你有一个程序像下面这样终止，抛出一个 <code>SystemExit</code> 异常，使用错误消息作为参数。例如：</p>
<pre><code>raise SystemExit('It failed!')
</code></pre><p>它会将消息在 <code>sys.stderr</code> 中打印，然后程序以状态码1退出。</p>
<h2 id="讨论">讨论</h2>
<p>本节虽然很短小，但是它能解决在写脚本时的一个常见问题。 也就是说，当你想要终止某个程序时，你可能会像下面这样写：</p>
<pre><code>import sys
sys.stderr.write('It failed!\n')
raise SystemExit(1)
</code></pre><p>如果你直接将消息作为参数传给 <code>SystemExit()</code> ，那么你可以省略其他步骤， 比如 import 语句或将错误消息写入 <code>sys.stderr</code></p>
<h1 id="133-解析命令行选项">13.3 解析命令行选项</h1>
<h2 id="问题">问题</h2>
<p>你的程序如何能够解析命令行选项（位于 sys.argv 中）</p>
<h2 id="解决方案">解决方案</h2>
<p><code>argparse</code> 模块可被用来解析命令行选项。下面一个简单例子演示了最基本的用法：</p>
<pre><code># search.py
'''
Hypothetical command-line tool for searching a collection of
files for one or more text patterns.
'''
import argparse
parser = argparse.ArgumentParser(description='Search some files')

parser.add_argument(dest='filenames',metavar='filename', nargs='*')

parser.add_argument('-p', '--pat',metavar='pattern', required=True,
                    dest='patterns', action='append',
                    help='text pattern to search for')

parser.add_argument('-v', dest='verbose', action='store_true',
                    help='verbose mode')

parser.add_argument('-o', dest='outfile', action='store',
                    help='output file')

parser.add_argument('--speed', dest='speed', action='store',
                    choices={'slow','fast'}, default='slow',
                    help='search speed')

args = parser.parse_args()

# Output the collected arguments
print(args.filenames)
print(args.patterns)
print(args.verbose)
print(args.outfile)
print(args.speed)
</code></pre><p>该程序定义了一个如下使用的命令行解析器：</p>
<pre><code>bash % python3 search.py -h
usage: search.py [-h] [-p pattern] [-v] [-o OUTFILE] [--speed {slow,fast}]
                 [filename [filename ...]]

Search some files

positional arguments:
  filename

optional arguments:
  -h, --help            show this help message and exit
  -p pattern, --pat pattern
                        text pattern to search for
  -v                    verbose mode
  -o OUTFILE            output file
  --speed {slow,fast}   search speed
</code></pre><p>下面的部分演示了程序中的数据部分。仔细观察 print()语句的打印输出。</p>
<pre><code>bash % python3 search.py foo.txt bar.txt
usage: search.py [-h] -p pattern [-v] [-o OUTFILE] [--speed {fast,slow}]
                 [filename [filename ...]]
search.py: error: the following arguments are required: -p/--pat

bash % python3 search.py -v -p spam --pat=eggs foo.txt bar.txt
filenames = ['foo.txt', 'bar.txt']
patterns  = ['spam', 'eggs']
verbose   = True
outfile   = None
speed     = slow

bash % python3 search.py -v -p spam --pat=eggs foo.txt bar.txt -o results
filenames = ['foo.txt', 'bar.txt']
patterns  = ['spam', 'eggs']
verbose   = True
outfile   = results
speed     = slow

bash % python3 search.py -v -p spam --pat=eggs foo.txt bar.txt -o results \
             --speed=fast
filenames = ['foo.txt', 'bar.txt']
patterns  = ['spam', 'eggs']
verbose   = True
outfile   = results
speed     = fast
</code></pre><p>对于选项值的进一步处理由程序来决定，用你自己的逻辑来替代 <code>print()</code> 函数。</p>
<h2 id="讨论">讨论</h2>
<p><code>argparse</code> 模块是标准库中最大的模块之一，拥有大量的配置选项。 本节只是演示了其中最基础的一些特性，帮助你入门。</p>
<p>为了解析命令行选项，你首先要创建一个 <code>ArgumentParser</code> 实例， 并使用 <code>add_argument()</code>方法声明你想要支持的选项。 在每个<code>add-argument()</code> 调用中，<code>dest</code> 参数指定解析结果被指派给属性的名字。 <code>metavar</code> 参数被用来生成帮助信息。<code>action</code> 参数指定跟属性对应的处理逻辑， 通常的值为 <code>store</code> ,被用来存储某个值或讲多个参数值收集到一个列表中。 下面的参数收集所有剩余的命令行参数到一个列表中。在本例中它被用来构造一个文件名列表：</p>
<pre><code>parser.add_argument(dest='filenames',metavar='filename', nargs='*')
</code></pre><p>下面的参数根据参数是否存在来设置一个 <code>Boolean</code> 标志：</p>
<pre><code>parser.add_argument('-v', dest='verbose', action='store_true',
                    help='verbose mode')
</code></pre><p>下面的参数接受一个单独值并将其存储为一个字符串：</p>
<pre><code>parser.add_argument('-o', dest='outfile', action='store',
                    help='output file')
</code></pre><p>下面的参数说明允许某个参数重复出现多次，并将它们追加到一个列表中去。<code>required</code> 标志表示该参数至少要有一个。<code>-p</code> 和 <code>--pat</code>表示两个参数名形式都可使用。</p>
<pre><code>parser.add_argument('-p', '--pat',metavar='pattern', required=True,
                    dest='patterns', action='append',
                    help='text pattern to search for')
</code></pre><p>最后，下面的参数说明接受一个值，但是会将其和可能的选择值做比较，以检测其合法性：</p>
<pre><code>parser.add_argument('--speed', dest='speed', action='store',
                    choices={'slow','fast'}, default='slow',
                    help='search speed')
</code></pre><p>一旦参数选项被指定，你就可以执行 <code>parser.parse()</code>方法了。 它会处理 <code>sys.argv</code> 的值并返回一个结果实例。 每个参数值会被设置成该实例中<code>add_argument()</code> 方法的<code>dest</code>参数指定的属性值。</p>
<p>还很多种其他方法解析命令行选项。 例如，你可能会手动的处理 <code>sys.argv</code>或者使用 <code>getopt</code>模块。 但是，如果你采用本节的方式，将会减少很多冗余代码，底层细节 <code>argparse</code> 模块已经帮你处理了。 你可能还会碰到使用 <code>optparse</code>库解析选项的代码。 尽管 <code>optparse</code>和 <code>argparse</code> 很像，但是后者更先进，因此在新的程序中你应该使用它。</p>
<h1 id="134-运行时弹出密码输入提示">13.4 运行时弹出密码输入提示</h1>
<h2 id="问题">问题</h2>
<p>你写了个脚本，运行时需要一个密码。此脚本是交互式的，因此不能将密码在脚本中硬编码， 而是需要弹出一个密码输入提示，让用户自己输入。</p>
<h2 id="解决方案">解决方案</h2>
<p>这时候 Python 的 <code>getpass</code> 模块正是你所需要的。你可以让你很轻松的弹出密码输入提示， 并且不会在用户终端回显密码。下面是具体代码：</p>
<pre><code>import getpass

user = getpass.getuser()
passwd = getpass.getpass()

if svc_login(user, passwd):    # You must write svc_login()
   print('Yay!')
else:
   print('Boo!')
</code></pre><p>在此代码中，<code>svc_login()</code>是你要实现的处理密码的函数，具体的处理过程你自己决定。</p>
<h2 id="讨论">讨论</h2>
<p>注意在前面代码中<code>getpass.getuser()</code> 不会弹出用户名的输入提示。 它会根据该用户的shell环境或者会依据本地系统的密码库（支持 pwd 模块的平台）来使用当前用户的登录名，</p>
<p>如果你想显示的弹出用户名输入提示，使用内置的 <code>input</code> 函数：</p>
<pre><code>user = input('Enter your username: ')
</code></pre><p>还有一点很重要，有些系统可能不支持 <code>getpass()</code>方法隐藏输入密码。 这种情况下，Python 会提前警告你这些问题（例如它会警告你说密码会以明文形式显示）</p>
<h1 id="135-获取终端的大小">13.5 获取终端的大小</h1>
<h2 id="问题">问题</h2>
<p>你需要知道当前终端的大小以便正确的格式化输出。</p>
<h2 id="解决方案">解决方案</h2>
<p>使用 <code>os.get_terminal_size()</code>函数来做到这一点。</p>
<p>代码示例：</p>
<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; sz = os.get_terminal_size()
&gt;&gt;&gt; sz
os.terminal_size(columns=80, lines=24)
&gt;&gt;&gt; sz.columns
80
&gt;&gt;&gt; sz.lines
24
&gt;&gt;&gt;
</code></pre><h2 id="讨论">讨论</h2>
<p>有太多方式来得知终端大小了，从读取环境变量到执行底层的 <code>ioctl()</code> 函数等等。 不过，为什么要去研究这些复杂的办法而不是仅仅调用一个简单的函数呢？</p>
<h1 id="136-执行外部命令并获取它的输出">13.6 执行外部命令并获取它的输出</h1>
<h2 id="问题">问题</h2>
<p>你想执行一个外部命令并以 Python 字符串的形式获取执行结果。</p>
<h2 id="解决方案">解决方案</h2>
<p>使用 <code>subprocess.check_output()</code> 函数。例如：</p>
<pre><code>import subprocess
out_bytes = subprocess.check_output(['netstat','-a'])
</code></pre><p>这段代码执行一个指定的命令并将执行结果以一个字节字符串的形式返回。 如果你需要文本形式返回，加一个解码步骤即可。例如：</p>
<pre><code>out_text = out_bytes.decode('utf-8')
</code></pre><p>如果被执行的命令以非零码返回，就会抛出异常。 下面的例子捕获到错误并获取返回码：</p>
<pre><code>try:
    out_bytes = subprocess.check_output(['cmd','arg1','arg2'])
except subprocess.CalledProcessError as e:
    out_bytes = e.output       # Output generated before error
    code      = e.returncode   # Return code
</code></pre><p>默认情况下，<code>check_output()</code> 仅仅返回输入到标准输出的值。 如果你需要同时收集标准输出和错误输出，使用 <code>stderr</code> 参数：</p>
<pre><code>out_bytes = subprocess.check_output(['cmd','arg1','arg2'],
                                    stderr=subprocess.STDOUT)
</code></pre><p>如果你需要用一个超时机制来执行命令，使用 <code>timeout</code> 参数：</p>
<pre><code>try:
    out_bytes = subprocess.check_output(['cmd','arg1','arg2'], timeout=5)
except subprocess.TimeoutExpired as e:
    ...
</code></pre><p>通常来讲，命令的执行不需要使用到底层 shell 环境（比如 sh、bash）。 一个字符串列表会被传递给一个低级系统命令，比如 <code>os.execve()</code> 。 如果你想让命令被一个 shell 执行，传递一个字符串参数，并设置参数 <code>shell=True</code> . 有时候你想要 Python 去执行一个复杂的 shell 命令的时候这个就很有用了，比如管道流、I/O 重定向和其他特性。例如：</p>
<pre><code>out_bytes = subprocess.check_output('grep python | wc &gt; out', shell=True)
</code></pre><p>需要注意的是在 shell 中执行命令会存在一定的安全风险，特别是当参数来自于用户输入时。 这时候可以使用 <code>shlex.quote()</code> 函数来讲参数正确的用双引用引起来。</p>
<h2 id="讨论">讨论</h2>
<p>使用 <code>check_output()</code> 函数是执行外部命令并获取其返回值的最简单方式。 但是，如果你需要对子进程做更复杂的交互，比如给它发送输入，你得采用另外一种方法。 这时候可直接使用 <code>subprocess.Popen</code> 类。例如：</p>
<pre><code>import subprocess

# Some text to send
text = b'''
hello world
this is a test
goodbye
'''

# Launch a command with pipes
p = subprocess.Popen(['wc'],
          stdout = subprocess.PIPE,
          stdin = subprocess.PIPE)

# Send the data and get the output
stdout, stderr = p.communicate(text)

# To interpret as text, decode
out = stdout.decode('utf-8')
err = stderr.decode('utf-8')
</code></pre><p><code>subprocess</code>模块对于依赖 TTY 的外部命令不合适用。 例如，你不能使用它来自动化一个用户输入密码的任务（比如一个 ssh 会话）。 这时候，你需要使用到第三方模块了，比如基于著名的 <code>expect</code> 家族的工具（pexpect 或类似的）</p>
<h1 id="137-复制或者移动文件和目录">13.7 复制或者移动文件和目录</h1>
<h2 id="问题">问题</h2>
<p>你想哟啊复制或移动文件和目录，但是又不想调用 shell 命令。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>shutil</code> 模块有很多便捷的函数可以复制文件和目录。使用起来非常简单，比如：</p>
<pre><code>import shutil

# Copy src to dst. (cp src dst)
shutil.copy(src, dst)

# Copy files, but preserve metadata (cp -p src dst)
shutil.copy2(src, dst)

# Copy directory tree (cp -R src dst)
shutil.copytree(src, dst)

# Move src to dst (mv src dst)
shutil.move(src, dst)
</code></pre><p>这些函数的参数都是字符串形式的文件或目录名。 底层语义模拟了类似的 Unix 命令，如上面的注释部分。</p>
<p>默认情况下，对于符号链接而已这些命令处理的是它指向的东西。 例如，如果源文件是一个符号链接，那么目标文件将会是符号链接指向的文件。 如果你只想复制符号链接本身，那么需要指定关键字参数 <code>follow_symlinks</code>,如下：</p>
<p>如果你想保留被复制目录中的符号链接，像这样做：</p>
<pre><code>shutil.copytree(src, dst, symlinks=True)
</code></pre><p><code>copytree()</code> 可以让你在复制过程中选择性的忽略某些文件或目录。 你可以提供一个忽略函数，接受一个目录名和文件名列表作为输入，返回一个忽略的名称列表。例如：</p>
<pre><code>def ignore_pyc_files(dirname, filenames):
    return [name in filenames if name.endswith('.pyc')]

shutil.copytree(src, dst, ignore=ignore_pyc_files)
</code></pre><p>Since ignoring filename patterns is common, a utility function ignore_patterns() has already been provided to do it. For example:</p>
<p>shutil.copytree(src, dst, ignore=shutil.ignore_patterns(‘~’,’.pyc’))</p>
<h2 id="讨论">讨论</h2>
<p>使用 <code>shutil</code> 复制文件和目录也忒简单了点吧。 不过，对于文件元数据信息，<code>copy2()</code> 这样的函数只能尽自己最大能力来保留它。 访问时间、创建时间和权限这些基本信息会被保留， 但是对于所有者、ACLs、资源 fork 和其他更深层次的文件元信息就说不准了， 这个还得依赖于底层操作系统类型和用户所拥有的访问权限。 你通常不会去使用<code>shutil.copytree()</code> 函数来执行系统备份。 当处理文件名的时候，最好使用<code>os.path</code> 中的函数来确保最大的可移植性（特别是同时要适用于 Unix 和 Windows）。 例如：</p>
<pre><code>&gt;&gt;&gt; filename = '/Users/guido/programs/spam.py'
&gt;&gt;&gt; import os.path
&gt;&gt;&gt; os.path.basename(filename)
'spam.py'
&gt;&gt;&gt; os.path.dirname(filename)
'/Users/guido/programs'
&gt;&gt;&gt; os.path.split(filename)
('/Users/guido/programs', 'spam.py')
&gt;&gt;&gt; os.path.join('/new/dir', os.path.basename(filename))
'/new/dir/spam.py'
&gt;&gt;&gt; os.path.expanduser('~/guido/programs/spam.py')
'/Users/guido/programs/spam.py'
&gt;&gt;&gt;
</code></pre><p>使用<code>copytree()</code> 复制文件夹的一个棘手的问题是对于错误的处理。 例如，在复制过程中，函数可能会碰到损坏的符号链接，因为权限无法访问文件的问题等等。 为了解决这个问题，所有碰到的问题会被收集到一个列表中并打包为一个单独的异常，到了最后再抛出。 下面是一个例子：</p>
<pre><code>try:
    shutil.copytree(src, dst)
except shutil.Error as e:
    for src, dst, msg in e.args[0]:
         # src is source name
         # dst is destination name
         # msg is error message from exception
         print(dst, src, msg)
</code></pre><p>如果你提供关键字参数 <code>ignore_dangling_symlinks=True</code>， 这时候 <code>copytree()</code> 会忽略掉无效符号链接。</p>
<p>本节演示的这些函数都是最常见的。不过，<code>shutil</code> 还有更多的和复制数据相关的操作。 它的文档很值得一看，参考 <a href="https://docs.python.org/3/library/shutil.html" target="_blank">Python documentation</a></p>
<h1 id="138-创建和解压归档文件">13.8 创建和解压归档文件</h1>
<h2 id="问题">问题</h2>
<p>你需要创建或解压常见格式的归档文件（比如.tar, .tgz或.zip）</p>
<h2 id="解决方案">解决方案</h2>
<p><code>shutil</code> 模块拥有两个函数—— <code>make_archive()</code> 和 <code>unpack_archive()</code> 可派上用场。 例如：</p>
<pre><code>&gt;&gt;&gt; import shutil
&gt;&gt;&gt; shutil.unpack_archive('Python-3.3.0.tgz')

&gt;&gt;&gt; shutil.make_archive('py33','zip','Python-3.3.0')
'/Users/beazley/Downloads/py33.zip'
&gt;&gt;&gt;
</code></pre><p><code>make_archive()</code>的第二个参数是期望的输出格式。 可以使用 <code>get_archive_formats()</code> 获取所有支持的归档格式列表。例如：</p>
<pre><code>&gt;&gt;&gt; shutil.get_archive_formats()
[('bztar', "bzip2'ed tar-file"), ('gztar', "gzip'ed tar-file"),
 ('tar', 'uncompressed tar file'), ('zip', 'ZIP file')]
&gt;&gt;&gt;
</code></pre><h2 id="讨论">讨论</h2>
<p>Python 还有其他的模块可用来处理多种归档格式（比如 tarfile, zipfile, gzip, bz2）的底层细节。 不过，如果你仅仅只是要创建或提取某个归档，就没有必要使用底层库了。 可以直接使用<code>shutil</code>中的这些高层函数。</p>
<p>这些函数还有很多其他选项，用于日志打印、预检、文件权限等等。 参考<a href="https://docs.python.org/3/library/shutil.html" target="_blank"> shutil 文档</a></p>
<h1 id="139-通过文件名查找文件">13.9 通过文件名查找文件</h1>
<h2 id="问题">问题</h2>
<p>你需要写一个涉及到文件查找操作的脚本，比如对日志归档文件的重命名工具， 你不想在 Python 脚本中调用 shell，或者你要实现一些 shell 不能做的功能。</p>
<h2 id="解决方案">解决方案</h2>
<p>查找文件，可使用 <code>os.walk()</code> 函数，传一个顶级目录名给它。 下面是一个例子，查找特定的文件名并答应所有符合条件的文件全路径：</p>
<pre><code>#!/usr/bin/env python3.3
import os

def findfile(start, name):
    for relpath, dirs, files in os.walk(start):
        if name in files:
            full_path = os.path.join(start, relpath, name)
            print(os.path.normpath(os.path.abspath(full_path)))

if __name__ == '__main__':
    findfile(sys.argv[1], sys.argv[2])
</code></pre><p>保存脚本为文件 findfile.py，然后在命令行中执行它。 指定初始查找目录以及名字作为位置参数，如下：</p>
<h2 id="讨论">讨论</h2>
<p><code>os.walk()</code>方法为我们遍历目录树， 每次进入一个目录，它会返回一个三元组，包含相对于查找目录的相对路径，一个该目录下的目录名列表， 以及那个目录下面的文件名列表。</p>
<p>对于每个元组，只需检测一下目标文件名是否在文件列表中。如果是就使用 <code>os.path.join()</code> 合并路径。 为了避免奇怪的路径名比如 <code>././foo//bar</code> ，使用了另外两个函数来修正结果。 第一个是 <code>os.path.abspath()</code>,它接受一个路径，可能是相对路径，最后返回绝对路径。 第二个是<code>os.path.normpath()</code> ，用来返回正常路径，可以解决双斜杆、对目录的多重引用的问题等。</p>
<p>尽管这个脚本相对于 UNIX 平台上面的很多查找公交来讲要简单很多，它还有跨平台的优势。 并且，还能很轻松的加入其他的功能。 我们再演示一个例子，下面的函数打印所有最近被修改过的文件：</p>
<pre><code>#!/usr/bin/env python3.3

import os
import time

def modified_within(top, seconds):
    now = time.time()
    for path, dirs, files in os.walk(top):
        for name in files:
            fullpath = os.path.join(path, name)
            if os.path.exists(fullpath):
                mtime = os.path.getmtime(fullpath)
                if mtime &gt; (now - seconds):
                    print(fullpath)

if __name__ == '__main__':
    import sys
    if len(sys.argv) != 3:
        print('Usage: {} dir seconds'.format(sys.argv[0]))
        raise SystemExit(1)

    modified_within(sys.argv[1], float(sys.argv[2]))
</code></pre><p>在此函数的基础之上，使用 os,os.path,glob 等类似模块，你就能实现更加复杂的操作了。 可参考5.11小节和5.13小节等相关章节。</p>
<h1 id="1310-读取配置文件">13.10 读取配置文件</h1>
<h2 id="问题">问题</h2>
<p>怎样读取普通.ini 格式的配置文件？</p>
<h2 id="解决方案">解决方案</h2>
<p><code>configparser</code> 模块能被用来读取配置文件。例如，假设你有如下的配置文件：</p>
<pre><code>; config.ini
; Sample configuration file

[installation]
library=%(prefix)s/lib
include=%(prefix)s/include
bin=%(prefix)s/bin
prefix=/usr/local

# Setting related to debug configuration
[debug]
log_errors=true
show_warnings=False

[server]
port: 8080
nworkers: 32
pid-file=/tmp/spam.pid
root=/www/root
signature:
    =================================
    Brought to you by the Python Cookbook
    =================================
</code></pre><p>下面是一个读取和提取其中值的例子：</p>
<pre><code>&gt;&gt;&gt; from configparser import ConfigParser
&gt;&gt;&gt; cfg = ConfigParser()
&gt;&gt;&gt; cfg.read('config.ini')
['config.ini']
&gt;&gt;&gt; cfg.sections()
['installation', 'debug', 'server']
&gt;&gt;&gt; cfg.get('installation','library')
'/usr/local/lib'
&gt;&gt;&gt; cfg.getboolean('debug','log_errors')

True
&gt;&gt;&gt; cfg.getint('server','port')
8080
&gt;&gt;&gt; cfg.getint('server','nworkers')
32
&gt;&gt;&gt; print(cfg.get('server','signature'))

\=================================
Brought to you by the Python Cookbook
\=================================
&gt;&gt;&gt;
</code></pre><p>如果有需要，你还能修改配置并使用 <code>cfg.write()</code> 方法将其写回到文件中。例如：</p>
<pre><code>&gt;&gt;&gt; cfg.set('server','port','9000')
&gt;&gt;&gt; cfg.set('debug','log_errors','False')
&gt;&gt;&gt; import sys
&gt;&gt;&gt; cfg.write(sys.stdout)
</code></pre><pre><code>[installation]
library = %(prefix)s/lib
include = %(prefix)s/include
bin = %(prefix)s/bin
prefix = /usr/local

[debug]
log_errors = False
show_warnings = False

[server]
port = 9000
nworkers = 32
pid-file = /tmp/spam.pid
root = /www/root
signature =
          =================================
          Brought to you by the Python Cookbook
          =================================
&gt;&gt;&gt;
</code></pre><h2 id="讨论">讨论</h2>
<p>配置文件作为一种可读性很好的格式，非常适用于存储程序中的配置数据。 在每个配置文件中，配置数据会被分组（比如例子中的“installation”、 “debug” 和 “server”）。 每个分组在其中指定对应的各个变量值。</p>
<p>对于可实现同样功能的配置文件和 Python 源文件是有很大的不同的。 首先，配置文件的语法要更自由些，下面的赋值语句是等效的：</p>
<pre><code>prefix=/usr/local
prefix: /usr/local
</code></pre><p>配置文件中的名字是不区分大小写的。例如：</p>
<pre><code>&gt;&gt;&gt; cfg.get('installation','PREFIX')
'/usr/local'
&gt;&gt;&gt; cfg.get('installation','prefix')
'/usr/local'
&gt;&gt;&gt;
</code></pre><p>在解析值的时候，<code>getboolean()</code> 方法查找任何可行的值。例如下面都是等价的：</p>
<pre><code>log_errors = true
log_errors = TRUE
log_errors = Yes
log_errors = 1
</code></pre><p>或许配置文件和 Python 代码最大的不同在于，它并不是从上而下的顺序执行。 文件是安装一个整体被读取的。如果碰到了变量替换，它实际上已经被替换完成了。 例如，在下面这个配置中，<code>prefix</code>变量在使用它的变量之前后之后定义都是可以的：</p>
<pre><code>[installation]
library=%(prefix)s/lib
include=%(prefix)s/include
bin=%(prefix)s/bin
prefix=/usr/local
</code></pre><p><code>ConfigParser</code> 有个容易被忽视的特性是它能一次读取多个配置文件然后合并成一个配置。 例如，假设一个用户像下面这样构造了他们的配置文件：</p>
<pre><code>; ~/.config.ini
[installation]
prefix=/Users/beazley/test

[debug]
log_errors=False
</code></pre><p>读取这个文件，它就能跟之前的配置合并起来。如：</p>
<pre><code>&gt;&gt;&gt; # Previously read configuration
&gt;&gt;&gt; cfg.get('installation', 'prefix')
'/usr/local'

&gt;&gt;&gt; # Merge in user-specific configuration
&gt;&gt;&gt; import os
&gt;&gt;&gt; cfg.read(os.path.expanduser('~/.config.ini'))
['/Users/beazley/.config.ini']

&gt;&gt;&gt; cfg.get('installation', 'prefix')
'/Users/beazley/test'
&gt;&gt;&gt; cfg.get('installation', 'library')
'/Users/beazley/test/lib'
&gt;&gt;&gt; cfg.getboolean('debug', 'log_errors')
False
&gt;&gt;&gt;
</code></pre><p>仔细观察下 <code>prefix</code>变量是怎样覆盖其他相关变量的，比如 <code>library</code>的设定值。 产生这种结果的原因是变量的改写采取的是后发制人策略，以最后一个为准。 你可以像下面这样做试验：</p>
<pre><code>&gt;&gt;&gt; cfg.get('installation','library')
'/Users/beazley/test/lib'
&gt;&gt;&gt; cfg.set('installation','prefix','/tmp/dir')
&gt;&gt;&gt; cfg.get('installation','library')
'/tmp/dir/lib'
&gt;&gt;&gt;
</code></pre><p>最后还有很重要一点哟啊注意的是 Python 并不能支持.ini 文件在其他程序（比如 windows 应用程序）中的所有特性。 确保你已经参阅了 configparser 文档中的语法详情以及支持特性。</p>
<h1 id="1311-给简单脚本增加日志功能">13.11 给简单脚本增加日志功能</h1>
<h2 id="问题">问题</h2>
<p>你希望在脚本和程序中将诊断信息写入日志文件。</p>
<h2 id="解决方案">解决方案</h2>
<p>The easiest way to add logging to simple programs is to use the logging module. For example: 打印日志最简单方式是使用 <code>logging</code> 模块。例如：</p>
<pre><code>import logging

def main():
    # Configure the logging system
    logging.basicConfig(
        filename='app.log',
        level=logging.ERROR
    )

    # Variables (to make the calls that follow work)
    hostname = 'www.python.org'
    item = 'spam'
    filename = 'data.csv'
    mode = 'r'

    # Example logging calls (insert into your program)
    logging.critical('Host %s unknown', hostname)
    logging.error("Couldn't find %r", item)
    logging.warning('Feature is deprecated')
    logging.info('Opening file %r, mode=%r', filename, mode)
    logging.debug('Got here')

if __name__ == '__main__':
    main()
</code></pre><p>上面五个日志调用（critical(), error(), warning(), info(), debug()）以降序方式表示不同的严重级别。 <code>basicConfig()</code> 的 <code>level</code> 参数是一个过滤器。 所有级别低于此级别的日志消息都会被忽略掉。 每个 logging 操作的参数是一个消息字符串，后面再跟一个或多个参数。 构造最终的日志消息的时候我们使用了%操作符来格式化消息字符串。</p>
<p>运行这个程序后，在文件 <code>app.log</code>中的内容应该是下面这样：</p>
<pre><code>CRITICAL:root:Host www.python.org unknown
ERROR:root:Could not find 'spam'
</code></pre><p>If you want to change the output or level of output, you can change the parameters to the basicConfig() call. For example: 如果你想改变输出等级，你可以修改 <code>basicConfig()</code> 调用中的参数。例如：</p>
<pre><code>logging.basicConfig(
     filename='app.log',
     level=logging.WARNING,
     format='%(levelname)s:%(asctime)s:%(message)s')
</code></pre><p>最后输出变成如下：</p>
<pre><code>CRITICAL:2012-11-20 12:27:13,595:Host www.python.org unknown
ERROR:2012-11-20 12:27:13,595:Could not find 'spam'
WARNING:2012-11-20 12:27:13,595:Feature is deprecated
</code></pre><p>上面的日志配置都是硬编码到程序中的。如果你想使用配置文件， 可以像下面这样修改 <code>basicConfig()</code> 调用：</p>
<pre><code>import logging
import logging.config

def main():
    # Configure the logging system
    logging.config.fileConfig('logconfig.ini')
    ...
</code></pre><p>创建一个下面这样的文件，名字叫 <code>logconfig.ini</code>：</p>
<pre><code>[loggers]
keys=root

[handlers]
keys=defaultHandler

[formatters]
keys=defaultFormatter

[logger_root]
level=INFO
handlers=defaultHandler
qualname=root

[handler_defaultHandler]
class=FileHandler
formatter=defaultFormatter
args=('app.log', 'a')

[formatter_defaultFormatter]
format=%(levelname)s:%(name)s:%(message)s
</code></pre><p>如果你想修改配置，可以直接编辑文件 logconfig.ini 即可。</p>
<h2 id="讨论">讨论</h2>
<p>尽管对于 <code>logging</code> 模块而已有很多更高级的配置选项， 不过这里的方案对于简单的程序和脚本已经足够了。 只想在调用日志操作前先执行下 basicConfig()函数方法，你的程序就能产生日志输出了。</p>
<p>如果你想要你的日志消息写到标准错误中，而不是日志文件中，调用 basicConfig() 时不传文件名参数即可。例如：</p>
<pre><code>logging.basicConfig(level=logging.INFO)
</code></pre><p><code>basicConfig()</code> 在程序中只能被执行一次。如果你稍后想改变日志配置， 就需要先获取 <code>root logger</code>，然后直接修改它。例如：</p>
<pre><code>logging.getLogger().level = logging.DEBUG
</code></pre><p>需要强调的是本节只是演示了 <code>logging</code> 模块的一些基本用法。 它可以做更多更高级的定制。 关于日志定制化一个很好的资源是 <a href="https://docs.python.org/3/howto/logging-cookbook.html" target="_blank">Logging Cookbook</a></p>
<h1 id="1312-给函数库增加日志功能">13.12 给函数库增加日志功能</h1>
<h2 id="问题">问题</h2>
<p>你想给某个函数库增加日志功能，但是又不能影响到那些不使用日志功能的程序。</p>
<h2 id="解决方案">解决方案</h2>
<p>对于想要执行日志操作的函数库而已，你应该创建一个专属的 <code>logger</code> 对象，并且像下面这样初始化配置：</p>
<pre><code># somelib.py

import logging
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())

# Example function (for testing)
def func():
    log.critical('A Critical Error!')
    log.debug('A debug message')
</code></pre><p>使用这个配置，默认情况下不会打印日志。例如：</p>
<pre><code>&gt;&gt;&gt; import somelib
&gt;&gt;&gt; somelib.func()
&gt;&gt;&gt;
</code></pre><p>不过，如果配置过日志系统，那么日志消息打印就开始生效，例如：</p>
<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig()
&gt;&gt;&gt; somelib.func()
CRITICAL:somelib:A Critical Error!
&gt;&gt;&gt;
</code></pre><h2 id="讨论">讨论</h2>
<p>通常来讲，你不应该在函数库代码中自己配置日志系统，或者是已经假定有个已经存在的日志配置了。</p>
<p>调用 <code>getLogger(__name__)</code> 创建一个和调用模块同名的 logger 模块。 由于模块都是唯一的，因此创建的 logger 也将是唯一的。</p>
<p><code>log.addHandler(logging.NullHandler())</code> 操作将一个空处理器绑定到刚刚已经创建好的 logger 对象上。 一个空处理器默认会忽略调用所有的日志消息。 因此，如果使用该函数库的时候还没有配置日志，那么将不会有消息或警告出现。</p>
<p>还有一点就是对于各个函数库的日志配置可以是相互独立的，不影响其他库的日志配置。 例如，对于如下的代码：</p>
<pre><code>&gt;&gt;&gt; import logging
&gt;&gt;&gt; logging.basicConfig(level=logging.ERROR)

&gt;&gt;&gt; import somelib
&gt;&gt;&gt; somelib.func()
CRITICAL:somelib:A Critical Error!

&gt;&gt;&gt; # Change the logging level for 'somelib' only
&gt;&gt;&gt; logging.getLogger('somelib').level=logging.DEBUG
&gt;&gt;&gt; somelib.func()
CRITICAL:somelib:A Critical Error!
DEBUG:somelib:A debug message
&gt;&gt;&gt;
</code></pre><p>在这里，根日志被配置成仅仅输出 ERROR 或更高级别的消息。 不过 ，<code>somelib</code> 的日志级别被单独配置成可以输出 debug 级别的消息，它的优先级比全局配置高。 像这样更改单独模块的日志配置对于调试来讲是很方便的， 因为你无需去更改任何的全局日志配置——只需要修改你想要更多输出的模块的日志等级。</p>
<p><a href="https://docs.python.org/3/howto/logging.html" target="_blank">Logging HOWTO </a>详细介绍了如何配置日志模块和其他有用技巧，可以参阅下。</p>
<h1 id="1313-实现一个计时器">13.13 实现一个计时器</h1>
<h2 id="问题">问题</h2>
<p>你想记录程序执行多个任务所花费的时间</p>
<h2 id="解决方案">解决方案</h2>
<p><code>time</code>模块包含很多函数来执行跟时间有关的函数。 尽管如此，通常我们会在此基础之上构造一个更高级的接口来模拟一个计时器。例如：</p>
<pre><code>import time

class Timer:
    def __init__(self, func=time.perf_counter):
        self.elapsed = 0.0
        self._func = func
        self._start = None

    def start(self):
        if self._start is not None:
            raise RuntimeError('Already started')
        self._start = self._func()

    def stop(self):
        if self._start is None:
            raise RuntimeError('Not started')
        end = self._func()
        self.elapsed += end - self._start
        self._start = None

    def reset(self):
        self.elapsed = 0.0

    @property
    def running(self):
        return self._start is not None

    def __enter__(self):
        self.start()
        return self

    def __exit__(self, *args):
        self.stop()
</code></pre><p>这个类定义了一个可以被用户根据需要启动、停止和重置的计时器。 它会在 <code>elapsed</code> 属性中记录整个消耗时间。 下面是一个例子来演示怎样使用它：</p>
<pre><code>def countdown(n):
    while n &gt; 0:
        n -= 1

# Use 1: Explicit start/stop
t = Timer()
t.start()
countdown(1000000)
t.stop()
print(t.elapsed)

# Use 2: As a context manager
with t:
    countdown(1000000)

print(t.elapsed)

with Timer() as t2:
    countdown(1000000)
print(t2.elapsed)
</code></pre><h2 id="讨论">讨论</h2>
<p>本节提供了一个简单而实用的类来实现时间记录以及耗时计算。 同时也是对使用 with 语句以及上下文管理器协议的一个很好的演示。</p>
<p>在计时中要考虑一个底层的时间函数问题。一般来说， 使用<code>time.time()</code> 或 <code>time.clock()</code> 计算的时间精度因操作系统的不同会有所不同。 而使用 <code>time.perf_counter()</code> 函数可以确保使用系统上面最精确的计时器。</p>
<p>上述代码中由 <code>Timer</code> 类记录的时间是钟表时间，并包含了所有休眠时间。 如果你只想计算该进程所花费的 CPU 时间，应该使用 <code>time.process_time()</code> 来代替：</p>
<pre><code>t = Timer(time.process_time)
with t:
    countdown(1000000)
print(t.elapsed)
</code></pre><p><code>time.perf_counter()</code>和 <code>time.process_time()</code> 都会返回小数形式的秒数时间。 实际的时间值没有任何意义，为了得到有意义的结果，你得执行两次函数然后计算它们的差值。</p>
<p>更多关于计时和性能分析的例子请参考14.13小节。</p>
<h1 id="1314-限制内存和-cpu-的使用量">13.14 限制内存和 CPU 的使用量</h1>
<h2 id="问题">问题</h2>
<p>你想对在 Unix 系统上面运行的程序设置内存或 CPU 的使用限制。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>resource</code> 模块能同时执行这两个任务。例如，要限制 CPU 时间，可以像下面这样做：</p>
<pre><code>import signal
import resource
import os

def time_exceeded(signo, frame):
    print("Time's up!")
    raise SystemExit(1)

def set_max_runtime(seconds):
    # Install the signal handler and set a resource limit
    soft, hard = resource.getrlimit(resource.RLIMIT_CPU)
    resource.setrlimit(resource.RLIMIT_CPU, (seconds, hard))
    signal.signal(signal.SIGXCPU, time_exceeded)

if __name__ == '__main__':
    set_max_runtime(15)
    while True:
        pass
</code></pre><p>程序运行时，<code>SIGXCPU</code> 信号在时间过期时被生成，然后执行清理并退出。</p>
<p>要限制内存使用，设置可使用的总内存值即可，如下：</p>
<pre><code>import resource

def limit_memory(maxsize):
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (maxsize, hard))
</code></pre><p>像这样设置了内存限制后，程序运行到没有多余内存时会抛出 <code>MemoryError</code> 异常。</p>
<h2 id="讨论">讨论</h2>
<p>在本节例子中，<code>setrlimit()</code> 函数被用来设置特定资源上面的软限制和硬限制。 软限制是一个值，当超过这个值的时候操作系统通常会发送一个信号来限制或通知该进程。 硬限制是用来指定软限制能设定的最大值。通常来讲，这个由系统管理员通过设置系统级参数来决定。 尽管硬限制可以改小一点，但是最好不要使用用户进程去修改。</p>
<p><code>setrlimit()</code> 函数还能被用来设置子进程数量、打开文件数以及类似系统资源的限制。 更多详情请参考 <code>resource</code> 模块的文档。</p>
<p>需要注意的是本节内容只能适用于 Unix 系统，并且不保证所有系统都能如期工作。 比如我们在测试的时候，它能在 Linux 上面正常运行，但是在 OS X 上却不能。</p>
<h1 id="1315-启动一个-web-浏览器">13.15 启动一个 WEB 浏览器</h1>
<h2 id="问题">问题</h2>
<p>你想通过脚本启动浏览器并打开指定的 URL 网页</p>
<h2 id="解决方案">解决方案</h2>
<p><code>webbrowser</code> 模块能被用来启动一个浏览器，并且与平台无关。例如：</p>
<pre><code>&gt;&gt;&gt; import webbrowser
&gt;&gt;&gt; webbrowser.open('http://www.python.org')
True
&gt;&gt;&gt;
</code></pre><p>它会使用默认浏览器打开指定网页。如果你还想对网页打开方式做更多控制，还可以使用下面这些函数：</p>
<pre><code>&gt;&gt;&gt; # Open the page in a new browser window
&gt;&gt;&gt; webbrowser.open_new('http://www.python.org')
True
&gt;&gt;&gt;

&gt;&gt;&gt; # Open the page in a new browser tab
&gt;&gt;&gt; webbrowser.open_new_tab('http://www.python.org')
True
&gt;&gt;&gt;
</code></pre><p>这样就可以打开一个新的浏览器窗口或者标签，只要浏览器支持就行。</p>
<p>如果你想指定浏览器类型，可以使用<code>webbrowser.get()</code> 函数来指定某个特定浏览器。例如：</p>
<pre><code>&gt;&gt;&gt; c = webbrowser.get('firefox')
&gt;&gt;&gt; c.open('http://www.python.org')
True
&gt;&gt;&gt; c.open_new_tab('http://docs.python.org')
True
&gt;&gt;&gt;
</code></pre><p>对于支持的浏览器名称列表可查阅<a href="http://docs.python.org/3/library/webbrowser.html" target="_blank"> Python 文档</a></p>
<h2 id="讨论">讨论</h2>
<p>在脚本中打开浏览器有时候会很有用。例如，某个脚本执行某个服务器发布任务， 你想快速打开一个浏览器来确保它已经正常运行了。 或者是某个程序以 HTML 网页格式输出数据，你想打开浏览器查看结果。 不管是上面哪种情况，使用<code>webbrowser</code> 模块都是一个简单实用的解决方案。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="concurrent-programming.html" class="navigation navigation-prev " aria-label="Previous page: 第十二章：并发编程">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="testing-debugging-and-exception.html" class="navigation navigation-next " aria-label="Next page: 第十四章：测试、调试和异常">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第十三章：脚本编程与系统管理","level":"1.14","depth":1,"next":{"title":"第十四章：测试、调试和异常","level":"1.15","depth":1,"path":"testing-debugging-and-exception.md","ref":"testing-debugging-and-exception.md","articles":[]},"previous":{"title":"第十二章：并发编程","level":"1.13","depth":1,"path":"concurrent-programming.md","ref":"concurrent-programming.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"scripting-and-systems-management.md","mtime":"2025-01-05T10:56:44.746Z","type":"markdown"},"gitbook":{"version":"6.0.2","time":"2025-01-05T12:14:20.822Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

