
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第六章：数据编码和处理 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="functions.html" />
    
    
    <link rel="prev" href="files-and-io.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="data-structures-and-algorithms.html">
            
                <a href="data-structures-and-algorithms.html">
            
                    
                    第一章：数据结构和算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="string-and-text.html">
            
                <a href="string-and-text.html">
            
                    
                    第二章：字符串和文本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="digital-date-and-time.html">
            
                <a href="digital-date-and-time.html">
            
                    
                    第三章：数字日期和时间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="iterators-and-generators.html">
            
                <a href="iterators-and-generators.html">
            
                    
                    第四章：迭代器与生成器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="files-and-io.html">
            
                <a href="files-and-io.html">
            
                    
                    第五章：文件与 IO
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7" data-path="coding-and-processing-data.html">
            
                <a href="coding-and-processing-data.html">
            
                    
                    第六章：数据编码和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    第七章：函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="classes-and-objects.html">
            
                <a href="classes-and-objects.html">
            
                    
                    第八章：类与对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="metaprogramming.html">
            
                <a href="metaprogramming.html">
            
                    
                    第九章：元编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="module-and-pack.html">
            
                <a href="module-and-pack.html">
            
                    
                    第十章：模块与包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="network-and-web-programming.html">
            
                <a href="network-and-web-programming.html">
            
                    
                    第十一章：网络与 Web 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="concurrent-programming.html">
            
                <a href="concurrent-programming.html">
            
                    
                    第十二章：并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="scripting-and-systems-management.html">
            
                <a href="scripting-and-systems-management.html">
            
                    
                    第十三章：脚本编程与系统管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="testing-debugging-and-exception.html">
            
                <a href="testing-debugging-and-exception.html">
            
                    
                    第十四章：测试、调试和异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="c-language-extensions.html">
            
                <a href="c-language-extensions.html">
            
                    
                    第十五章：C 语言扩展
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第六章：数据编码和处理</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第六章：数据编码和处理">第六章：数据编码和处理</h1>
<p>这一章主要讨论使用 Python 处理各种不同方式编码的数据，比如 CSV 文件，JSON，XML 和二进制包装记录。 和数据结构那一章不同的是，这章不会讨论特殊的算法问题，而是关注于怎样获取和存储这些格式的数据。</p>
<h1 id="61-读写-csv-数据">6.1 读写 CSV 数据</h1>
<h2 id="问题">问题</h2>
<p>你想读写一个 CSV 格式的文件。</p>
<h2 id="解决方案">解决方案</h2>
<p>对于大多数的 CSV 格式的数据读写问题，都可以使用 <code>csv</code> 库。 例如：假设你在一个名叫 stocks.csv 文件中有一些股票市场数据，就像这样：</p>
<pre><code class="lang-python">Symbol,Price,Date,Time,Change,Volume
<span class="hljs-string">"AA"</span>,<span class="hljs-number">39.48</span>,<span class="hljs-string">"6/11/2007"</span>,<span class="hljs-string">"9:36am"</span>,-<span class="hljs-number">0.18</span>,<span class="hljs-number">181800</span>
<span class="hljs-string">"AIG"</span>,<span class="hljs-number">71.38</span>,<span class="hljs-string">"6/11/2007"</span>,<span class="hljs-string">"9:36am"</span>,-<span class="hljs-number">0.15</span>,<span class="hljs-number">195500</span>
<span class="hljs-string">"AXP"</span>,<span class="hljs-number">62.58</span>,<span class="hljs-string">"6/11/2007"</span>,<span class="hljs-string">"9:36am"</span>,-<span class="hljs-number">0.46</span>,<span class="hljs-number">935000</span>
<span class="hljs-string">"BA"</span>,<span class="hljs-number">98.31</span>,<span class="hljs-string">"6/11/2007"</span>,<span class="hljs-string">"9:36am"</span>,+<span class="hljs-number">0.12</span>,<span class="hljs-number">104800</span>
<span class="hljs-string">"C"</span>,<span class="hljs-number">53.08</span>,<span class="hljs-string">"6/11/2007"</span>,<span class="hljs-string">"9:36am"</span>,-<span class="hljs-number">0.25</span>,<span class="hljs-number">360900</span>
<span class="hljs-string">"CAT"</span>,<span class="hljs-number">78.29</span>,<span class="hljs-string">"6/11/2007"</span>,<span class="hljs-string">"9:36am"</span>,-<span class="hljs-number">0.23</span>,<span class="hljs-number">225400</span>
</code></pre>
<p>下面向你展示如何将这些数据读取为一个元组的序列：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> csv
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stocks.csv'</span>) <span class="hljs-keyword">as</span> f:
    f_csv = csv.reader(f)
    headers = <span class="hljs-built_in">next</span>(f_csv)
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> f_csv:
        <span class="hljs-comment"># Process row</span>
        ...
</code></pre>
<p>在上面的代码中，<code>row</code> 会是一个元组。因此，为了访问某个字段，你需要使用下标，如 <code>row[0]</code>访问 Symbol， <code>row[4]</code> 访问 Change。</p>
<p>由于这种下标访问通常会引起混淆，你可以考虑使用命名元组。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stock.csv'</span>) <span class="hljs-keyword">as</span> f:
    f_csv = csv.reader(f)
    headings = <span class="hljs-built_in">next</span>(f_csv)
    Row = namedtuple(<span class="hljs-string">'Row'</span>, headings)
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> f_csv:
        row = Row(*r)
        <span class="hljs-comment"># Process row</span>
        ...
</code></pre>
<p>它允许你使用列名如 <code>row.Symbol</code> 和<code>row.Change</code>代替下标访问。 需要注意的是这个只有在列名是合法的 Python 标识符的时候才生效。如果不是的话， 你可能需要修改下原始的列名(如将非标识符字符替换成下划线之类的)。</p>
<p>另外一个选择就是将数据读取到一个字典序列中去。可以这样做：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> csv
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stocks.csv'</span>) <span class="hljs-keyword">as</span> f:
    f_csv = csv.DictReader(f)
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> f_csv:
        <span class="hljs-comment"># process row</span>
        ...
</code></pre>
<p>在这个版本中，你可以使用列名去访问每一行的数据了。比如，<code>row['Symbol']</code> 或者 <code>row['Change']</code>。</p>
<p>为了写入 CSV 数据，你仍然可以使用 csv 模块，不过这时候先创建一个 <code>writer</code> 对象。例如:</p>
<pre><code class="lang-python">headers = [<span class="hljs-string">'Symbol'</span>,<span class="hljs-string">'Price'</span>,<span class="hljs-string">'Date'</span>,<span class="hljs-string">'Time'</span>,<span class="hljs-string">'Change'</span>,<span class="hljs-string">'Volume'</span>]
rows = [(<span class="hljs-string">'AA'</span>, <span class="hljs-number">39.48</span>, <span class="hljs-string">'6/11/2007'</span>, <span class="hljs-string">'9:36am'</span>, -<span class="hljs-number">0.18</span>, <span class="hljs-number">181800</span>),
         (<span class="hljs-string">'AIG'</span>, <span class="hljs-number">71.38</span>, <span class="hljs-string">'6/11/2007'</span>, <span class="hljs-string">'9:36am'</span>, -<span class="hljs-number">0.15</span>, <span class="hljs-number">195500</span>),
         (<span class="hljs-string">'AXP'</span>, <span class="hljs-number">62.58</span>, <span class="hljs-string">'6/11/2007'</span>, <span class="hljs-string">'9:36am'</span>, -<span class="hljs-number">0.46</span>, <span class="hljs-number">935000</span>),
       ]

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stocks.csv'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
    f_csv = csv.writer(f)
    f_csv.writerow(headers)
    f_csv.writerows(rows)
</code></pre>
<p>如果你有一个字典序列的数据，可以像这样做：</p>
<pre><code class="lang-python">headers = [<span class="hljs-string">'Symbol'</span>, <span class="hljs-string">'Price'</span>, <span class="hljs-string">'Date'</span>, <span class="hljs-string">'Time'</span>, <span class="hljs-string">'Change'</span>, <span class="hljs-string">'Volume'</span>]
rows = [{<span class="hljs-string">'Symbol'</span>:<span class="hljs-string">'AA'</span>, <span class="hljs-string">'Price'</span>:<span class="hljs-number">39.48</span>, <span class="hljs-string">'Date'</span>:<span class="hljs-string">'6/11/2007'</span>,
        <span class="hljs-string">'Time'</span>:<span class="hljs-string">'9:36am'</span>, <span class="hljs-string">'Change'</span>:-<span class="hljs-number">0.18</span>, <span class="hljs-string">'Volume'</span>:<span class="hljs-number">181800</span>},
        {<span class="hljs-string">'Symbol'</span>:<span class="hljs-string">'AIG'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-number">71.38</span>, <span class="hljs-string">'Date'</span>:<span class="hljs-string">'6/11/2007'</span>,
        <span class="hljs-string">'Time'</span>:<span class="hljs-string">'9:36am'</span>, <span class="hljs-string">'Change'</span>:-<span class="hljs-number">0.15</span>, <span class="hljs-string">'Volume'</span>: <span class="hljs-number">195500</span>},
        {<span class="hljs-string">'Symbol'</span>:<span class="hljs-string">'AXP'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-number">62.58</span>, <span class="hljs-string">'Date'</span>:<span class="hljs-string">'6/11/2007'</span>,
        <span class="hljs-string">'Time'</span>:<span class="hljs-string">'9:36am'</span>, <span class="hljs-string">'Change'</span>:-<span class="hljs-number">0.46</span>, <span class="hljs-string">'Volume'</span>: <span class="hljs-number">935000</span>},
        ]

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stocks.csv'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
    f_csv = csv.DictWriter(f, headers)
    f_csv.writeheader()
    f_csv.writerows(rows)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>你应该总是优先选择 csv 模块分割或解析 CSV 数据。例如，你可能会像编写类似下面这样的代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stocks.csv'</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
    row = line.split(<span class="hljs-string">','</span>)
    <span class="hljs-comment"># process row</span>
    ...
</code></pre>
<p>使用这种方式的一个缺点就是你仍然需要去处理一些棘手的细节问题。 比如，如果某些字段值被引号包围，你不得不去除这些引号。 另外，如果一个被引号包围的字段碰巧含有一个逗号，那么程序就会因为产生一个错误大小的行而出错。</p>
<p>默认情况下，<code>csv</code> 库可识别 Microsoft Excel 所使用的 CSV 编码规则。 这或许也是最常见的形式，并且也会给你带来最好的兼容性。 然而，如果你查看<code>csv</code>的文档，就会发现有很多种方法将它应用到其他编码格式上(如修改分割字符等)。 例如，如果你想读取以 tab 分割的数据，可以这样做：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example of reading tab-separated values</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stock.tsv'</span>) <span class="hljs-keyword">as</span> f:
    f_tsv = csv.reader(f, delimiter=<span class="hljs-string">'\t'</span>)
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> f_tsv:
        <span class="hljs-comment"># Process row</span>
        ...
</code></pre>
<p>如果你正在读取 CSV 数据并将它们转换为命名元组，需要注意对列名进行合法性认证。 例如，一个 CSV 格式文件有一个包含非法标识符的列头行，类似下面这样：</p>
<p>这样最终会导致在创建一个命名元组时产生一个 <code>ValueError</code> 异常而失败。 为了解决这问题，你可能不得不先去修正列标题。 例如，可以像下面这样在非法标识符上使用一个正则表达式替换：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> re
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stock.csv'</span>) <span class="hljs-keyword">as</span> f:
    f_csv = csv.reader(f)
    headers = [ re.sub(<span class="hljs-string">'[^a-zA-Z_]'</span>, <span class="hljs-string">'_'</span>, h) <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">next</span>(f_csv) ]
    Row = namedtuple(<span class="hljs-string">'Row'</span>, headers)
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> f_csv:
        row = Row(*r)
        <span class="hljs-comment"># Process row</span>
        ...
</code></pre>
<p>还有重要的一点需要强调的是，csv 产生的数据都是字符串类型的，它不会做任何其他类型的转换。 如果你需要做这样的类型转换，你必须自己手动去实现。 下面是一个在 CSV 数据上执行其他类型转换的例子：</p>
<pre><code class="lang-python">col_types = [<span class="hljs-built_in">str</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">int</span>]
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stocks.csv'</span>) <span class="hljs-keyword">as</span> f:
    f_csv = csv.reader(f)
    headers = <span class="hljs-built_in">next</span>(f_csv)
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> f_csv:
        <span class="hljs-comment"># Apply conversions to the row items</span>
        row = <span class="hljs-built_in">tuple</span>(convert(value) <span class="hljs-keyword">for</span> convert, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(col_types, row))
        ...
</code></pre>
<p>另外，下面是一个转换字典中特定字段的例子：</p>
<pre><code class="lang-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">'Reading as dicts with type conversion'</span>)
field_types = [ (<span class="hljs-string">'Price'</span>, <span class="hljs-built_in">float</span>),
                (<span class="hljs-string">'Change'</span>, <span class="hljs-built_in">float</span>),
                (<span class="hljs-string">'Volume'</span>, <span class="hljs-built_in">int</span>) ]

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'stocks.csv'</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> csv.DictReader(f):
        row.update((key, conversion(row[key]))
                <span class="hljs-keyword">for</span> key, conversion <span class="hljs-keyword">in</span> field_types)
        <span class="hljs-built_in">print</span>(row)
</code></pre>
<p>通常来讲，你可能并不想过多去考虑这些转换问题。 在实际情况中，CSV 文件都或多或少有些缺失的数据，被破坏的数据以及其它一些让转换失败的问题。 因此，除非你的数据确实有保障是准确无误的，否则你必须考虑这些问题(你可能需要增加合适的错误处理机制)。</p>
<p>最后，如果你读取 CSV 数据的目的是做数据分析和统计的话， 你可能需要看一看 <code>Pandas</code> 包。<code>Pandas</code> 包含了一个非常方便的函数叫 <code>pandas.read_csv()</code> ， 它可以加载 CSV 数据到一个 <code>DataFrame</code> 对象中去。 然后利用这个对象你就可以生成各种形式的统计、过滤数据以及执行其他高级操作了。 在6.13小节中会有这样一个例子。</p>
<h1 id="62-读写-json-数据">6.2 读写 JSON 数据</h1>
<h2 id="问题">问题</h2>
<p>你想读写 JSON(JavaScript Object Notation)编码格式的数据。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>json</code>模块提供了一种很简单的方式来编码和解码 JSON 数据。 其中两个主要的函数是 <code>json.dumps()</code> 和 <code>json.loads()</code>， 要比其他序列化函数库如 pickle 的接口少得多。 下面演示如何将一个 Python 数据结构转换为 JSON：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> json

data = {
    <span class="hljs-string">'name'</span> : <span class="hljs-string">'ACME'</span>,
    <span class="hljs-string">'shares'</span> : <span class="hljs-number">100</span>,
    <span class="hljs-string">'price'</span> : <span class="hljs-number">542.23</span>
}

json_str = json.dumps(data)
</code></pre>
<p>下面演示如何将一个 JSON 编码的字符串转换回一个 Python 数据结构：</p>
<pre><code class="lang-python">data = json.loads(json_str)
</code></pre>
<p>如果你要处理的是文件而不是字符串，你可以使用 <code>json.dump()</code>和<code>json.load()</code> 来编码和解码 JSON 数据。例如：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Writing JSON data</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.json'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
    json.dump(data, f)

<span class="hljs-comment"># Reading data back</span>
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.json'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
    data = json.load(f)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>JSON 编码支持的基本数据类型为 <code>None</code> ，<code>bool</code> ，<code>int</code> ， <code>float</code> 和 <code>str</code>， 以及包含这些类型数据的 lists，tuples 和 dictionaries。 对于 dictionaries，keys 需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。 为了遵循 JSON 规范，你应该只编码 Python 的 lists 和 dictionaries。 而且，在 web 应用程序中，顶层对象被编码为一个字典是一个标准做法。</p>
<p>JSON 编码的格式对于 Python 语法而已几乎是完全一样的，除了一些小的差异之外。 比如，True 会被映射为 true，False 被映射为 false，而 None 会被映射为 null。 下面是一个例子，演示了编码后的字符串效果：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>json.dumps(<span class="hljs-literal">False</span>)
<span class="hljs-string">'false'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>d = {<span class="hljs-string">'a'</span>: <span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    <span class="hljs-string">'b'</span>: <span class="hljs-string">'Hello'</span>,
<span class="hljs-meta">... </span>    <span class="hljs-string">'c'</span>: <span class="hljs-literal">None</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>json.dumps(d)
<span class="hljs-string">'{"b": "Hello", "c": null, "a": true}'</span>
&gt;&gt;&gt;
</code></pre>
<p>如果你试着去检查 JSON 解码后的数据，你通常很难通过简单的打印来确定它的结构， 特别是当数据的嵌套结构层次很深或者包含大量的字段时。 为了解决这个问题，可以考虑使用 pprint 模块的 <code>pprint()</code>函数来代替普通的 <code>print()</code>函数。 它会按照 key 的字母顺序并以一种更加美观的方式输出。 下面是一个演示如何漂亮的打印输出 Twitter 上搜索结果的例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json
<span class="hljs-meta">&gt;&gt;&gt; </span>u = urlopen(<span class="hljs-string">'http://search.twitter.com/search.json?q=python&amp;rpp=5'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>resp = json.loads(u.read().decode(<span class="hljs-string">'utf-8'</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint
<span class="hljs-meta">&gt;&gt;&gt; </span>pprint(resp)
{<span class="hljs-string">'completed_in'</span>: <span class="hljs-number">0.074</span>,
<span class="hljs-string">'max_id'</span>: <span class="hljs-number">264043230692245504</span>,
<span class="hljs-string">'max_id_str'</span>: <span class="hljs-string">'264043230692245504'</span>,
<span class="hljs-string">'next_page'</span>: <span class="hljs-string">'?page=2&amp;max_id=264043230692245504&amp;q=python&amp;rpp=5'</span>,
<span class="hljs-string">'page'</span>: <span class="hljs-number">1</span>,
<span class="hljs-string">'query'</span>: <span class="hljs-string">'python'</span>,
<span class="hljs-string">'refresh_url'</span>: <span class="hljs-string">'?since_id=264043230692245504&amp;q=python'</span>,
<span class="hljs-string">'results'</span>: [{<span class="hljs-string">'created_at'</span>: <span class="hljs-string">'Thu, 01 Nov 2012 16:36:26 +0000'</span>,
            <span class="hljs-string">'from_user'</span>: ...
            },
            {<span class="hljs-string">'created_at'</span>: <span class="hljs-string">'Thu, 01 Nov 2012 16:36:14 +0000'</span>,
            <span class="hljs-string">'from_user'</span>: ...
            },
            {<span class="hljs-string">'created_at'</span>: <span class="hljs-string">'Thu, 01 Nov 2012 16:36:13 +0000'</span>,
            <span class="hljs-string">'from_user'</span>: ...
            },
            {<span class="hljs-string">'created_at'</span>: <span class="hljs-string">'Thu, 01 Nov 2012 16:36:07 +0000'</span>,
            <span class="hljs-string">'from_user'</span>: ...
            }
            {<span class="hljs-string">'created_at'</span>: <span class="hljs-string">'Thu, 01 Nov 2012 16:36:04 +0000'</span>,
            <span class="hljs-string">'from_user'</span>: ...
            }],
<span class="hljs-string">'results_per_page'</span>: <span class="hljs-number">5</span>,
<span class="hljs-string">'since_id'</span>: <span class="hljs-number">0</span>,
<span class="hljs-string">'since_id_str'</span>: <span class="hljs-string">'0'</span>}
&gt;&gt;&gt;
</code></pre>
<p>一般来讲，JSON 解码会根据提供的数据创建 dicts 或 lists。 如果你想要创建其他类型的对象，可以给 <code>json.loads()</code>传递 object_pairs_hook 或 object_hook 参数。 例如，下面是演示如何解码 JSON 数据并在一个 OrderedDict 中保留其顺序的例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'{"name": "ACME", "shares": 50, "price": 490.1}'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict
<span class="hljs-meta">&gt;&gt;&gt; </span>data = json.loads(s, object_pairs_hook=OrderedDict)
<span class="hljs-meta">&gt;&gt;&gt; </span>data
OrderedDict([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'ACME'</span>), (<span class="hljs-string">'shares'</span>, <span class="hljs-number">50</span>), (<span class="hljs-string">'price'</span>, <span class="hljs-number">490.1</span>)])
&gt;&gt;&gt;
</code></pre>
<p>下面是如何将一个 JSON 字典转换为一个 Python 对象例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">JSONObject</span>:
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, d</span>):
<span class="hljs-meta">... </span>        <span class="hljs-variable language_">self</span>.__dict__ = d
...
&gt;&gt;&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>data = json.loads(s, object_hook=JSONObject)
<span class="hljs-meta">&gt;&gt;&gt; </span>data.name
<span class="hljs-string">'ACME'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>data.shares
<span class="hljs-number">50</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>data.price
<span class="hljs-number">490.1</span>
&gt;&gt;&gt;
</code></pre>
<p>最后一个例子中，JSON 解码后的字典作为一个单个参数传递给 <code>__init__()</code> 。 然后，你就可以随心所欲的使用它了，比如作为一个实例字典来直接使用它。</p>
<p>在编码 JSON 的时候，还有一些选项很有用。 如果你想获得漂亮的格式化字符串后输出，可以使用 <code>json.dumps()</code>的 indent 参数。 它会使得输出和 pprint()函数效果类似。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(json.dumps(data))
{<span class="hljs-string">"price"</span>: <span class="hljs-number">542.23</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"ACME"</span>, <span class="hljs-string">"shares"</span>: <span class="hljs-number">100</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(json.dumps(data, indent=<span class="hljs-number">4</span>))
{
    <span class="hljs-string">"price"</span>: <span class="hljs-number">542.23</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"ACME"</span>,
    <span class="hljs-string">"shares"</span>: <span class="hljs-number">100</span>
}
&gt;&gt;&gt;
</code></pre>
<p>对象实例通常并不是 JSON 可序列化的。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):
<span class="hljs-meta">... </span>        <span class="hljs-variable language_">self</span>.x = x
<span class="hljs-meta">... </span>        <span class="hljs-variable language_">self</span>.y = y
...
<span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>json.dumps(p)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"/usr/local/lib/python3.3/json/__init__.py"</span>, line <span class="hljs-number">226</span>, <span class="hljs-keyword">in</span> dumps
        <span class="hljs-keyword">return</span> _default_encoder.encode(obj)
    File <span class="hljs-string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="hljs-number">187</span>, <span class="hljs-keyword">in</span> encode
        chunks = <span class="hljs-variable language_">self</span>.iterencode(o, _one_shot=<span class="hljs-literal">True</span>)
    File <span class="hljs-string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="hljs-number">245</span>, <span class="hljs-keyword">in</span> iterencode
        <span class="hljs-keyword">return</span> _iterencode(o, <span class="hljs-number">0</span>)
    File <span class="hljs-string">"/usr/local/lib/python3.3/json/encoder.py"</span>, line <span class="hljs-number">169</span>, <span class="hljs-keyword">in</span> default
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-built_in">repr</span>(o) + <span class="hljs-string">" is not JSON serializable"</span>)
TypeError: &lt;__main__.Point <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006f2650</span>&gt; <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> JSON serializable
&gt;&gt;&gt;
</code></pre>
<p>如果你想序列化对象实例，你可以提供一个函数，它的输入是一个实例，返回一个可序列化的字典。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize_instance</span>(<span class="hljs-params">obj</span>):
    d = { <span class="hljs-string">'__classname__'</span> : <span class="hljs-built_in">type</span>(obj).__name__ }
    d.update(<span class="hljs-built_in">vars</span>(obj))
    <span class="hljs-keyword">return</span> d
</code></pre>
<p>如果你想反过来获取这个实例，可以这样做：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Dictionary mapping names to known classes</span>
classes = {
    <span class="hljs-string">'Point'</span> : Point
}

<span class="hljs-keyword">def</span> <span class="hljs-title function_">unserialize_object</span>(<span class="hljs-params">d</span>):
    clsname = d.pop(<span class="hljs-string">'__classname__'</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> clsname:
        cls = classes[clsname]
        obj = cls.__new__(cls) <span class="hljs-comment"># Make instance without calling __init__</span>
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():
            <span class="hljs-built_in">setattr</span>(obj, key, value)
            <span class="hljs-keyword">return</span> obj
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> d
</code></pre>
<p>下面是如何使用这些函数的例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s = json.dumps(p, default=serialize_instance)
<span class="hljs-meta">&gt;&gt;&gt; </span>s
<span class="hljs-string">'{"__classname__": "Point", "y": 3, "x": 2}'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a = json.loads(s, object_hook=unserialize_object)
<span class="hljs-meta">&gt;&gt;&gt; </span>a
&lt;__main__.Point <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1017577d0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>a.x
<span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.y
<span class="hljs-number">3</span>
&gt;&gt;&gt;
</code></pre>
<p><code>json</code>模块还有很多其他选项来控制更低级别的数字、特殊值如 NaN 等的解析。 可以参考官方文档获取更多细节。</p>
<h1 id="63-解析简单的-xml-数据">6.3 解析简单的 XML 数据</h1>
<h2 id="问题">问题</h2>
<p>你想从一个简单的 XML 文档中提取数据。</p>
<h2 id="解决方案">解决方案</h2>
<p>可以使用 <code>xml.etree.ElementTree</code> 模块从简单的XML文档中提取数据。 为了演示，假设你想解析 Planet Python 上的 RSS 源。下面是相应的代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen
<span class="hljs-keyword">from</span> xml.etree.ElementTree <span class="hljs-keyword">import</span> parse

<span class="hljs-comment"># Download the RSS feed and parse it</span>
u = urlopen(<span class="hljs-string">'http://planet.python.org/rss20.xml'</span>)
doc = parse(u)

<span class="hljs-comment"># Extract and output tags of interest</span>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> doc.iterfind(<span class="hljs-string">'channel/item'</span>):
    title = item.findtext(<span class="hljs-string">'title'</span>)
    date = item.findtext(<span class="hljs-string">'pubDate'</span>)
    link = item.findtext(<span class="hljs-string">'link'</span>)

    <span class="hljs-built_in">print</span>(title)
    <span class="hljs-built_in">print</span>(date)
    <span class="hljs-built_in">print</span>(link)
    <span class="hljs-built_in">print</span>()
</code></pre>
<p>运行上面的代码，输出结果类似这样：</p>
<pre><code class="lang-python">Steve Holden: Python <span class="hljs-keyword">for</span> Data Analysis
Mon, <span class="hljs-number">19</span> Nov <span class="hljs-number">2012</span> 02:<span class="hljs-number">13</span>:<span class="hljs-number">51</span> +<span class="hljs-number">0000</span>
http://holdenweb.blogspot.com/<span class="hljs-number">2012</span>/<span class="hljs-number">11</span>/python-<span class="hljs-keyword">for</span>-data-analysis.html

Vasudev Ram: The Python Data model (<span class="hljs-keyword">for</span> v2 <span class="hljs-keyword">and</span> v3)
Sun, <span class="hljs-number">18</span> Nov <span class="hljs-number">2012</span> <span class="hljs-number">22</span>:06:<span class="hljs-number">47</span> +<span class="hljs-number">0000</span>
http://jugad2.blogspot.com/<span class="hljs-number">2012</span>/<span class="hljs-number">11</span>/the-python-data-model.html

Python Diary: Been playing around <span class="hljs-keyword">with</span> Object Databases
Sun, <span class="hljs-number">18</span> Nov <span class="hljs-number">2012</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29</span> +<span class="hljs-number">0000</span>
http://www.pythondiary.com/blog/Nov<span class="hljs-number">.18</span>,<span class="hljs-number">2012</span>/been-...-<span class="hljs-built_in">object</span>-databases.html

Vasudev Ram: Wakari, Scientific Python <span class="hljs-keyword">in</span> the cloud
Sun, <span class="hljs-number">18</span> Nov <span class="hljs-number">2012</span> <span class="hljs-number">20</span>:<span class="hljs-number">19</span>:<span class="hljs-number">41</span> +<span class="hljs-number">0000</span>
http://jugad2.blogspot.com/<span class="hljs-number">2012</span>/<span class="hljs-number">11</span>/wakari-scientific-python-<span class="hljs-keyword">in</span>-cloud.html

Jesse Jiryu Davis: Toro: synchronization primitives <span class="hljs-keyword">for</span> Tornado coroutines
Sun, <span class="hljs-number">18</span> Nov <span class="hljs-number">2012</span> <span class="hljs-number">20</span>:<span class="hljs-number">17</span>:<span class="hljs-number">49</span> +<span class="hljs-number">0000</span>
http://feedproxy.google.com/~r/EmptysquarePython/~<span class="hljs-number">3</span>/_DOZT2Kd0hQ/
</code></pre>
<p>很显然，如果你想做进一步的处理，你需要替换 <code>print()</code>语句来完成其他有趣的事。</p>
<h2 id="讨论">讨论</h2>
<p>在很多应用程序中处理 XML 编码格式的数据是很常见的。 不仅因为 XML 在 Internet 上面已经被广泛应用于数据交换， 同时它也是一种存储应用程序数据的常用格式(比如字处理，音乐库等)。 接下来的讨论会先假定读者已经对 XML 基础比较熟悉了。</p>
<p>在很多情况下，当使用 XML 来仅仅存储数据的时候，对应的文档结构非常紧凑并且直观。 例如，上面例子中的 RSS 订阅源类似于下面的格式：</p>
<pre><code class="lang-python">&lt;?xml version=<span class="hljs-string">"1.0"</span>?&gt;
&lt;rss version=<span class="hljs-string">"2.0"</span> xmlns:dc=<span class="hljs-string">"http://purl.org/dc/elements/1.1/"</span>&gt;
    &lt;channel&gt;
        &lt;title&gt;Planet Python&lt;/title&gt;
        &lt;link&gt;http://planet.python.org/&lt;/link&gt;
        &lt;language&gt;en&lt;/language&gt;
        &lt;description&gt;Planet Python - http://planet.python.org/&lt;/description&gt;
        &lt;item&gt;
            &lt;title&gt;Steve Holden: Python <span class="hljs-keyword">for</span> Data Analysis&lt;/title&gt;
            &lt;guid&gt;http://holdenweb.blogspot.com/...-data-analysis.html&lt;/guid&gt;
            &lt;link&gt;http://holdenweb.blogspot.com/...-data-analysis.html&lt;/link&gt;
            &lt;description&gt;...&lt;/description&gt;
            &lt;pubDate&gt;Mon, <span class="hljs-number">19</span> Nov <span class="hljs-number">2012</span> 02:<span class="hljs-number">13</span>:<span class="hljs-number">51</span> +<span class="hljs-number">0000</span>&lt;/pubDate&gt;
        &lt;/item&gt;
        &lt;item&gt;
            &lt;title&gt;Vasudev Ram: The Python Data model (<span class="hljs-keyword">for</span> v2 <span class="hljs-keyword">and</span> v3)&lt;/title&gt;
            &lt;guid&gt;http://jugad2.blogspot.com/...-data-model.html&lt;/guid&gt;
            &lt;link&gt;http://jugad2.blogspot.com/...-data-model.html&lt;/link&gt;
            &lt;description&gt;...&lt;/description&gt;
            &lt;pubDate&gt;Sun, <span class="hljs-number">18</span> Nov <span class="hljs-number">2012</span> <span class="hljs-number">22</span>:06:<span class="hljs-number">47</span> +<span class="hljs-number">0000</span>&lt;/pubDate&gt;
        &lt;/item&gt;
        &lt;item&gt;
            &lt;title&gt;Python Diary: Been playing around <span class="hljs-keyword">with</span> Object Databases&lt;/title&gt;
            &lt;guid&gt;http://www.pythondiary.com/...-<span class="hljs-built_in">object</span>-databases.html&lt;/guid&gt;
            &lt;link&gt;http://www.pythondiary.com/...-<span class="hljs-built_in">object</span>-databases.html&lt;/link&gt;
            &lt;description&gt;...&lt;/description&gt;
            &lt;pubDate&gt;Sun, <span class="hljs-number">18</span> Nov <span class="hljs-number">2012</span> <span class="hljs-number">20</span>:<span class="hljs-number">40</span>:<span class="hljs-number">29</span> +<span class="hljs-number">0000</span>&lt;/pubDate&gt;
        &lt;/item&gt;
        ...
    &lt;/channel&gt;
&lt;/rss&gt;
</code></pre>
<p><code>xml.etree.ElementTree.parse()</code> 函数解析整个XML文档并将其转换成一个文档对象。 然后，你就能使用 <code>find()</code> 、<code>iterfind()</code>和 <code>findtext()</code>等方法来搜索特定的 XML 元素了。 这些函数的参数就是某个指定的标签名，例如 <code>channel/item</code>或 <code>title</code>。</p>
<p>每次指定某个标签时，你需要遍历整个文档结构。每次搜索操作会从一个起始元素开始进行。 同样，每次操作所指定的标签名也是起始元素的相对路径。 例如，执行 <code>doc.iterfind('channel/item')</code> 来搜索所有在<code>channel</code> 元素下面的 <code>item</code> 元素。 <code>doc</code> 代表文档的最顶层(也就是第一级的<code>rss</code> 元素)。 然后接下来的调用 <code>item.findtext()</code> 会从已找到的 <code>item</code>元素位置开始搜索。</p>
<p><code>ElementTree</code> 模块中的每个元素有一些重要的属性和方法，在解析的时候非常有用。 <code>tag</code>属性包含了标签的名字，<code>text</code> 属性包含了内部的文本，而 <code>get()</code> 方法能获取属性值。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>doc
&lt;xml.etree.ElementTree.ElementTree <span class="hljs-built_in">object</span> at <span class="hljs-number">0x101339510</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>e = doc.find(<span class="hljs-string">'channel/title'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>e
&lt;Element <span class="hljs-string">'title'</span> at <span class="hljs-number">0x10135b310</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>e.tag
<span class="hljs-string">'title'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e.text
<span class="hljs-string">'Planet Python'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e.get(<span class="hljs-string">'some_attribute'</span>)
&gt;&gt;&gt;
</code></pre>
<p>有一点要强调的是 <code>xml.etree.ElementTree</code> 并不是 XML 解析的唯一方法。 对于更高级的应用程序，你需要考虑使用 <code>lxml</code> 。 它使用了和 ElementTree 同样的编程接口，因此上面的例子同样也适用于 lxml。 你只需要将刚开始的 import 语句换成 <code>from lxml.etree import parse</code> 就行了。 <code>lxml</code> 完全遵循 XML 标准，并且速度也非常快，同时还支持验证，XSLT，和 XPath 等特性。</p>
<h1 id="64-增量式解析大型-xml-文件">6.4 增量式解析大型 XML 文件</h1>
<h2 id="问题">问题</h2>
<p>你想使用尽可能少的内存从一个超大的 XML 文档中提取数据。</p>
<h2 id="解决方案">解决方案</h2>
<p>任何时候只要你遇到增量式的数据处理时，第一时间就应该想到迭代器和生成器。 下面是一个很简单的函数，只使用很少的内存就能增量式的处理一个大型 XML 文件：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> xml.etree.ElementTree <span class="hljs-keyword">import</span> iterparse

<span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_and_remove</span>(<span class="hljs-params">filename, path</span>):
    path_parts = path.split(<span class="hljs-string">'/'</span>)
    doc = iterparse(filename, (<span class="hljs-string">'start'</span>, <span class="hljs-string">'end'</span>))
    <span class="hljs-comment"># Skip the root element</span>
    <span class="hljs-built_in">next</span>(doc)

    tag_stack = []
    elem_stack = []
    <span class="hljs-keyword">for</span> event, elem <span class="hljs-keyword">in</span> doc:
        <span class="hljs-keyword">if</span> event == <span class="hljs-string">'start'</span>:
            tag_stack.append(elem.tag)
            elem_stack.append(elem)
        <span class="hljs-keyword">elif</span> event == <span class="hljs-string">'end'</span>:
            <span class="hljs-keyword">if</span> tag_stack == path_parts:
                <span class="hljs-keyword">yield</span> elem
                elem_stack[-<span class="hljs-number">2</span>].remove(elem)
            <span class="hljs-keyword">try</span>:
                tag_stack.pop()
                elem_stack.pop()
            <span class="hljs-keyword">except</span> IndexError:
                <span class="hljs-keyword">pass</span>
</code></pre>
<p>为了测试这个函数，你需要先有一个大型的 XML 文件。 通常你可以在政府网站或公共数据网站上找到这样的文件。 例如，你可以下载 XML 格式的芝加哥城市道路坑洼数据库。 在写这本书的时候，下载文件已经包含超过100,000行数据，编码格式类似于下面这样：</p>
<p>假设你想写一个脚本来按照坑洼报告数量排列邮编号码。你可以像这样做：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> xml.etree.ElementTree <span class="hljs-keyword">import</span> parse
<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

potholes_by_zip = Counter()

doc = parse(<span class="hljs-string">'potholes.xml'</span>)
<span class="hljs-keyword">for</span> pothole <span class="hljs-keyword">in</span> doc.iterfind(<span class="hljs-string">'row/row'</span>):
    potholes_by_zip[pothole.findtext(<span class="hljs-string">'zip'</span>)] += <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> zipcode, num <span class="hljs-keyword">in</span> potholes_by_zip.most_common():
    <span class="hljs-built_in">print</span>(zipcode, num)
</code></pre>
<p>这个脚本唯一的问题是它会先将整个 XML 文件加载到内存中然后解析。 在我的机器上，为了运行这个程序需要用到 450 MB 左右的内存空间。 如果使用如下代码，程序只需要修改一点点：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter

potholes_by_zip = Counter()

data = parse_and_remove(<span class="hljs-string">'potholes.xml'</span>, <span class="hljs-string">'row/row'</span>)
<span class="hljs-keyword">for</span> pothole <span class="hljs-keyword">in</span> data:
    potholes_by_zip[pothole.findtext(<span class="hljs-string">'zip'</span>)] += <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> zipcode, num <span class="hljs-keyword">in</span> potholes_by_zip.most_common():
    <span class="hljs-built_in">print</span>(zipcode, num)
</code></pre>
<p>结果是：这个版本的代码运行时只需要 7 MB 的内存–大大节约了内存资源。</p>
<h2 id="讨论">讨论</h2>
<p>这一节的技术会依赖 <code>ElementTree</code> 模块中的两个核心功能。 第一，<code>iterparse()</code> 方法允许对 XML 文档进行增量操作。 使用时，你需要提供文件名和一个包含下面一种或多种类型的事件列表： <code>start</code> , <code>end</code>, <code>start-ns</code> 和 <code>end-ns</code> 。 由 <code>iterparse()</code> 创建的迭代器会产生形如 <code>(event, elem)</code> 的元组， 其中 <code>event</code> 是上述事件列表中的某一个，而 <code>elem</code> 是相应的 XML 元素。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>data = iterparse(<span class="hljs-string">'potholes.xml'</span>,(<span class="hljs-string">'start'</span>,<span class="hljs-string">'end'</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(data)
(<span class="hljs-string">'start'</span>, &lt;Element <span class="hljs-string">'response'</span> at <span class="hljs-number">0x100771d60</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(data)
(<span class="hljs-string">'start'</span>, &lt;Element <span class="hljs-string">'row'</span> at <span class="hljs-number">0x100771e68</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(data)
(<span class="hljs-string">'start'</span>, &lt;Element <span class="hljs-string">'row'</span> at <span class="hljs-number">0x100771fc8</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(data)
(<span class="hljs-string">'start'</span>, &lt;Element <span class="hljs-string">'creation_date'</span> at <span class="hljs-number">0x100771f18</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(data)
(<span class="hljs-string">'end'</span>, &lt;Element <span class="hljs-string">'creation_date'</span> at <span class="hljs-number">0x100771f18</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(data)
(<span class="hljs-string">'start'</span>, &lt;Element <span class="hljs-string">'status'</span> at <span class="hljs-number">0x1006a7f18</span>&gt;)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(data)
(<span class="hljs-string">'end'</span>, &lt;Element <span class="hljs-string">'status'</span> at <span class="hljs-number">0x1006a7f18</span>&gt;)
&gt;&gt;&gt;
</code></pre>
<p><code>start</code> 事件在某个元素第一次被创建并且还没有被插入其他数据(如子元素)时被创建。 而 <code>end</code> 事件在某个元素已经完成时被创建。 尽管没有在例子中演示， <code>start-ns</code> 和 <code>end-ns</code> 事件被用来处理 XML 文档命名空间的声明。</p>
<p>这本节例子中，<code>start</code> 和<code>end</code>事件被用来管理元素和标签栈。 栈代表了文档被解析时的层次结构， 还被用来判断某个元素是否匹配传给函数 <code>parse_and_remove()</code> 的路径。 如果匹配，就利用 <code>yield</code>语句向调用者返回这个元素。</p>
<p>在 <code>yield</code>之后的下面这个语句才是使得程序占用极少内存的 ElementTree 的核心特性：</p>
<pre><code class="lang-python">elem_stack[-<span class="hljs-number">2</span>].remove(elem)
</code></pre>
<p>这个语句使得之前由 <code>yield</code> 产生的元素从它的父节点中删除掉。 假设已经没有其它的地方引用这个元素了，那么这个元素就被销毁并回收内存。</p>
<p>对节点的迭代式解析和删除的最终效果就是一个在文档上高效的增量式清扫过程。 文档树结构从始自终没被完整的创建过。尽管如此，还是能通过上述简单的方式来处理这个 XML 数据。</p>
<p>这种方案的主要缺陷就是它的运行性能了。 我自己测试的结果是，读取整个文档到内存中的版本的运行速度差不多是增量式处理版本的两倍快。 但是它却使用了超过后者60倍的内存。 因此，如果你更关心内存使用量的话，那么增量式的版本完胜。</p>
<h1 id="65-将字典转换为-xml">6.5 将字典转换为 XML</h1>
<h2 id="问题">问题</h2>
<p>你想使用一个 Python 字典存储数据，并将它转换成 XML 格式。</p>
<h2 id="解决方案">解决方案</h2>
<p>尽管 <code>xml.etree.ElementTree</code> 库通常用来做解析工作，其实它也可以创建 XML 文档。 例如，考虑如下这个函数：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> xml.etree.ElementTree <span class="hljs-keyword">import</span> Element

<span class="hljs-keyword">def</span> <span class="hljs-title function_">dict_to_xml</span>(<span class="hljs-params">tag, d</span>):
<span class="hljs-string">'''
Turn a simple dict of key/value pairs into XML
'''</span>
elem = Element(tag)
<span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> d.items():
    child = Element(key)
    child.text = <span class="hljs-built_in">str</span>(val)
    elem.append(child)
<span class="hljs-keyword">return</span> elem
</code></pre>
<p>下面是一个使用例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = { <span class="hljs-string">'name'</span>: <span class="hljs-string">'GOOG'</span>, <span class="hljs-string">'shares'</span>: <span class="hljs-number">100</span>, <span class="hljs-string">'price'</span>:<span class="hljs-number">490.1</span> }
<span class="hljs-meta">&gt;&gt;&gt; </span>e = dict_to_xml(<span class="hljs-string">'stock'</span>, s)
<span class="hljs-meta">&gt;&gt;&gt; </span>e
&lt;Element <span class="hljs-string">'stock'</span> at <span class="hljs-number">0x1004b64c8</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>转换结果是一个 <code>Element</code> 实例。对于 I/O 操作，使用 <code>xml.etree.ElementTree</code>中的 <code>tostring()</code> 函数很容易就能将它转换成一个字节字符串。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> xml.etree.ElementTree <span class="hljs-keyword">import</span> tostring
<span class="hljs-meta">&gt;&gt;&gt; </span>tostring(e)
<span class="hljs-string">b'&lt;stock&gt;&lt;price&gt;490.1&lt;/price&gt;&lt;shares&gt;100&lt;/shares&gt;&lt;name&gt;GOOG&lt;/name&gt;&lt;/stock&gt;'</span>
&gt;&gt;&gt;
</code></pre>
<p>如果你想给某个元素添加属性值，可以使用 <code>set()</code> 方法：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>e.<span class="hljs-built_in">set</span>(<span class="hljs-string">'_id'</span>,<span class="hljs-string">'1234'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tostring(e)
<span class="hljs-string">b'&lt;stock _id="1234"&gt;&lt;price&gt;490.1&lt;/price&gt;&lt;shares&gt;100&lt;/shares&gt;&lt;name&gt;GOOG&lt;/name&gt;
&lt;/stock&gt;'</span>
&gt;&gt;&gt;
</code></pre>
<p>如果你还想保持元素的顺序，可以考虑构造一个 <code>OrderedDict</code> 来代替一个普通的字典。请参考1.7小节。</p>
<h2 id="讨论">讨论</h2>
<p>当创建 XML 的时候，你被限制只能构造字符串类型的值。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dict_to_xml_str</span>(<span class="hljs-params">tag, d</span>):
    <span class="hljs-string">'''
    Turn a simple dict of key/value pairs into XML
    '''</span>
    parts = [<span class="hljs-string">'&lt;{}&gt;'</span>.<span class="hljs-built_in">format</span>(tag)]
    <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> d.items():
        parts.append(<span class="hljs-string">'&lt;{0}&gt;{1}&lt;/{0}&gt;'</span>.<span class="hljs-built_in">format</span>(key,val))
    parts.append(<span class="hljs-string">'&lt;/{}&gt;'</span>.<span class="hljs-built_in">format</span>(tag))
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(parts)
</code></pre>
<p>问题是如果你手动的去构造的时候可能会碰到一些麻烦。例如，当字典的值中包含一些特殊字符的时候会怎样呢？</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = { <span class="hljs-string">'name'</span> : <span class="hljs-string">'&lt;spam&gt;'</span> }

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># String creation</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>dict_to_xml_str(<span class="hljs-string">'item'</span>,d)
<span class="hljs-string">'&lt;item&gt;&lt;name&gt;&lt;spam&gt;&lt;/name&gt;&lt;/item&gt;'</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Proper XML creation</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e = dict_to_xml(<span class="hljs-string">'item'</span>,d)
<span class="hljs-meta">&gt;&gt;&gt; </span>tostring(e)
<span class="hljs-string">b'&lt;item&gt;&lt;name&gt;&amp;lt;spam&amp;gt;&lt;/name&gt;&lt;/item&gt;'</span>
&gt;&gt;&gt;
</code></pre>
<p>注意到程序的后面那个例子中，字符 ‘&lt;’ 和 ‘&gt;’ 被替换成了 <code>&amp;lt;</code>和<code>&amp;gt;</code></p>
<p>下面仅供参考，如果你需要手动去转换这些字符， 可以使用 <code>xml.sax.saxutils</code>中的 <code>escape()</code> 和 <code>unescape()</code> 函数。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> xml.sax.saxutils <span class="hljs-keyword">import</span> escape, unescape
<span class="hljs-meta">&gt;&gt;&gt; </span>escape(<span class="hljs-string">'&lt;spam&gt;'</span>)
<span class="hljs-string">'&amp;lt;spam&amp;gt;'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>unescape(_)
<span class="hljs-string">'&lt;spam&gt;'</span>
&gt;&gt;&gt;
</code></pre>
<p>除了能创建正确的输出外，还有另外一个原因推荐你创建 <code>Element</code>实例而不是字符串， 那就是使用字符串组合构造一个更大的文档并不是那么容易。 而 <code>Element</code>实例可以不用考虑解析 XML 文本的情况下通过多种方式被处理。 也就是说，你可以在一个高级数据结构上完成你所有的操作，并在最后以字符串的形式将其输出。</p>
<h1 id="66-解析和修改-xml">6.6 解析和修改 XML</h1>
<h2 id="问题">问题</h2>
<p>你想读取一个 XML 文档，对它最一些修改，然后将结果写回 XML 文档。</p>
<h2 id="解决方案">解决方案</h2>
<p>使用 <code>xml.etree.ElementTree</code> 模块可以很容易的处理这些任务。 第一步是以通常的方式来解析这个文档。例如，假设你有一个名为 <code>pred.xml</code> 的文档，类似下面这样：</p>
<p>下面是一个利用 <code>ElementTree</code> 来读取这个文档并对它做一些修改的例子：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> xml.etree.ElementTree <span class="hljs-keyword">import</span> parse, Element
<span class="hljs-meta">&gt;&gt;&gt; </span>doc = parse(<span class="hljs-string">'pred.xml'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>root = doc.getroot()
<span class="hljs-meta">&gt;&gt;&gt; </span>root
&lt;Element <span class="hljs-string">'stop'</span> at <span class="hljs-number">0x100770cb0</span>&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Remove a few elements</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>root.remove(root.find(<span class="hljs-string">'sri'</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>root.remove(root.find(<span class="hljs-string">'cr'</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Insert a new element after &lt;nm&gt;...&lt;/nm&gt;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>root.getchildren().index(root.find(<span class="hljs-string">'nm'</span>))
<span class="hljs-number">1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>e = Element(<span class="hljs-string">'spam'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>e.text = <span class="hljs-string">'This is a test'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>root.insert(<span class="hljs-number">2</span>, e)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Write back to a file</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.write(<span class="hljs-string">'newpred.xml'</span>, xml_declaration=<span class="hljs-literal">True</span>)
&gt;&gt;&gt;
</code></pre>
<p>处理结果是一个像下面这样新的 XML 文件：</p>
<h2 id="讨论">讨论</h2>
<p>修改一个 XML 文档结构是很容易的，但是你必须牢记的是所有的修改都是针对父节点元素， 将它作为一个列表来处理。例如，如果你删除某个元素，通过调用父节点的 <code>remove()</code> 方法从它的直接父节点中删除。 如果你插入或增加新的元素，你同样使用父节点元素的<code>insert()</code>和 <code>append()</code> 方法。 还能对元素使用索引和切片操作，比如<code>element[i]</code>或 <code>element[i:j]</code></p>
<p>如果你需要创建新的元素，可以使用本节方案中演示的<code>Element</code> 类。我们在6.5小节已经详细讨论过了。</p>
<h1 id="67-利用命名空间解析-xml-文档">6.7 利用命名空间解析 XML 文档</h1>
<h2 id="问题">问题</h2>
<p>你想解析某个 XML 文档，文档中使用了 XML 命名空间。</p>
<h2 id="解决方案">解决方案</h2>
<p>考虑下面这个使用了命名空间的文档：</p>
<p>如果你解析这个文档并执行普通的查询，你会发现这个并不是那么容易，因为所有步骤都变得相当的繁琐。</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Some queries that work</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.findtext(<span class="hljs-string">'author'</span>)
<span class="hljs-string">'David Beazley'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.find(<span class="hljs-string">'content'</span>)
&lt;Element <span class="hljs-string">'content'</span> at <span class="hljs-number">0x100776ec0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># A query involving a namespace (doesn't work)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.find(<span class="hljs-string">'content/html'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Works if fully qualified</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.find(<span class="hljs-string">'content/{http://www.w3.org/1999/xhtml}html'</span>)
&lt;Element <span class="hljs-string">'{http://www.w3.org/1999/xhtml}html'</span> at <span class="hljs-number">0x1007767e0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Doesn't work</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.findtext(<span class="hljs-string">'content/{http://www.w3.org/1999/xhtml}html/head/title'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Fully qualified</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.findtext(<span class="hljs-string">'content/{http://www.w3.org/1999/xhtml}html/'</span>
<span class="hljs-meta">... </span><span class="hljs-string">'{http://www.w3.org/1999/xhtml}head/{http://www.w3.org/1999/xhtml}title'</span>)
<span class="hljs-string">'Hello World'</span>
&gt;&gt;&gt;
</code></pre>
<p>你可以通过将命名空间处理逻辑包装为一个工具类来简化这个过程：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">XMLNamespaces</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, **kwargs</span>):
        <span class="hljs-variable language_">self</span>.namespaces = {}
        <span class="hljs-keyword">for</span> name, uri <span class="hljs-keyword">in</span> kwargs.items():
            <span class="hljs-variable language_">self</span>.register(name, uri)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">self, name, uri</span>):
        <span class="hljs-variable language_">self</span>.namespaces[name] = <span class="hljs-string">'{'</span>+uri+<span class="hljs-string">'}'</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, path</span>):
        <span class="hljs-keyword">return</span> path.format_map(<span class="hljs-variable language_">self</span>.namespaces)
</code></pre>
<p>通过下面的方式使用这个类：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>ns = XMLNamespaces(html=<span class="hljs-string">'http://www.w3.org/1999/xhtml'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.find(ns(<span class="hljs-string">'content/{html}html'</span>))
&lt;Element <span class="hljs-string">'{http://www.w3.org/1999/xhtml}html'</span> at <span class="hljs-number">0x1007767e0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>doc.findtext(ns(<span class="hljs-string">'content/{html}html/{html}head/{html}title'</span>))
<span class="hljs-string">'Hello World'</span>
&gt;&gt;&gt;
</code></pre>
<p>讨论
解析含有命名空间的 XML 文档会比较繁琐。 上面的 <code>XMLNamespaces</code> 仅仅是允许你使用缩略名代替完整的 URI 将其变得稍微简洁一点。</p>
<p>很不幸的是，在基本的 <code>ElementTree</code> 解析中没有任何途径获取命名空间的信息。 但是，如果你使用 <code>iterparse()</code>函数的话就可以获取更多关于命名空间处理范围的信息。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> xml.etree.ElementTree <span class="hljs-keyword">import</span> iterparse
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> evt, elem <span class="hljs-keyword">in</span> iterparse(<span class="hljs-string">'ns2.xml'</span>, (<span class="hljs-string">'end'</span>, <span class="hljs-string">'start-ns'</span>, <span class="hljs-string">'end-ns'</span>)):
<span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(evt, elem)
...
end &lt;Element <span class="hljs-string">'author'</span> at <span class="hljs-number">0x10110de10</span>&gt;
start-ns (<span class="hljs-string">''</span>, <span class="hljs-string">'http://www.w3.org/1999/xhtml'</span>)
end &lt;Element <span class="hljs-string">'{http://www.w3.org/1999/xhtml}title'</span> at <span class="hljs-number">0x1011131b0</span>&gt;
end &lt;Element <span class="hljs-string">'{http://www.w3.org/1999/xhtml}head'</span> at <span class="hljs-number">0x1011130a8</span>&gt;
end &lt;Element <span class="hljs-string">'{http://www.w3.org/1999/xhtml}h1'</span> at <span class="hljs-number">0x101113310</span>&gt;
end &lt;Element <span class="hljs-string">'{http://www.w3.org/1999/xhtml}body'</span> at <span class="hljs-number">0x101113260</span>&gt;
end &lt;Element <span class="hljs-string">'{http://www.w3.org/1999/xhtml}html'</span> at <span class="hljs-number">0x10110df70</span>&gt;
end-ns <span class="hljs-literal">None</span>
end &lt;Element <span class="hljs-string">'content'</span> at <span class="hljs-number">0x10110de68</span>&gt;
end &lt;Element <span class="hljs-string">'top'</span> at <span class="hljs-number">0x10110dd60</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>elem <span class="hljs-comment"># This is the topmost element</span>
&lt;Element <span class="hljs-string">'top'</span> at <span class="hljs-number">0x10110dd60</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>最后一点，如果你要处理的 XML 文本除了要使用到其他高级 XML 特性外，还要使用到命名空间， 建议你最好是使用 <code>lxml</code> 函数库来代替 <code>ElementTree</code>。 例如，<code>lxml</code>对利用 DTD 验证文档、更好的 XPath 支持和一些其他高级 XML 特性等都提供了更好的支持。 这一小节其实只是教你如何让 XML 解析稍微简单一点。</p>
<h1 id="68-与关系型数据库的交互">6.8 与关系型数据库的交互</h1>
<h2 id="问题">问题</h2>
<p>你想在关系型数据库中查询、增加或删除记录。</p>
<h2 id="解决方案">解决方案</h2>
<p>Python 中表示多行数据的标准方式是一个由元组构成的序列。例如：</p>
<pre><code class="lang-python">stocks = [
    (<span class="hljs-string">'GOOG'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">490.1</span>),
    (<span class="hljs-string">'AAPL'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">545.75</span>),
    (<span class="hljs-string">'FB'</span>, <span class="hljs-number">150</span>, <span class="hljs-number">7.45</span>),
    (<span class="hljs-string">'HPQ'</span>, <span class="hljs-number">75</span>, <span class="hljs-number">33.2</span>),
]
</code></pre>
<p>依据 PEP249，通过这种形式提供数据， 可以很容易的使用 Python 标准数据库 API 和关系型数据库进行交互。 所有数据库上的操作都通过 SQL 查询语句来完成。每一行输入输出数据用一个元组来表示。</p>
<p>为了演示说明，你可以使用 Python 标准库中的 <code>sqlite3</code> 模块。 如果你使用的是一个不同的数据库(比如 MySql、Postgresql 或者 ODBC)， 还得安装相应的第三方模块来提供支持。 不过相应的编程接口几乎都是一样的，除了一点点细微差别外。</p>
<p>第一步是连接到数据库。通常你要执行 <code>connect()</code> 函数， 给它提供一些数据库名、主机、用户名、密码和其他必要的一些参数。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sqlite3
<span class="hljs-meta">&gt;&gt;&gt; </span>db = sqlite3.connect(<span class="hljs-string">'database.db'</span>)
&gt;&gt;&gt;
</code></pre>
<p>为了处理数据，下一步你需要创建一个游标。 一旦你有了游标，那么你就可以执行 SQL 查询语句了。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = db.cursor()
<span class="hljs-meta">&gt;&gt;&gt; </span>c.execute(<span class="hljs-string">'create table portfolio (symbol text, shares integer, price real)'</span>)
&lt;sqlite3.Cursor <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10067a730</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>db.commit()
&gt;&gt;&gt;
</code></pre>
<p>为了向数据库表中插入多条记录，使用类似下面这样的语句：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c.executemany(<span class="hljs-string">'insert into portfolio values (?,?,?)'</span>, stocks)
&lt;sqlite3.Cursor <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10067a730</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>db.commit()
&gt;&gt;&gt;
</code></pre>
<p>为了执行某个查询，使用像下面这样的语句：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> db.execute(<span class="hljs-string">'select * from portfolio'</span>):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(row)
...
(<span class="hljs-string">'GOOG'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">490.1</span>)
(<span class="hljs-string">'AAPL'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">545.75</span>)
(<span class="hljs-string">'FB'</span>, <span class="hljs-number">150</span>, <span class="hljs-number">7.45</span>)
(<span class="hljs-string">'HPQ'</span>, <span class="hljs-number">75</span>, <span class="hljs-number">33.2</span>)
&gt;&gt;&gt;
</code></pre>
<p>如果你想接受用户输入作为参数来执行查询操作，必须确保你使用下面这样的占位符<code>?</code>来进行引用参数：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>min_price = <span class="hljs-number">100</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> db.execute(<span class="hljs-string">'select * from portfolio where price &gt;= ?'</span>,
                          (min_price,)):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(row)
...
(<span class="hljs-string">'GOOG'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">490.1</span>)
(<span class="hljs-string">'AAPL'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">545.75</span>)
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>在比较低的级别上和数据库交互是非常简单的。 你只需提供 SQL 语句并调用相应的模块就可以更新或提取数据了。 虽说如此，还是有一些比较棘手的细节问题需要你逐个列出去解决。</p>
<p>一个难点是数据库中的数据和 Python 类型直接的映射。 对于日期类型，通常可以使用 <code>datetime</code> 模块中的 <code>datetime</code> 实例， 或者可能是 <code>time</code> 模块中的系统时间戳。 对于数字类型，特别是使用到小数的金融数据，可以用 <code>decimal</code> 模块中的 <code>Decimal</code> 实例来表示。 不幸的是，对于不同的数据库而言具体映射规则是不一样的，你必须参考相应的文档。</p>
<p>另外一个更加复杂的问题就是 SQL 语句字符串的构造。 你千万不要使用 Python 字符串格式化操作符(如%)或者 <code>.format()</code> 方法来创建这样的字符串。 如果传递给这些格式化操作符的值来自于用户的输入，那么你的程序就很有可能遭受 SQL 注入攻击(参考 <a href="http://xkcd.com/327" target="_blank">http://xkcd.com/327</a> )。 查询语句中的通配符 <code>?</code> 指示后台数据库使用它自己的字符串替换机制，这样更加的安全。</p>
<p>不幸的是，不同的数据库后台对于通配符的使用是不一样的。大部分模块使用 <code>?</code> 或 <code>%s</code>， 还有其他一些使用了不同的符号，比如:0或:1来指示参数。 同样的，你还是得去参考你使用的数据库模块相应的文档。 一个数据库模块的 <code>paramstyle</code> 属性包含了参数引用风格的信息。</p>
<p>对于简单的数据库数据的读写问题，使用数据库 API 通常非常简单。 如果你要处理更加复杂的问题，建议你使用更加高级的接口，比如一个对象关系映射 ORM 所提供的接口。 类似 <code>SQLAlchemy</code> 这样的库允许你使用 Python 类来表示一个数据库表， 并且能在隐藏底层 SQL 的情况下实现各种数据库的操作。</p>
<h1 id="69-编码和解码十六进制数">6.9 编码和解码十六进制数</h1>
<h2 id="问题">问题</h2>
<p>你想将一个十六进制字符串解码成一个字节字符串或者将一个字节字符串编码成一个十六进制字符串。</p>
<h2 id="解决方案">解决方案</h2>
<p>如果你只是简单的解码或编码一个十六进制的原始字符串，可以使用　<code>binascii</code> 模块。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initial byte string</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">b'hello'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Encode as hex</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> binascii
<span class="hljs-meta">&gt;&gt;&gt; </span>h = binascii.b2a_hex(s)
<span class="hljs-meta">&gt;&gt;&gt; </span>h
<span class="hljs-string">b'68656c6c6f'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Decode back to bytes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>binascii.a2b_hex(h)
<span class="hljs-string">b'hello'</span>
&gt;&gt;&gt;
</code></pre>
<p>类似的功能同样可以在 <code>base64</code>模块中找到。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> base64
<span class="hljs-meta">&gt;&gt;&gt; </span>h = base64.b16encode(s)
<span class="hljs-meta">&gt;&gt;&gt; </span>h
<span class="hljs-string">b'68656C6C6F'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>base64.b16decode(h)
<span class="hljs-string">b'hello'</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>大部分情况下，通过使用上述的函数来转换十六进制是很简单的。 上面两种技术的主要不同在于大小写的处理。 函数 <code>base64.b16decode()</code> 和 <code>base64.b16encode()</code> 只能操作大写形式的十六进制字母， 而 <code>binascii</code> 模块中的函数大小写都能处理。</p>
<p>还有一点需要注意的是编码函数所产生的输出总是一个字节字符串。 如果想强制以 Unicode 形式输出，你需要增加一个额外的界面步骤。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>h = base64.b16encode(s)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(h)
<span class="hljs-string">b'68656C6C6F'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(h.decode(<span class="hljs-string">'ascii'</span>))
68656C6C6F
&gt;&gt;&gt;
</code></pre>
<p>在解码十六进制数时，函数 <code>b16decode()</code>和 <code>a2b_hex()</code>可以接受字节或 unicode 字符串。 但是，unicode 字符串必须仅仅只包含 ASCII 编码的十六进制数。</p>
<h1 id="610-编码解码-base64-数据">6.10 编码解码 Base64 数据</h1>
<h2 id="问题">问题</h2>
<p>你需要使用 Base64 格式解码或编码二进制数据。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>base64</code> 模块中有两个函数<code>b64encode()</code>and <code>b64decode()</code>可以帮你解决这个问题。例如;</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Some byte data</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">b'hello'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> base64

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Encode as Base64</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a = base64.b64encode(s)
<span class="hljs-meta">&gt;&gt;&gt; </span>a
<span class="hljs-string">b'aGVsbG8='</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Decode from Base64</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>base64.b64decode(a)
<span class="hljs-string">b'hello'</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>Base64 编码仅仅用于面向字节的数据比如字节字符串和字节数组。 此外，编码处理的输出结果总是一个字节字符串。 如果你想混合使用 Base64 编码的数据和 Unicode 文本，你必须添加一个额外的解码步骤。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = base64.b64encode(s).decode(<span class="hljs-string">'ascii'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a
<span class="hljs-string">'aGVsbG8='</span>
&gt;&gt;&gt;
</code></pre>
<p>当解码 Base64 的时候，字节字符串和 Unicode 文本都可以作为参数。 但是，Unicode 字符串只能包含 ASCII 字符。</p>
<h1 id="611-读写二进制数组数据">6.11 读写二进制数组数据</h1>
<h2 id="问题">问题</h2>
<p>你想读写一个二进制数组的结构化数据到 Python 元组中。</p>
<p>解决方案
可以使用 <code>struct</code> 模块处理二进制数据。 下面是一段示例代码将一个 Python 元组列表写入一个二进制文件，并使用 <code>struct</code> 将每个元组编码为一个结构体。</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> Struct
<span class="hljs-keyword">def</span> <span class="hljs-title function_">write_records</span>(<span class="hljs-params">records, <span class="hljs-built_in">format</span>, f</span>):
    <span class="hljs-string">'''
    Write a sequence of tuples to a binary file of structures.
    '''</span>
    record_struct = Struct(<span class="hljs-built_in">format</span>)
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> records:
        f.write(record_struct.pack(*r))

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    records = [ (<span class="hljs-number">1</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">4.5</span>),
                (<span class="hljs-number">6</span>, <span class="hljs-number">7.8</span>, <span class="hljs-number">9.0</span>),
                (<span class="hljs-number">12</span>, <span class="hljs-number">13.4</span>, <span class="hljs-number">56.7</span>) ]
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.b'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
        write_records(records, <span class="hljs-string">'&lt;idd'</span>, f)
</code></pre>
<p>有很多种方法来读取这个文件并返回一个元组列表。 首先，如果你打算以块的形式增量读取文件，你可以这样做：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> Struct

<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_records</span>(<span class="hljs-params"><span class="hljs-built_in">format</span>, f</span>):
    record_struct = Struct(<span class="hljs-built_in">format</span>)
    chunks = <span class="hljs-built_in">iter</span>(<span class="hljs-keyword">lambda</span>: f.read(record_struct.size), <span class="hljs-string">b''</span>)
    <span class="hljs-keyword">return</span> (record_struct.unpack(chunk) <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunks)

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.b'</span>,<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> rec <span class="hljs-keyword">in</span> read_records(<span class="hljs-string">'&lt;idd'</span>, f):
            <span class="hljs-comment"># Process rec</span>
            ...
</code></pre>
<p>如果你想将整个文件一次性读取到一个字节字符串中，然后在分片解析。那么你可以这样做：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> Struct

<span class="hljs-keyword">def</span> <span class="hljs-title function_">unpack_records</span>(<span class="hljs-params"><span class="hljs-built_in">format</span>, data</span>):
    record_struct = Struct(<span class="hljs-built_in">format</span>)
    <span class="hljs-keyword">return</span> (record_struct.unpack_from(data, offset)
            <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(data), record_struct.size))

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.b'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
        data = f.read()
    <span class="hljs-keyword">for</span> rec <span class="hljs-keyword">in</span> unpack_records(<span class="hljs-string">'&lt;idd'</span>, data):
        <span class="hljs-comment"># Process rec</span>
        ...
</code></pre>
<p>两种情况下的结果都是一个可返回用来创建该文件的原始元组的可迭代对象。</p>
<h2 id="讨论">讨论</h2>
<p>对于需要编码和解码二进制数据的程序而言，通常会使用 <code>struct</code> 模块。 为了声明一个新的结构体，只需要像这样创建一个 <code>Struct</code> 实例即可：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Little endian 32-bit integer, two double precision floats</span>
record_struct = Struct(<span class="hljs-string">'&lt;idd'</span>)
</code></pre>
<p>结构体通常会使用一些结构码值 i, d, f 等 [<a href="https://docs.python.org/3/library/struct.html" target="_blank">参考 Python 文档</a> ]。 这些代码分别代表某个特定的二进制数据类型如32位整数，64位浮点数，32位浮点数等。 第一个字符 <code>&lt;</code> 指定了字节顺序。在这个例子中，它表示”低位在前”。 更改这个字符为 <code>&gt;</code> 表示高位在前，或者是 <code>!</code> 表示网络字节顺序。</p>
<p>产生的 <code>Struct</code> 实例有很多属性和方法用来操作相应类型的结构。 <code>size</code> 属性包含了结构的字节数，这在 I/O 操作时非常有用。 <code>pack()</code>和 <code>unpack()</code>方法被用来打包和解包数据。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> Struct
<span class="hljs-meta">&gt;&gt;&gt; </span>record_struct = Struct(<span class="hljs-string">'&lt;idd'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>record_struct.size
<span class="hljs-number">20</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>record_struct.pack(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>)
<span class="hljs-string">b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>record_struct.unpack(_)
(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>)
&gt;&gt;&gt;
</code></pre>
<p>有时候你还会看到 <code>pack()</code> 和<code>unpack()</code>操作以模块级别函数被调用，类似下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> struct
<span class="hljs-meta">&gt;&gt;&gt; </span>struct.pack(<span class="hljs-string">'&lt;idd'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>)
<span class="hljs-string">b'\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>struct.unpack(<span class="hljs-string">'&lt;idd'</span>, _)
(<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>)
&gt;&gt;&gt;
</code></pre>
<p>这样可以工作，但是感觉没有实例方法那么优雅，特别是在你代码中同样的结构出现在多个地方的时候。 通过创建一个 <code>Struct</code>实例，格式代码只会指定一次并且所有的操作被集中处理。 这样一来代码维护就变得更加简单了(因为你只需要改变一处代码即可)。</p>
<p>读取二进制结构的代码要用到一些非常有趣而优美的编程技巧。 在函数　<code>read_records</code> 中，<code>iter()</code> 被用来创建一个返回固定大小数据块的迭代器，参考5.8小节。 这个迭代器会不断的调用一个用户提供的可调用对象(比如 <code>lambda: f.read(record_struct.size)</code>)， 直到它返回一个特殊的值(如 b’‘)，这时候迭代停止。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.b'</span>, <span class="hljs-string">'rb'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>chunks = <span class="hljs-built_in">iter</span>(<span class="hljs-keyword">lambda</span>: f.read(<span class="hljs-number">20</span>), <span class="hljs-string">b''</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>chunks
&lt;callable_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10069e6d0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> chk <span class="hljs-keyword">in</span> chunks:
<span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(chk)
...
<span class="hljs-string">b'\x01\x00\x00\x00ffffff\x02@\x00\x00\x00\x00\x00\x00\x12@'</span>
<span class="hljs-string">b'\x06\x00\x00\x00333333\x1f@\x00\x00\x00\x00\x00\x00"@'</span>
<span class="hljs-string">b'\x0c\x00\x00\x00\xcd\xcc\xcc\xcc\xcc\xcc*@\x9a\x99\x99\x99\x99YL@'</span>
&gt;&gt;&gt;
</code></pre>
<p>如你所见，创建一个可迭代对象的一个原因是它能允许使用一个生成器推导来创建记录。 如果你不使用这种技术，那么代码可能会像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_records</span>(<span class="hljs-params"><span class="hljs-built_in">format</span>, f</span>):
    record_struct = Struct(<span class="hljs-built_in">format</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        chk = f.read(record_struct.size)
        <span class="hljs-keyword">if</span> chk == <span class="hljs-string">b''</span>:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">yield</span> record_struct.unpack(chk)
</code></pre>
<p>在函数 <code>unpack_records()</code>中使用了另外一种方法<code>unpack_from()</code> 。 <code>unpack_from()</code> 对于从一个大型二进制数组中提取二进制数据非常有用， 因为它不会产生任何的临时对象或者进行内存复制操作。 你只需要给它一个字节字符串(或数组)和一个字节偏移量，它会从那个位置开始直接解包数据。</p>
<p>如果你使用 <code>unpack()</code> 来代替<code>unpack_from()</code> ， 你需要修改代码来构造大量的小的切片以及进行偏移量的计算。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpack_records</span>(<span class="hljs-params"><span class="hljs-built_in">format</span>, data</span>):
    record_struct = Struct(<span class="hljs-built_in">format</span>)
    <span class="hljs-keyword">return</span> (record_struct.unpack(data[offset:offset + record_struct.size])
            <span class="hljs-keyword">for</span> offset <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(data), record_struct.size))
</code></pre>
<p>这种方案除了代码看上去很复杂外，还得做很多额外的工作，因为它执行了大量的偏移量计算， 复制数据以及构造小的切片对象。 如果你准备从读取到的一个大型字节字符串中解包大量的结构体的话，<code>unpack_from()</code> 会表现的更出色。</p>
<p>在解包的时候，<code>collections</code> 模块中的命名元组对象或许是你想要用到的。 它可以让你给返回元组设置属性名称。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple

Record = namedtuple(<span class="hljs-string">'Record'</span>, [<span class="hljs-string">'kind'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>])

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.p'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
    records = (Record(*r) <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> read_records(<span class="hljs-string">'&lt;idd'</span>, f))

<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> records:
    <span class="hljs-built_in">print</span>(r.kind, r.x, r.y)
</code></pre>
<p>如果你的程序需要处理大量的二进制数据，你最好使用 <code>numpy</code> 模块。 例如，你可以将一个二进制数据读取到一个结构化数组中而不是一个元组列表中。就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'data.b'</span>, <span class="hljs-string">'rb'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>records = np.fromfile(f, dtype=<span class="hljs-string">'&lt;i,&lt;d,&lt;d'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>records
array([(<span class="hljs-number">1</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">4.5</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">7.8</span>, <span class="hljs-number">9.0</span>), (<span class="hljs-number">12</span>, <span class="hljs-number">13.4</span>, <span class="hljs-number">56.7</span>)],
dtype=[(<span class="hljs-string">'f0'</span>, <span class="hljs-string">'&lt;i4'</span>), (<span class="hljs-string">'f1'</span>, <span class="hljs-string">'&lt;f8'</span>), (<span class="hljs-string">'f2'</span>, <span class="hljs-string">'&lt;f8'</span>)])
<span class="hljs-meta">&gt;&gt;&gt; </span>records[<span class="hljs-number">0</span>]
(<span class="hljs-number">1</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">4.5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>records[<span class="hljs-number">1</span>]
(<span class="hljs-number">6</span>, <span class="hljs-number">7.8</span>, <span class="hljs-number">9.0</span>)
&gt;&gt;&gt;
</code></pre>
<p>最后提一点，如果你需要从已知的文件格式(如图片格式，图形文件，HDF5 等)中读取二进制数据时， 先检查看看 Python 是不是已经提供了现存的模块。因为不到万不得已没有必要去重复造轮子。</p>
<h1 id="612-读取嵌套和可变长二进制数据">6.12 读取嵌套和可变长二进制数据</h1>
<h2 id="问题">问题</h2>
<p>你需要读取包含嵌套或者可变长记录集合的复杂二进制格式的数据。这些数据可能包含图片、视频、电子地图文件等。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>struct</code> 模块可被用来编码/解码几乎所有类型的二进制的数据结构。为了解释清楚这种数据，假设你用下面的 Python 数据结构 来表示一个组成一系列多边形的点的集合：</p>
<pre><code class="lang-python">polys = [
    [ (<span class="hljs-number">1.0</span>, <span class="hljs-number">2.5</span>), (<span class="hljs-number">3.5</span>, <span class="hljs-number">4.0</span>), (<span class="hljs-number">2.5</span>, <span class="hljs-number">1.5</span>) ],
    [ (<span class="hljs-number">7.0</span>, <span class="hljs-number">1.2</span>), (<span class="hljs-number">5.1</span>, <span class="hljs-number">3.0</span>), (<span class="hljs-number">0.5</span>, <span class="hljs-number">7.5</span>), (<span class="hljs-number">0.8</span>, <span class="hljs-number">9.0</span>) ],
    [ (<span class="hljs-number">3.4</span>, <span class="hljs-number">6.3</span>), (<span class="hljs-number">1.2</span>, <span class="hljs-number">0.5</span>), (<span class="hljs-number">4.6</span>, <span class="hljs-number">9.2</span>) ],
]
</code></pre>
<p>现在假设这个数据被编码到一个以下列头部开始的二进制文件中去了：</p>
<pre><code class="lang-python">+------+--------+------------------------------------+
|Byte  | <span class="hljs-type">Type</span>   |  Description                       |
+======+========+====================================+
|<span class="hljs-number">0</span>     | <span class="hljs-built_in">int</span>    |  文件代码（<span class="hljs-number">0x1234</span>，小端）          |
+------+--------+------------------------------------+
|<span class="hljs-number">4</span>     | double |  x 的最小值（小端）                |
+------+--------+------------------------------------+
|<span class="hljs-number">12</span>    | double |  y 的最小值（小端）                |
+------+--------+------------------------------------+
|<span class="hljs-number">20</span>    | double |  x 的最大值（小端）                |
+------+--------+------------------------------------+
|<span class="hljs-number">28</span>    | double |  y 的最大值（小端）                |
+------+--------+------------------------------------+
|<span class="hljs-number">36</span>    | <span class="hljs-built_in">int</span>    |  三角形数量（小端）                |
+------+--------+------------------------------------+
</code></pre>
<p>紧跟着头部是一系列的多边形记录，编码格式如下：</p>
<pre><code class="lang-python">+------+--------+-------------------------------------------+
|Byte  | <span class="hljs-type">Type</span>   |  Description                              |
+======+========+===========================================+
|<span class="hljs-number">0</span>     | <span class="hljs-built_in">int</span>    |  记录长度（N字节）                        |
+------+--------+-------------------------------------------+
|<span class="hljs-number">4</span>-N   | Points |  (X,Y) 坐标，以浮点数表示                 |
+------+--------+-------------------------------------------+
</code></pre>
<p>为了写这样的文件，你可以使用如下的 Python 代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> struct
<span class="hljs-keyword">import</span> itertools

<span class="hljs-keyword">def</span> <span class="hljs-title function_">write_polys</span>(<span class="hljs-params">filename, polys</span>):
    <span class="hljs-comment"># Determine bounding box</span>
    flattened = <span class="hljs-built_in">list</span>(itertools.chain(*polys))
    min_x = <span class="hljs-built_in">min</span>(x <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> flattened)
    max_x = <span class="hljs-built_in">max</span>(x <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> flattened)
    min_y = <span class="hljs-built_in">min</span>(y <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> flattened)
    max_y = <span class="hljs-built_in">max</span>(y <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> flattened)
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
        f.write(struct.pack(<span class="hljs-string">'&lt;iddddi'</span>, <span class="hljs-number">0x1234</span>,
                            min_x, min_y,
                            max_x, max_y,
                            <span class="hljs-built_in">len</span>(polys)))
        <span class="hljs-keyword">for</span> poly <span class="hljs-keyword">in</span> polys:
            size = <span class="hljs-built_in">len</span>(poly) * struct.calcsize(<span class="hljs-string">'&lt;dd'</span>)
            f.write(struct.pack(<span class="hljs-string">'&lt;i'</span>, size + <span class="hljs-number">4</span>))
            <span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> poly:
                f.write(struct.pack(<span class="hljs-string">'&lt;dd'</span>, *pt))
</code></pre>
<p>将数据读取回来的时候，可以利用函数 <code>struct.unpack()</code> ，代码很相似，基本就是上面写操作的逆序。如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_polys</span>(<span class="hljs-params">filename</span>):
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-comment"># Read the header</span>
        header = f.read(<span class="hljs-number">40</span>)
        file_code, min_x, min_y, max_x, max_y, num_polys = \
            struct.unpack(<span class="hljs-string">'&lt;iddddi'</span>, header)
        polys = []
        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_polys):
            pbytes, = struct.unpack(<span class="hljs-string">'&lt;i'</span>, f.read(<span class="hljs-number">4</span>))
            poly = []
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pbytes // <span class="hljs-number">16</span>):
                pt = struct.unpack(<span class="hljs-string">'&lt;dd'</span>, f.read(<span class="hljs-number">16</span>))
                poly.append(pt)
            polys.append(poly)
    <span class="hljs-keyword">return</span> polys
</code></pre>
<p>尽管这个代码可以工作，但是里面混杂了很多读取、解包数据结构和其他细节的代码。如果用这样的代码来处理真实的数据文件， 那未免也太繁杂了点。因此很显然应该有另一种解决方法可以简化这些步骤，让程序员只关注自最重要的事情。</p>
<p>在本小节接下来的部分，我会逐步演示一个更加优秀的解析字节数据的方案。 目标是可以给程序员提供一个高级的文件格式化方法，并简化读取和解包数据的细节。但是我要先提醒你， 本小节接下来的部分代码应该是整本书中最复杂最高级的例子，使用了大量的面向对象编程和元编程技术。 一定要仔细的阅读我们的讨论部分，另外也要参考下其他章节内容。</p>
<p>首先，当读取字节数据的时候，通常在文件开始部分会包含文件头和其他的数据结构。 尽管 struct 模块可以解包这些数据到一个元组中去，另外一种表示这种信息的方式就是使用一个类。 就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> struct

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StructField</span>:
    <span class="hljs-string">'''
    Descriptor representing a simple structure field
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">format</span>, offset</span>):
        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">format</span> = <span class="hljs-built_in">format</span>
        <span class="hljs-variable language_">self</span>.offset = offset
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">else</span>:
            r = struct.unpack_from(<span class="hljs-variable language_">self</span>.<span class="hljs-built_in">format</span>, instance._buffer, <span class="hljs-variable language_">self</span>.offset)
            <span class="hljs-keyword">return</span> r[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r) == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> r

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, bytedata</span>):
        <span class="hljs-variable language_">self</span>._buffer = <span class="hljs-built_in">memoryview</span>(bytedata)
</code></pre>
<p>这里我们使用了一个描述器来表示每个结构字段，每个描述器包含一个结构兼容格式的代码以及一个字节偏移量， 存储在内部的内存缓冲中。在 <code>__get__()</code> 方法中，<code>struct.unpack_from()</code> 函数被用来从缓冲中解包一个值，省去了额外的分片或复制操作步骤。</p>
<p><code>Structure</code>类就是一个基础类，接受字节数据并存储在内部的内存缓冲中，并被 <code>StructField</code> 描述器使用。 这里使用了 <code>memoryview()</code> ，我们会在后面详细讲解它是用来干嘛的。</p>
<p>使用这个代码，你现在就能定义一个高层次的结构对象来表示上面表格信息所期望的文件格式。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyHeader</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    file_code = StructField(<span class="hljs-string">'&lt;i'</span>, <span class="hljs-number">0</span>)
    min_x = StructField(<span class="hljs-string">'&lt;d'</span>, <span class="hljs-number">4</span>)
    min_y = StructField(<span class="hljs-string">'&lt;d'</span>, <span class="hljs-number">12</span>)
    max_x = StructField(<span class="hljs-string">'&lt;d'</span>, <span class="hljs-number">20</span>)
    max_y = StructField(<span class="hljs-string">'&lt;d'</span>, <span class="hljs-number">28</span>)
    num_polys = StructField(<span class="hljs-string">'&lt;i'</span>, <span class="hljs-number">36</span>)
</code></pre>
<p>下面的例子利用这个类来读取之前我们写入的多边形数据的头部数据：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'polys.bin'</span>, <span class="hljs-string">'rb'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>phead = PolyHeader(f.read(<span class="hljs-number">40</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.file_code == <span class="hljs-number">0x1234</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.min_x
<span class="hljs-number">0.5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.min_y
<span class="hljs-number">0.5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.max_x
<span class="hljs-number">7.0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.max_y
<span class="hljs-number">9.2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.num_polys
<span class="hljs-number">3</span>
&gt;&gt;&gt;
</code></pre>
<p>这个很有趣，不过这种方式还是有一些烦人的地方。首先，尽管你获得了一个类接口的便利， 但是这个代码还是有点臃肿，还需要使用者指定很多底层的细节(比如重复使用 <code>StructField</code>，指定偏移量等)。 另外，返回的结果类同样确实一些便利的方法来计算结构的总数。</p>
<p>任何时候只要你遇到了像这样冗余的类定义，你应该考虑下使用类装饰器或元类。 元类有一个特性就是它能够被用来填充许多低层的实现细节，从而释放使用者的负担。 下面我来举个例子，使用元类稍微改造下我们的 <code>Structure</code> 类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StructureMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-string">'''
    Metaclass that automatically creates StructField descriptors
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clsname, bases, clsdict</span>):
        fields = <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">'_fields_'</span>, [])
        byte_order = <span class="hljs-string">''</span>
        offset = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> <span class="hljs-built_in">format</span>, fieldname <span class="hljs-keyword">in</span> fields:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">format</span>.startswith((<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'!'</span>,<span class="hljs-string">'@'</span>)):
                byte_order = <span class="hljs-built_in">format</span>[<span class="hljs-number">0</span>]
                <span class="hljs-built_in">format</span> = <span class="hljs-built_in">format</span>[<span class="hljs-number">1</span>:]
            <span class="hljs-built_in">format</span> = byte_order + <span class="hljs-built_in">format</span>
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, fieldname, StructField(<span class="hljs-built_in">format</span>, offset))
            offset += struct.calcsize(<span class="hljs-built_in">format</span>)
        <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">'struct_size'</span>, offset)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure</span>(metaclass=StructureMeta):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, bytedata</span>):
        <span class="hljs-variable language_">self</span>._buffer = bytedata

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">from_file</span>(<span class="hljs-params">cls, f</span>):
        <span class="hljs-keyword">return</span> cls(f.read(cls.struct_size))
</code></pre>
<p>使用新的 <code>Structure</code> 类，你可以像下面这样定义一个结构：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyHeader</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields_ = [
        (<span class="hljs-string">'&lt;i'</span>, <span class="hljs-string">'file_code'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'min_x'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'min_y'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'max_x'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'max_y'</span>),
        (<span class="hljs-string">'i'</span>, <span class="hljs-string">'num_polys'</span>)
    ]
</code></pre>
<p>正如你所见，这样写就简单多了。我们添加的类方法 <code>from_file()</code>让我们在不需要知道任何数据的大小和结构的情况下就能轻松的从文件中读取数据。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'polys.bin'</span>, <span class="hljs-string">'rb'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>phead = PolyHeader.from_file(f)
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.file_code == <span class="hljs-number">0x1234</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.min_x
<span class="hljs-number">0.5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.min_y
<span class="hljs-number">0.5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.max_x
<span class="hljs-number">7.0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.max_y
<span class="hljs-number">9.2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.num_polys
<span class="hljs-number">3</span>
&gt;&gt;&gt;
</code></pre>
<p>一旦你开始使用了元类，你就可以让它变得更加智能。例如，假设你还想支持嵌套的字节结构， 下面是对前面元类的一个小的改进，提供了一个新的辅助描述器来达到想要的效果：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NestedStruct</span>:
    <span class="hljs-string">'''
    Descriptor representing a nested structure
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, struct_type, offset</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.struct_type = struct_type
        <span class="hljs-variable language_">self</span>.offset = offset

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">else</span>:
            data = instance._buffer[<span class="hljs-variable language_">self</span>.offset:
                            <span class="hljs-variable language_">self</span>.offset+<span class="hljs-variable language_">self</span>.struct_type.struct_size]
            result = <span class="hljs-variable language_">self</span>.struct_type(data)
            <span class="hljs-comment"># Save resulting structure back on instance to avoid</span>
            <span class="hljs-comment"># further recomputation of this step</span>
            <span class="hljs-built_in">setattr</span>(instance, <span class="hljs-variable language_">self</span>.name, result)
            <span class="hljs-keyword">return</span> result

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StructureMeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-string">'''
    Metaclass that automatically creates StructField descriptors
    '''</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clsname, bases, clsdict</span>):
        fields = <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">'_fields_'</span>, [])
        byte_order = <span class="hljs-string">''</span>
        offset = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> <span class="hljs-built_in">format</span>, fieldname <span class="hljs-keyword">in</span> fields:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">format</span>, StructureMeta):
                <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, fieldname,
                        NestedStruct(fieldname, <span class="hljs-built_in">format</span>, offset))
                offset += <span class="hljs-built_in">format</span>.struct_size
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">format</span>.startswith((<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'!'</span>,<span class="hljs-string">'@'</span>)):
                    byte_order = <span class="hljs-built_in">format</span>[<span class="hljs-number">0</span>]
                    <span class="hljs-built_in">format</span> = <span class="hljs-built_in">format</span>[<span class="hljs-number">1</span>:]
                <span class="hljs-built_in">format</span> = byte_order + <span class="hljs-built_in">format</span>
                <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, fieldname, StructField(<span class="hljs-built_in">format</span>, offset))
                offset += struct.calcsize(<span class="hljs-built_in">format</span>)
        <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, <span class="hljs-string">'struct_size'</span>, offset)
</code></pre>
<p>在这段代码中，<code>NestedStruct</code> 描述器被用来叠加另外一个定义在某个内存区域上的结构。 它通过将原始内存缓冲进行切片操作后实例化给定的结构类型。由于底层的内存缓冲区是通过一个内存视图初始化的， 所以这种切片操作不会引发任何的额外的内存复制。相反，它仅仅就是之前的内存的一个叠加而已。 另外，为了防止重复实例化，通过使用和8.10小节同样的技术，描述器保存了该实例中的内部结构对象。</p>
<p>使用这个新的修正版，你就可以像下面这样编写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields_ = [
        (<span class="hljs-string">'&lt;d'</span>, <span class="hljs-string">'x'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'y'</span>)
    ]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyHeader</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields_ = [
        (<span class="hljs-string">'&lt;i'</span>, <span class="hljs-string">'file_code'</span>),
        (Point, <span class="hljs-string">'min'</span>), <span class="hljs-comment"># nested struct</span>
        (Point, <span class="hljs-string">'max'</span>), <span class="hljs-comment"># nested struct</span>
        (<span class="hljs-string">'i'</span>, <span class="hljs-string">'num_polys'</span>)
    ]
</code></pre>
<p>令人惊讶的是，它也能按照预期的正常工作，我们实际操作下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'polys.bin'</span>, <span class="hljs-string">'rb'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>phead = PolyHeader.from_file(f)
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.file_code == <span class="hljs-number">0x1234</span>
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.<span class="hljs-built_in">min</span> <span class="hljs-comment"># Nested structure</span>
&lt;__main__.Point <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a48d0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.<span class="hljs-built_in">min</span>.x
<span class="hljs-number">0.5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.<span class="hljs-built_in">min</span>.y
<span class="hljs-number">0.5</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.<span class="hljs-built_in">max</span>.x
<span class="hljs-number">7.0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.<span class="hljs-built_in">max</span>.y
<span class="hljs-number">9.2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.num_polys
<span class="hljs-number">3</span>
&gt;&gt;&gt;
</code></pre>
<p>到目前为止，一个处理定长记录的框架已经写好了。但是如果组件记录是变长的呢？ 比如，多边形文件包含变长的部分。</p>
<p>一种方案是写一个类来表示字节数据，同时写一个工具函数来通过多少方式解析内容。跟6.11小节的代码很类似：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SizedRecord</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, bytedata</span>):
        <span class="hljs-variable language_">self</span>._buffer = <span class="hljs-built_in">memoryview</span>(bytedata)

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">from_file</span>(<span class="hljs-params">cls, f, size_fmt, includes_size=<span class="hljs-literal">True</span></span>):
        sz_nbytes = struct.calcsize(size_fmt)
        sz_bytes = f.read(sz_nbytes)
        sz, = struct.unpack(size_fmt, sz_bytes)
        buf = f.read(sz - includes_size * sz_nbytes)
        <span class="hljs-keyword">return</span> cls(buf)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">iter_as</span>(<span class="hljs-params">self, code</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(code, <span class="hljs-built_in">str</span>):
            s = struct.Struct(code)
            <span class="hljs-keyword">for</span> off <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._buffer), s.size):
                <span class="hljs-keyword">yield</span> s.unpack_from(<span class="hljs-variable language_">self</span>._buffer, off)
        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(code, StructureMeta):
            size = code.struct_size
            <span class="hljs-keyword">for</span> off <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._buffer), size):
                data = <span class="hljs-variable language_">self</span>._buffer[off:off+size]
                <span class="hljs-keyword">yield</span> code(data)
</code></pre>
<p>类方法 <code>SizedRecord.from_file()</code> 是一个工具，用来从一个文件中读取带大小前缀的数据块， 这也是很多文件格式常用的方式。作为输入，它接受一个包含大小编码的结构格式编码，并且也是自己形式。 可选的<code>includes_size</code> 参数指定了字节数是否包含头部大小。 下面是一个例子教你怎样使用从多边形文件中读取单独的多边形数据：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'polys.bin'</span>, <span class="hljs-string">'rb'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>phead = PolyHeader.from_file(f)
<span class="hljs-meta">&gt;&gt;&gt; </span>phead.num_polys
<span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>polydata = [ SizedRecord.from_file(f, <span class="hljs-string">'&lt;i'</span>)
<span class="hljs-meta">... </span>            <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(phead.num_polys) ]
<span class="hljs-meta">&gt;&gt;&gt; </span>polydata
[&lt;__main__.SizedRecord <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a4d50</span>&gt;,
&lt;__main__.SizedRecord <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a4f50</span>&gt;,
&lt;__main__.SizedRecord <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10070da90</span>&gt;]
&gt;&gt;&gt;
</code></pre>
<p>可以看出，<code>SizedRecord</code> 实例的内容还没有被解析出来。 可以使用 <code>iter_as()</code>方法来达到目的，这个方法接受一个结构格式化编码或者是 <code>Structure</code> 类作为输入。 这样子可以很灵活的去解析数据，例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> n, poly <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(polydata):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Polygon'</span>, n)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> poly.iter_as(<span class="hljs-string">'&lt;dd'</span>):
<span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(p)
...
Polygon <span class="hljs-number">0</span>
(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.5</span>)
(<span class="hljs-number">3.5</span>, <span class="hljs-number">4.0</span>)
(<span class="hljs-number">2.5</span>, <span class="hljs-number">1.5</span>)
Polygon <span class="hljs-number">1</span>
(<span class="hljs-number">7.0</span>, <span class="hljs-number">1.2</span>)
(<span class="hljs-number">5.1</span>, <span class="hljs-number">3.0</span>)
(<span class="hljs-number">0.5</span>, <span class="hljs-number">7.5</span>)
(<span class="hljs-number">0.8</span>, <span class="hljs-number">9.0</span>)
Polygon <span class="hljs-number">2</span>
(<span class="hljs-number">3.4</span>, <span class="hljs-number">6.3</span>)
(<span class="hljs-number">1.2</span>, <span class="hljs-number">0.5</span>)
(<span class="hljs-number">4.6</span>, <span class="hljs-number">9.2</span>)
&gt;&gt;&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> n, poly <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(polydata):
<span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'Polygon'</span>, n)
<span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> poly.iter_as(Point):
<span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(p.x, p.y)
...
Polygon <span class="hljs-number">0</span>
<span class="hljs-number">1.0</span> <span class="hljs-number">2.5</span>
<span class="hljs-number">3.5</span> <span class="hljs-number">4.0</span>
<span class="hljs-number">2.5</span> <span class="hljs-number">1.5</span>
Polygon <span class="hljs-number">1</span>
<span class="hljs-number">7.0</span> <span class="hljs-number">1.2</span>
<span class="hljs-number">5.1</span> <span class="hljs-number">3.0</span>
<span class="hljs-number">0.5</span> <span class="hljs-number">7.5</span>
<span class="hljs-number">0.8</span> <span class="hljs-number">9.0</span>
Polygon <span class="hljs-number">2</span>
<span class="hljs-number">3.4</span> <span class="hljs-number">6.3</span>
<span class="hljs-number">1.2</span> <span class="hljs-number">0.5</span>
<span class="hljs-number">4.6</span> <span class="hljs-number">9.2</span>
&gt;&gt;&gt;
</code></pre>
<p>将所有这些结合起来，下面是一个 <code>read_polys()</code>函数的另外一个修正版：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields_ = [
        (<span class="hljs-string">'&lt;d'</span>, <span class="hljs-string">'x'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'y'</span>)
    ]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyHeader</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields_ = [
        (<span class="hljs-string">'&lt;i'</span>, <span class="hljs-string">'file_code'</span>),
        (Point, <span class="hljs-string">'min'</span>),
        (Point, <span class="hljs-string">'max'</span>),
        (<span class="hljs-string">'i'</span>, <span class="hljs-string">'num_polys'</span>)
    ]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">read_polys</span>(<span class="hljs-params">filename</span>):
    polys = []
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
        phead = PolyHeader.from_file(f)
        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(phead.num_polys):
            rec = SizedRecord.from_file(f, <span class="hljs-string">'&lt;i'</span>)
            poly = [ (p.x, p.y) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> rec.iter_as(Point) ]
            polys.append(poly)
    <span class="hljs-keyword">return</span> polys
</code></pre>
<h2 id="讨论">讨论</h2>
<p>这一节向你展示了许多高级的编程技术，包括描述器，延迟计算，元类，类变量和内存视图。 然而，它们都为了同一个特定的目标服务。</p>
<p>上面的实现的一个主要特征是它是基于懒解包的思想。当一个<code>Structure</code> 实例被创建时， <code>__init__()</code> 仅仅只是创建一个字节数据的内存视图，没有做其他任何事。 特别的，这时候并没有任何的解包或者其他与结构相关的操作发生。 这样做的一个动机是你可能仅仅只对一个字节记录的某一小部分感兴趣。我们只需要解包你需要访问的部分，而不是整个文件。</p>
<p>为了实现懒解包和打包，需要使用 <code>StructField</code> 描述器类。 用户在<code>_fields_</code> 中列出来的每个属性都会被转化成一个 <code>StructField</code> 描述器， 它将相关结构格式码和偏移值保存到存储缓存中。元类 <code>StructureMeta</code> 在多个结构类被定义时自动创建了这些描述器。 我们使用元类的一个主要原因是它使得用户非常方便的通过一个高层描述就能指定结构格式，而无需考虑低层的细节问题。</p>
<p><code>StructureMeta</code> 的一个很微妙的地方就是它会固定字节数据顺序。 也就是说，如果任意的属性指定了一个字节顺序(&lt;表示低位优先 或者 &gt;表示高位优先)， 那后面所有字段的顺序都以这个顺序为准。这么做可以帮助避免额外输入，但是在定义的中间我们仍然可能切换顺序的。 比如，你可能有一些比较复杂的结构，就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeFile</span>(<span class="hljs-title class_ inherited__">Structure</span>):
    _fields_ = [ (<span class="hljs-string">'&gt;i'</span>, <span class="hljs-string">'file_code'</span>), <span class="hljs-comment"># Big endian</span>
        (<span class="hljs-string">'20s'</span>, <span class="hljs-string">'unused'</span>),
        (<span class="hljs-string">'i'</span>, <span class="hljs-string">'file_length'</span>),
        (<span class="hljs-string">'&lt;i'</span>, <span class="hljs-string">'version'</span>), <span class="hljs-comment"># Little endian</span>
        (<span class="hljs-string">'i'</span>, <span class="hljs-string">'shape_type'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'min_x'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'min_y'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'max_x'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'max_y'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'min_z'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'max_z'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'min_m'</span>),
        (<span class="hljs-string">'d'</span>, <span class="hljs-string">'max_m'</span>) ]
</code></pre>
<p>之前我们提到过，<code>memoryview()</code> 的使用可以帮助我们避免内存的复制。 当结构存在嵌套的时候，<code>memoryviews</code> 可以叠加同一内存区域上定义的机构的不同部分。 这个特性比较微妙，但是它关注的是内存视图与普通字节数组的切片操作行为。 如果你在一个字节字符串或字节数组上执行切片操作，你通常会得到一个数据的拷贝。 而内存视图切片不是这样的，它仅仅是在已存在的内存上面叠加而已。因此，这种方式更加高效。</p>
<p>还有很多相关的章节可以帮助我们扩展这里讨论的方案。 参考8.13小节使用描述器构建一个类型系统。 8.10小节有更多关于延迟计算属性值的讨论，并且跟 NestedStruct 描述器的实现也有关。 9.19小节有一个使用元类来初始化类成员的例子，和 <code>StructureMeta</code>类非常相似。 Python 的 <code>ctypes</code>源码同样也很有趣，它提供了对定义数据结构、数据结构嵌套这些相似功能的支持。</p>
<h1 id="613-数据的累加与统计操作">6.13 数据的累加与统计操作</h1>
<h2 id="问题">问题</h2>
<p>你需要处理一个很大的数据集并需要计算数据总和或其他统计量。</p>
<h2 id="解决方案">解决方案</h2>
<p>对于任何涉及到统计、时间序列以及其他相关技术的数据分析问题，都可以考虑使用 <a href="http://pandas.pydata.org/" target="_blank">Pandas 库</a> 。</p>
<p>为了让你先体验下，下面是一个使用 Pandas 来分析芝加哥城市的<a href="https://data.cityofchicago.org/Service-Requests/311-Service-Requests-Rodent-Baiting/97t6-zrhs" target="_blank">老鼠和啮齿类动物数据库</a>的例子。 在我写这篇文章的时候，这个数据库是一个拥有大概74,000行数据的 CSV 文件。</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> pandas

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Read a CSV file, skipping last line</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>rats = pandas.read_csv(<span class="hljs-string">'rats.csv'</span>, skip_footer=<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>rats
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'pandas.core.frame.DataFrame'</span>&gt;
Int64Index: <span class="hljs-number">74055</span> entries, <span class="hljs-number">0</span> to <span class="hljs-number">74054</span>
Data columns:
Creation Date <span class="hljs-number">74055</span> non-null values
Status <span class="hljs-number">74055</span> non-null values
Completion Date <span class="hljs-number">72154</span> non-null values
Service Request Number <span class="hljs-number">74055</span> non-null values
<span class="hljs-type">Type</span> of Service Request <span class="hljs-number">74055</span> non-null values
Number of Premises Baited <span class="hljs-number">65804</span> non-null values
Number of Premises <span class="hljs-keyword">with</span> Garbage <span class="hljs-number">65600</span> non-null values
Number of Premises <span class="hljs-keyword">with</span> Rats <span class="hljs-number">65752</span> non-null values
Current Activity <span class="hljs-number">66041</span> non-null values
Most Recent Action <span class="hljs-number">66023</span> non-null values
Street Address <span class="hljs-number">74055</span> non-null values
ZIP Code <span class="hljs-number">73584</span> non-null values
X Coordinate <span class="hljs-number">74043</span> non-null values
Y Coordinate <span class="hljs-number">74043</span> non-null values
Ward <span class="hljs-number">74044</span> non-null values
Police District <span class="hljs-number">74044</span> non-null values
Community Area <span class="hljs-number">74044</span> non-null values
Latitude <span class="hljs-number">74043</span> non-null values
Longitude <span class="hljs-number">74043</span> non-null values
Location <span class="hljs-number">74043</span> non-null values
dtypes: float64(<span class="hljs-number">11</span>), <span class="hljs-built_in">object</span>(<span class="hljs-number">9</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Investigate range of values for a certain field</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>rats[<span class="hljs-string">'Current Activity'</span>].unique()
array([nan, Dispatch Crew, Request Sanitation Inspector], dtype=<span class="hljs-built_in">object</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Filter the data</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>crew_dispatched = rats[rats[<span class="hljs-string">'Current Activity'</span>] == <span class="hljs-string">'Dispatch Crew'</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(crew_dispatched)
<span class="hljs-number">65676</span>
&gt;&gt;&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Find 10 most rat-infested ZIP codes in Chicago</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>crew_dispatched[<span class="hljs-string">'ZIP Code'</span>].value_counts()[:<span class="hljs-number">10</span>]
<span class="hljs-number">60647</span> <span class="hljs-number">3837</span>
<span class="hljs-number">60618</span> <span class="hljs-number">3530</span>
<span class="hljs-number">60614</span> <span class="hljs-number">3284</span>
<span class="hljs-number">60629</span> <span class="hljs-number">3251</span>
<span class="hljs-number">60636</span> <span class="hljs-number">2801</span>
<span class="hljs-number">60657</span> <span class="hljs-number">2465</span>
<span class="hljs-number">60641</span> <span class="hljs-number">2238</span>
<span class="hljs-number">60609</span> <span class="hljs-number">2206</span>
<span class="hljs-number">60651</span> <span class="hljs-number">2152</span>
<span class="hljs-number">60632</span> <span class="hljs-number">2071</span>
&gt;&gt;&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Group by completion date</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>dates = crew_dispatched.groupby(<span class="hljs-string">'Completion Date'</span>)
&lt;pandas.core.groupby.DataFrameGroupBy <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10d0a2a10</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(dates)
<span class="hljs-number">472</span>
&gt;&gt;&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Determine counts on each day</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>date_counts = dates.size()
<span class="hljs-meta">&gt;&gt;&gt; </span>date_counts[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]
Completion Date
01/03/<span class="hljs-number">2011</span> <span class="hljs-number">4</span>
01/03/<span class="hljs-number">2012</span> <span class="hljs-number">125</span>
01/04/<span class="hljs-number">2011</span> <span class="hljs-number">54</span>
01/04/<span class="hljs-number">2012</span> <span class="hljs-number">38</span>
01/05/<span class="hljs-number">2011</span> <span class="hljs-number">78</span>
01/05/<span class="hljs-number">2012</span> <span class="hljs-number">100</span>
01/06/<span class="hljs-number">2011</span> <span class="hljs-number">100</span>
01/06/<span class="hljs-number">2012</span> <span class="hljs-number">58</span>
01/07/<span class="hljs-number">2011</span> <span class="hljs-number">1</span>
01/09/<span class="hljs-number">2012</span> <span class="hljs-number">12</span>
&gt;&gt;&gt;

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Sort the counts</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>date_counts.sort()
<span class="hljs-meta">&gt;&gt;&gt; </span>date_counts[-<span class="hljs-number">10</span>:]
Completion Date
<span class="hljs-number">10</span>/<span class="hljs-number">12</span>/<span class="hljs-number">2012</span> <span class="hljs-number">313</span>
<span class="hljs-number">10</span>/<span class="hljs-number">21</span>/<span class="hljs-number">2011</span> <span class="hljs-number">314</span>
09/<span class="hljs-number">20</span>/<span class="hljs-number">2011</span> <span class="hljs-number">316</span>
<span class="hljs-number">10</span>/<span class="hljs-number">26</span>/<span class="hljs-number">2011</span> <span class="hljs-number">319</span>
02/<span class="hljs-number">22</span>/<span class="hljs-number">2011</span> <span class="hljs-number">325</span>
<span class="hljs-number">10</span>/<span class="hljs-number">26</span>/<span class="hljs-number">2012</span> <span class="hljs-number">333</span>
03/<span class="hljs-number">17</span>/<span class="hljs-number">2011</span> <span class="hljs-number">336</span>
<span class="hljs-number">10</span>/<span class="hljs-number">13</span>/<span class="hljs-number">2011</span> <span class="hljs-number">378</span>
<span class="hljs-number">10</span>/<span class="hljs-number">14</span>/<span class="hljs-number">2011</span> <span class="hljs-number">391</span>
<span class="hljs-number">10</span>/07/<span class="hljs-number">2011</span> <span class="hljs-number">457</span>
&gt;&gt;&gt;
</code></pre>
<p>嗯，看样子2011年10月7日对老鼠们来说是个很忙碌的日子啊！^_^</p>
<h2 id="讨论">讨论</h2>
<p>Pandas 是一个拥有很多特性的大型函数库，我在这里不可能介绍完。 但是只要你需要去分析大型数据集合、对数据分组、计算各种统计量或其他类似任务的话，这个函数库真的值得你去看一看。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="files-and-io.html" class="navigation navigation-prev " aria-label="Previous page: 第五章：文件与 IO">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="functions.html" class="navigation navigation-next " aria-label="Next page: 第七章：函数">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第六章：数据编码和处理","level":"1.7","depth":1,"next":{"title":"第七章：函数","level":"1.8","depth":1,"path":"functions.md","ref":"functions.md","articles":[]},"previous":{"title":"第五章：文件与 IO","level":"1.6","depth":1,"path":"files-and-io.md","ref":"files-and-io.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"coding-and-processing-data.md","mtime":"2025-01-09T21:48:31.984Z","type":"markdown"},"gitbook":{"version":"6.0.2","time":"2025-01-11T18:48:45.487Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

