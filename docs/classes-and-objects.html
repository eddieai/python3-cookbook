
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>第八章：类与对象 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="metaprogramming.html" />
    
    
    <link rel="prev" href="functions.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="data-structures-and-algorithms.html">
            
                <a href="data-structures-and-algorithms.html">
            
                    
                    第一章：数据结构和算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="string-and-text.html">
            
                <a href="string-and-text.html">
            
                    
                    第二章：字符串和文本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="digital-date-and-time.html">
            
                <a href="digital-date-and-time.html">
            
                    
                    第三章：数字日期和时间
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="iterators-and-generators.html">
            
                <a href="iterators-and-generators.html">
            
                    
                    第四章：迭代器与生成器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="files-and-io.html">
            
                <a href="files-and-io.html">
            
                    
                    第五章：文件与 IO
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="coding-and-processing-data.html">
            
                <a href="coding-and-processing-data.html">
            
                    
                    第六章：数据编码和处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="functions.html">
            
                <a href="functions.html">
            
                    
                    第七章：函数
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.9" data-path="classes-and-objects.html">
            
                <a href="classes-and-objects.html">
            
                    
                    第八章：类与对象
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="metaprogramming.html">
            
                <a href="metaprogramming.html">
            
                    
                    第九章：元编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="module-and-pack.html">
            
                <a href="module-and-pack.html">
            
                    
                    第十章：模块与包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="network-and-web-programming.html">
            
                <a href="network-and-web-programming.html">
            
                    
                    第十一章：网络与 Web 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="concurrent-programming.html">
            
                <a href="concurrent-programming.html">
            
                    
                    第十二章：并发编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="scripting-and-systems-management.html">
            
                <a href="scripting-and-systems-management.html">
            
                    
                    第十三章：脚本编程与系统管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="testing-debugging-and-exception.html">
            
                <a href="testing-debugging-and-exception.html">
            
                    
                    第十四章：测试、调试和异常
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="c-language-extensions.html">
            
                <a href="c-language-extensions.html">
            
                    
                    第十五章：C 语言扩展
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第八章：类与对象</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第八章：类与对象">第八章：类与对象</h1>
<p>本章主要关注点的是和类定义有关的常见编程模型。包括让对象支持常见的 Python 特性、特殊方法的使用、 类封装技术、继承、内存管理以及有用的设计模式。</p>
<h1 id="81-改变对象的字符串显示">8.1 改变对象的字符串显示</h1>
<h2 id="问题">问题</h2>
<p>你想改变对象实例的打印或显示输出，让它们更具可读性。</p>
<h2 id="解决方案">解决方案</h2>
<p>要改变一个实例的字符串表示，可重新定义它的 <code>__str__()</code>和 <code>__repr__()</code> 方法。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-variable language_">self</span>.x = x
        <span class="hljs-variable language_">self</span>.y = y

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Pair({0.x!r}, {0.y!r})'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'({0.x!s}, {0.y!s})'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>)
</code></pre>
<p><code>__repr__()</code>方法返回一个实例的代码表示形式，通常用来重新构造这个实例。 内置的 <code>repr()</code>函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。 <code>__str__()</code>方法将实例转换为一个字符串，使用 <code>str()</code> 或 <code>print()</code> 函数会输出这个字符串。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Pair(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>p
Pair(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment"># __repr__() output</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p)
(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment"># __str__() output</span>
&gt;&gt;&gt;
</code></pre>
<p>我们在这里还演示了在格式化的时候怎样使用不同的字符串表现形式。 特别来讲，<code>!r</code> 格式化代码指明输出使用<code>__repr__()</code> 来代替默认的<code>__str__()</code> 。 你可以用前面的类来试着测试下：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Pair(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">'p is {0!r}'</span>.<span class="hljs-built_in">format</span>(p))
p <span class="hljs-keyword">is</span> Pair(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">'p is {0}'</span>.<span class="hljs-built_in">format</span>(p))
p <span class="hljs-keyword">is</span> (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>自定义 <code>__repr__()</code>和<code>__str__()</code> 通常是很好的习惯，因为它能简化调试和实例输出。 例如，如果仅仅只是打印输出或日志输出某个实例，那么程序员会看到实例更加详细与有用的信息。</p>
<p><code>__repr__()</code> 生成的文本字符串标准做法是需要让 <code>eval(repr(x)) == x</code>为真。 如果实在不能这样子做，应该创建一个有用的文本表示，并使用 &lt; 和 &gt; 括起来。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'file.dat'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>f
&lt;_io.TextIOWrapper name=<span class="hljs-string">'file.dat'</span> mode=<span class="hljs-string">'r'</span> encoding=<span class="hljs-string">'UTF-8'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>如果 <code>__str__()</code> 没有被定义，那么就会使用 <code>__repr__()</code> 来代替输出。</p>
<p>上面的 <code>format()</code>方法的使用看上去很有趣，格式化代码 <code>{0.x}</code>对应的是第1个参数的 x 属性。 因此，在下面的函数中，0实际上指的就是 <code>self</code>本身：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Pair({0.x!r}, {0.y!r})'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>)
</code></pre>
<p>作为这种实现的一个替代，你也可以使用 <code>%</code> 操作符，就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Pair(%r, %r)'</span> % (<span class="hljs-variable language_">self</span>.x, <span class="hljs-variable language_">self</span>.y)
</code></pre>
<h1 id="82-自定义字符串的格式化">8.2 自定义字符串的格式化</h1>
<h2 id="问题">问题</h2>
<p>你想通过 <code>format()</code>函数和字符串方法使得一个对象能支持自定义的格式化。</p>
<h2 id="解决方案">解决方案</h2>
<p>为了自定义字符串的格式化，我们需要在类上面定义<code>__format__()</code> 方法。例如：</p>
<pre><code class="lang-python">_formats = {
    <span class="hljs-string">'ymd'</span> : <span class="hljs-string">'{d.year}-{d.month}-{d.day}'</span>,
    <span class="hljs-string">'mdy'</span> : <span class="hljs-string">'{d.month}/{d.day}/{d.year}'</span>,
    <span class="hljs-string">'dmy'</span> : <span class="hljs-string">'{d.day}/{d.month}/{d.year}'</span>
    }

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        <span class="hljs-variable language_">self</span>.year = year
        <span class="hljs-variable language_">self</span>.month = month
        <span class="hljs-variable language_">self</span>.day = day

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__format__</span>(<span class="hljs-params">self, code</span>):
        <span class="hljs-keyword">if</span> code == <span class="hljs-string">''</span>:
            code = <span class="hljs-string">'ymd'</span>
        fmt = _formats[code]
        <span class="hljs-keyword">return</span> fmt.<span class="hljs-built_in">format</span>(d=<span class="hljs-variable language_">self</span>)
</code></pre>
<p>现在<code>Date</code>类的实例可以支持格式化操作了，如同下面这样：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = Date(<span class="hljs-number">2012</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">format</span>(d)
<span class="hljs-string">'2012-12-21'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">format</span>(d, <span class="hljs-string">'mdy'</span>)
<span class="hljs-string">'12/21/2012'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'The date is {:ymd}'</span>.<span class="hljs-built_in">format</span>(d)
<span class="hljs-string">'The date is 2012-12-21'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'The date is {:mdy}'</span>.<span class="hljs-built_in">format</span>(d)
<span class="hljs-string">'The date is 12/21/2012'</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p><code>__format__()</code>方法给 Python 的字符串格式化功能提供了一个钩子。 这里需要着重强调的是格式化代码的解析工作完全由类自己决定。因此，格式化代码可以是任何值。 例如，参考下面来自 <code>datetime</code> 模块中的代码：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date
<span class="hljs-meta">&gt;&gt;&gt; </span>d = date(<span class="hljs-number">2012</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">format</span>(d)
<span class="hljs-string">'2012-12-21'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">format</span>(d,<span class="hljs-string">'%A, %B %d, %Y'</span>)
<span class="hljs-string">'Friday, December 21, 2012'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'The end is {:%d %b %Y}. Goodbye'</span>.<span class="hljs-built_in">format</span>(d)
<span class="hljs-string">'The end is 21 Dec 2012. Goodbye'</span>
&gt;&gt;&gt;
</code></pre>
<p>对于内置类型的格式化有一些标准的约定。 可以参考 <a href="https://docs.python.org/3/library/string.html" target="_blank">string 模块文档</a>说明。</p>
<h1 id="83-让对象支持上下文管理协议">8.3 让对象支持上下文管理协议</h1>
<h2 id="问题">问题</h2>
<p>你想让你的对象支持上下文管理协议(with 语句)。</p>
<h2 id="解决方案">解决方案</h2>
<p>为了让一个对象兼容 <code>with</code>语句，你需要实现 <code>__enter__()</code> 和 <code>__exit__()</code> 方法。 例如，考虑如下的一个类，它能为我们创建一个网络连接：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyConnection</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, address, family=AF_INET, <span class="hljs-built_in">type</span>=SOCK_STREAM</span>):
        <span class="hljs-variable language_">self</span>.address = address
        <span class="hljs-variable language_">self</span>.family = family
        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span>
        <span class="hljs-variable language_">self</span>.sock = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.sock <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Already connected'</span>)
        <span class="hljs-variable language_">self</span>.sock = socket(<span class="hljs-variable language_">self</span>.family, <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">type</span>)
        <span class="hljs-variable language_">self</span>.sock.connect(<span class="hljs-variable language_">self</span>.address)
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.sock

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_ty, exc_val, tb</span>):
        <span class="hljs-variable language_">self</span>.sock.close()
        <span class="hljs-variable language_">self</span>.sock = <span class="hljs-literal">None</span>
</code></pre>
<p>这个类的关键特点在于它表示了一个网络连接，但是初始化的时候并不会做任何事情(比如它并没有建立一个连接)。 连接的建立和关闭是使用 <code>with</code>语句自动完成的，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial

conn = LazyConnection((<span class="hljs-string">'www.python.org'</span>, <span class="hljs-number">80</span>))
<span class="hljs-comment"># Connection closed</span>
<span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> s:
    <span class="hljs-comment"># conn.__enter__() executes: connection open</span>
    s.send(<span class="hljs-string">b'GET /index.html HTTP/1.0\r\n'</span>)
    s.send(<span class="hljs-string">b'Host: www.python.org\r\n'</span>)
    s.send(<span class="hljs-string">b'\r\n'</span>)
    resp = <span class="hljs-string">b''</span>.join(<span class="hljs-built_in">iter</span>(partial(s.recv, <span class="hljs-number">8192</span>), <span class="hljs-string">b''</span>))
    <span class="hljs-comment"># conn.__exit__() executes: connection closed</span>
</code></pre>
<h2 id="讨论">讨论</h2>
<p>编写上下文管理器的主要原理是你的代码会放到<code>with</code>语句块中执行。 当出现 <code>with</code> 语句的时候，对象的 <code>__enter__()</code>方法被触发， 它返回的值(如果有的话)会被赋值给 <code>as</code> 声明的变量。然后，<code>with</code> 语句块里面的代码开始执行。 最后，<code>__exit__()</code> 方法被触发进行清理工作。</p>
<p>不管 <code>with</code>代码块中发生什么，上面的控制流都会执行完，就算代码块中发生了异常也是一样的。 事实上，<code>__exit__()</code> 方法的第三个参数包含了异常类型、异常值和追溯信息(如果有的话)。 <code>__exit__()</code> 方法能自己决定怎样利用这个异常信息，或者忽略它并返回一个 None 值。 如果 <code>__exit__()</code> 返回 <code>True</code> ，那么异常会被清空，就好像什么都没发生一样， <code>with</code>语句后面的程序继续在正常执行。</p>
<p>还有一个细节问题就是 <code>LazyConnection</code> 类是否允许多个 <code>with</code> 语句来嵌套使用连接。 很显然，上面的定义中一次只能允许一个 socket 连接，如果正在使用一个 socket 的时候又重复使用 <code>with</code> 语句， 就会产生一个异常了。不过你可以像下面这样修改下上面的实现来解决这个问题：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyConnection</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, address, family=AF_INET, <span class="hljs-built_in">type</span>=SOCK_STREAM</span>):
        <span class="hljs-variable language_">self</span>.address = address
        <span class="hljs-variable language_">self</span>.family = family
        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span>
        <span class="hljs-variable language_">self</span>.connections = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        sock = socket(<span class="hljs-variable language_">self</span>.family, <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">type</span>)
        sock.connect(<span class="hljs-variable language_">self</span>.address)
        <span class="hljs-variable language_">self</span>.connections.append(sock)
        <span class="hljs-keyword">return</span> sock

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_ty, exc_val, tb</span>):
        <span class="hljs-variable language_">self</span>.connections.pop().close()

<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial

conn = LazyConnection((<span class="hljs-string">'www.python.org'</span>, <span class="hljs-number">80</span>))
<span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> s1:
    <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> s2:
        <span class="hljs-keyword">pass</span>
        <span class="hljs-comment"># s1 and s2 are independent sockets</span>
</code></pre>
<p>在第二个版本中，<code>LazyConnection</code> 类可以被看做是某个连接工厂。在内部，一个列表被用来构造一个栈。 每次 <code>__enter__()</code> 方法执行的时候，它复制创建一个新的连接并将其加入到栈里面。 <code>__exit__()</code> 方法简单的从栈中弹出最后一个连接并关闭它。 这里稍微有点难理解，不过它能允许嵌套使用 <code>with</code> 语句创建多个连接，就如上面演示的那样。</p>
<p>在需要管理一些资源比如文件、网络连接和锁的编程环境中，使用上下文管理器是很普遍的。 这些资源的一个主要特征是它们必须被手动的关闭或释放来确保程序的正确运行。 例如，如果你请求了一个锁，那么你必须确保之后释放了它，否则就可能产生死锁。 通过实现<code>__enter__()</code>和<code>__exit__()</code> 方法并使用<code>with</code> 语句可以很容易的避免这些问题， 因为 <code>__exit__()</code>方法可以让你无需担心这些了。</p>
<p>在<code>contextmanager</code>模块中有一个标准的上下文管理方案模板，可参考9.22小节。 同时在12.6小节中还有一个对本节示例程序的线程安全的修改版。</p>
<h1 id="84-创建大量对象时节省内存方法">8.4 创建大量对象时节省内存方法</h1>
<h2 id="问题">问题</h2>
<p>你的程序要创建大量(可能上百万)的对象，导致占用很大的内存。</p>
<h2 id="解决方案">解决方案</h2>
<p>对于主要是用来当成简单的数据结构的类而言，你可以通过给类添加 <code>__slots__</code> 属性来极大的减少实例所占的内存。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    __slots__ = [<span class="hljs-string">'year'</span>, <span class="hljs-string">'month'</span>, <span class="hljs-string">'day'</span>]
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        <span class="hljs-variable language_">self</span>.year = year
        <span class="hljs-variable language_">self</span>.month = month
        <span class="hljs-variable language_">self</span>.day = day
</code></pre>
<p>当你定义 <code>__slots__</code> 后，Python 就会为实例使用一种更加紧凑的内部表示。 实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似。 在<code>__slots__</code> 中列出的属性名在内部被映射到这个数组的指定小标上。 使用 slots 一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 <code>__slots__</code>中定义的那些属性名。</p>
<h2 id="讨论">讨论</h2>
<p>使用 slots 后节省的内存会跟存储属性的数量和类型有关。 不过，一般来讲，使用到的内存总量和将数据存储在一个元组中差不多。 为了给你一个直观认识，假设你不使用 slots 直接存储一个 Date 实例， 在64位的 Python 上面要占用428字节，而如果使用了 slots，内存占用下降到156字节。 如果程序中需要同时创建大量的日期实例，那么这个就能极大的减小内存使用量了。</p>
<p>尽管 slots 看上去是一个很有用的特性，很多时候你还是得减少对它的使用冲动。 Python 的很多特性都依赖于普通的基于字典的实现。 另外，定义了 slots 后的类不再支持一些普通类特性了，比如多继承。 大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义 slots (比如在程序中需要创建某个类的几百万个实例对象)。</p>
<p>关于 <code>__slots__</code> 的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。 尽管使用 slots 可以达到这样的目的，但是这个并不是它的初衷。 <code>__slots__</code> 更多的是用来作为一个内存优化工具。</p>
<h1 id="85-在类中封装属性名">8.5 在类中封装属性名</h1>
<h2 id="问题">问题</h2>
<p>你想封装类的实例上面的“私有”数据，但是 Python 语言并没有访问控制。</p>
<h2 id="解决方案">解决方案</h2>
<p>Python 程序员不去依赖语言特性去封装数据，而是通过遵循一定的属性和方法命名规约来达到这个效果。 第一个约定是任何以单下划线_开头的名字都应该是内部实现。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._internal = <span class="hljs-number">0</span> <span class="hljs-comment"># An internal attribute</span>
        <span class="hljs-variable language_">self</span>.public = <span class="hljs-number">1</span> <span class="hljs-comment"># A public attribute</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">public_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-string">'''
        A public method
        '''</span>
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_internal_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>Python 并不会真的阻止别人访问内部名称。但是如果你这么做肯定是不好的，可能会导致脆弱的代码。 同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数。 例如，如果你看到某个模块名以单下划线开头(比如_socket)，那它就是内部实现。 类似的，模块级别函数比如 <code>sys._getframe()</code>在使用的时候就得加倍小心了。</p>
<p>你还可能会遇到在类定义中使用两个下划线(__)开头的命名。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.__private = <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__private_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">public_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>
        <span class="hljs-variable language_">self</span>.__private_method()
</code></pre>
<p>使用双下划线开始会导致访问名称变成其他形式。 比如，在前面的类B中，私有属性会被分别重命名为<code>_B__private</code>和 <code>_B__private_method</code>。 这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">B</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-variable language_">self</span>.__private = <span class="hljs-number">1</span> <span class="hljs-comment"># Does not override B.__private</span>

    <span class="hljs-comment"># Does not override B.__private_method()</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__private_method</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>这里，私有名称<code>__private</code> 和<code>__private_method</code>被重命名为 <code>_C__private</code>和 <code>_C__private_method</code> ，这个跟父类 B 中的名称是完全不同的。</p>
<h2 id="讨论">讨论</h2>
<p>上面提到有两种不同的编码约定(单下划线和双下划线)来命名私有属性，那么问题就来了：到底哪种方式好呢？ 大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p>
<p>还有一点要注意的是，有时候你定义的一个变量和某个保留关键字冲突，这时候可以使用单下划线作为后缀，例如：</p>
<pre><code class="lang-python">lambda_ = <span class="hljs-number">2.0</span> <span class="hljs-comment"># Trailing _ to avoid clash with lambda keyword</span>
</code></pre>
<p>这里我们并不使用单下划线前缀的原因是它避免误解它的使用初衷 (如使用单下划线前缀的目的是为了防止命名冲突而不是指明这个属性是私有的)。 通过使用单下划线后缀可以解决这个问题。</p>
<h1 id="86-创建可管理的属性">8.6 创建可管理的属性</h1>
<h2 id="问题">问题</h2>
<p>你想给某个实例 attribute 增加除访问与修改之外的其他处理逻辑，比如类型检查或合法性验证。</p>
<h2 id="解决方案">解决方案</h2>
<p>自定义某个属性的一种简单方法是将它定义为一个 property。 例如，下面的代码定义了一个 property，增加对一个属性简单的类型检查：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, first_name</span>):
        <span class="hljs-variable language_">self</span>.first_name = first_name

    <span class="hljs-comment"># Getter function</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._first_name

    <span class="hljs-comment"># Setter function</span>
<span class="hljs-meta">    @first_name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
        <span class="hljs-variable language_">self</span>._first_name = value

    <span class="hljs-comment"># Deleter function (optional)</span>
<span class="hljs-meta">    @first_name.deleter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">"Can't delete attribute"</span>)
</code></pre>
<p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个 <code>getter</code> 函数，它使得 <code>first_name</code> 成为一个属性。 其他两个方法给 <code>first_name</code> 属性添加了 <code>setter</code> 和<code>deleter</code>函数。 需要强调的是只有在 <code>first_name</code>属性被创建后， 后面的两个装饰器<code>@first_name.setter</code> 和 <code>@first_name.deleter</code>才能被定义。</p>
<p>property 的一个关键特征是它看上去跟普通的 attribute 没什么两样， 但是访问它的时候会自动触发 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Person(<span class="hljs-string">'Guido'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a.first_name <span class="hljs-comment"># Calls the getter</span>
<span class="hljs-string">'Guido'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.first_name = <span class="hljs-number">42</span> <span class="hljs-comment"># Calls the setter</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"prop.py"</span>, line <span class="hljs-number">14</span>, <span class="hljs-keyword">in</span> first_name
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
TypeError: Expected a string
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a.first_name
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
AttributeError: can`t delete attribute
&gt;&gt;&gt;
</code></pre>
<p>在实现一个 property 的时候，底层数据(如果有的话)仍然需要存储在某个地方。 因此，在 get 和 set 方法中，你会看到对 <code>_first_name</code> 属性的操作，这也是实际数据保存的地方。 另外，你可能还会问为什么 <code>__init__()</code>方法中设置了 <code>self.first_name</code>而不是 <code>self._first_name</code>。 在这个例子中，我们创建一个 property 的目的就是在设置 attribute 的时候进行检查。 因此，你可能想在初始化的时候也进行这种类型检查。通过设置 <code>self.first_name</code> ，自动调用 <code>setter</code>方法， 这个方法里面会进行参数的检查，否则就是直接访问<code>self._first_name</code>了。</p>
<p>还能在已存在的 get 和 set 方法基础上定义 property。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, first_name</span>):
        <span class="hljs-variable language_">self</span>.set_first_name(first_name)

    <span class="hljs-comment"># Getter function</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_first_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._first_name

    <span class="hljs-comment"># Setter function</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_first_name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
        <span class="hljs-variable language_">self</span>._first_name = value

    <span class="hljs-comment"># Deleter function (optional)</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">del_first_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">"Can't delete attribute"</span>)

    <span class="hljs-comment"># Make a property from existing get/set methods</span>
    name = <span class="hljs-built_in">property</span>(get_first_name, set_first_name, del_first_name)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>一个 property 属性其实就是一系列相关绑定方法的集合。如果你去查看拥有 property 的类， 就会发现 property 本身的 fget、fset 和 fdel 属性就是类里面的普通方法。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>Person.first_name.fget
&lt;function Person.first_name at <span class="hljs-number">0x1006a60e0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>Person.first_name.fset
&lt;function Person.first_name at <span class="hljs-number">0x1006a6170</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>Person.first_name.fdel
&lt;function Person.first_name at <span class="hljs-number">0x1006a62e0</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>通常来讲，你不会直接取调用 fget 或者 fset，它们会在访问 property 的时候自动被触发。</p>
<p>只有当你确实需要对 attribute 执行其他额外的操作的时候才应该使用到 property。 有时候一些从其他编程语言(比如 Java)过来的程序员总认为所有访问都应该通过 getter 和 setter， 所以他们认为代码应该像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, first_name</span>):
        <span class="hljs-variable language_">self</span>.first_name = first_name

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._first_name

<span class="hljs-meta">    @first_name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-variable language_">self</span>._first_name = value
</code></pre>
<p>不要写这种没有做任何其他额外操作的 property。 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。 其次，它还会让你的程序运行起来变慢很多。 最后，这样的设计并没有带来任何的好处。 特别是当你以后想给普通 attribute 访问添加额外的处理逻辑的时候， 你可以将它变成一个 property 而无需改变原来的代码。 因为访问 attribute 的代码还是保持原样。</p>
<p>Properties 还是一种定义动态计算 attribute 的方法。 这种类型的 attributes 并不会被实际的存储，而是在需要的时候计算出来。比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> math
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):
        <span class="hljs-variable language_">self</span>.radius = radius

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> math.pi * <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameter</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span>

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">perimeter</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.pi * <span class="hljs-variable language_">self</span>.radius
</code></pre>
<p>在这里，我们通过使用 properties，将所有的访问接口形式统一起来， 对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的 attribute 是一样的。 如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用。 下面是使用的实例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = Circle(<span class="hljs-number">4.0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c.radius
<span class="hljs-number">4.0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area  <span class="hljs-comment"># Notice lack of ()</span>
<span class="hljs-number">50.26548245743669</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.perimeter  <span class="hljs-comment"># Notice lack of ()</span>
<span class="hljs-number">25.132741228718345</span>
&gt;&gt;&gt;
</code></pre>
<p>尽管 properties 可以实现优雅的编程接口，但有些时候你还是会想直接使用 getter 和 setter 函数。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person(<span class="hljs-string">'Guido'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>p.get_first_name()
<span class="hljs-string">'Guido'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p.set_first_name(<span class="hljs-string">'Larry'</span>)
&gt;&gt;&gt;
</code></pre>
<p>这种情况的出现通常是因为 Python 代码被集成到一个大型基础平台架构或程序中。 例如，有可能是一个 Python 类准备加入到一个基于远程过程调用的大型分布式系统中。 这种情况下，直接使用 get/set 方法(普通方法调用)而不是 property 或许会更容易兼容。</p>
<p>最后一点，不要像下面这样写有大量重复代码的 property 定义：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, first_name, last_name</span>):
        <span class="hljs-variable language_">self</span>.first_name = first_name
        <span class="hljs-variable language_">self</span>.last_name = last_name

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._first_name

<span class="hljs-meta">    @first_name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">first_name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
        <span class="hljs-variable language_">self</span>._first_name = value

    <span class="hljs-comment"># Repeated property code, but for a different name (bad!)</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">last_name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._last_name

<span class="hljs-meta">    @last_name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">last_name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
        <span class="hljs-variable language_">self</span>._last_name = value
</code></pre>
<p>重复代码会导致臃肿、易出错和丑陋的程序。好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情。 可以参考8.9和9.21小节的内容。</p>
<h1 id="87-调用父类方法">8.7 调用父类方法</h1>
<h2 id="问题">问题</h2>
<p>你想在子类中调用父类的某个已经被覆盖的方法。</p>
<h2 id="解决方案">解决方案</h2>
<p>为了调用父类(超类)的一个方法，可以使用 <code>super()</code> 函数，比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.spam'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.spam'</span>)
        <span class="hljs-built_in">super</span>().spam()  <span class="hljs-comment"># Call parent spam()</span>
</code></pre>
<p><code>super()</code>函数的一个常见用法是在 <code>__init__()</code>方法中确保父类被正确的初始化了：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.x = <span class="hljs-number">0</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-variable language_">self</span>.y = <span class="hljs-number">1</span>
</code></pre>
<p><code>super()</code> 的另外一个常见用法出现在覆盖 Python 特殊方法的代码中，比如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, obj</span>):
        <span class="hljs-variable language_">self</span>._obj = obj

    <span class="hljs-comment"># Delegate attribute lookup to internal obj</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>._obj, name)

    <span class="hljs-comment"># Delegate attribute assignment</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):
        <span class="hljs-keyword">if</span> name.startswith(<span class="hljs-string">'_'</span>):
            <span class="hljs-built_in">super</span>().__setattr__(name, value) <span class="hljs-comment"># Call original __setattr__</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>._obj, name, value)
</code></pre>
<p>在上面代码中，<code>__setattr__()</code>的实现包含一个名字检查。 如果某个属性名以下划线(<em>)开头，就通过<code>super()</code> 调用原始的 `<em>_setattr</em></em>()<code>， 否则的话就委派给内部的代理对象</code> self._obj <code>去处理。 这看上去有点意思，因为就算没有显式的指明某个类的父类，</code>super()` 仍然可以有效的工作。</p>
<h2 id="讨论">讨论</h2>
<p>实际上，大家对于在Python中如何正确使用 <code>super()</code>函数普遍知之甚少。 你有时候会看到像下面这样直接调用父类的一个方法：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Base.__init__'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Base</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        Base.__init__(<span class="hljs-variable language_">self</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.__init__'</span>)
</code></pre>
<p>尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。 比如，考虑如下的情况：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Base.__init__'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Base</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        Base.__init__(<span class="hljs-variable language_">self</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.__init__'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">Base</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        Base.__init__(<span class="hljs-variable language_">self</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.__init__'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(A,B):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        A.__init__(<span class="hljs-variable language_">self</span>)
        B.__init__(<span class="hljs-variable language_">self</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'C.__init__'</span>)
</code></pre>
<p>如果你运行这段代码就会发现 <code>Base.__init__()</code> 被调用两次，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = C()
Base.__init__
A.__init__
Base.__init__
B.__init__
C.__init__
&gt;&gt;&gt;
</code></pre>
<p>可能两次调用<code>Base.__init__()</code>没什么坏处，但有时候却不是。 另一方面，假设你在代码中换成使用 <code>super()</code> ，结果就很完美了：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Base.__init__'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Base</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.__init__'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">Base</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.__init__'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(A,B):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># Only one call to super() here</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'C.__init__'</span>)
</code></pre>
<p>运行这个新版本后，你会发现每个<code>__init__()</code>方法只会被调用一次了：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = C()
Base.__init__
B.__init__
A.__init__
C.__init__
&gt;&gt;&gt;
</code></pre>
<p>为了弄清它的原理，我们需要花点时间解释下 Python 是如何实现继承的。 对于你定义的每一个类而已，Python 会计算出一个所谓的方法解析顺序(MRO)列表。 这个 MRO 列表就是一个简单的所有基类的线性顺序表。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>C.__mro__
(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.C'</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.A'</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.B'</span>&gt;,
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.Base'</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'object'</span>&gt;)
&gt;&gt;&gt;
</code></pre>
<p>为了实现继承，Python 会在 MRO 列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<p>而这个 MRO 列表的构造是通过一个 C3 线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的 MRO 列表并遵循如下三条准则：</p>
<ul>
<li>子类会先于父类被检查</li>
<li>多个父类会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类
老实说，你所要知道的就是 MRO 列表中的类顺序会让你定义的任意类层级关系变得有意义。</li>
</ul>
<p>当你使用 <code>super()</code> 函数时，Python 会在 MRO 列表上继续搜索下一个类。 只要每个重定义的方法统一使用 <code>super()</code>并只调用它一次， 那么控制流最终会遍历完整个 MRO 列表，每个方法也只会被调用一次。 这也是为什么在第二个例子中你不会调用两次 <code>Base.__init__()</code> 的原因。</p>
<p><code>super()</code> 有个令人吃惊的地方是它并不一定去查找某个类在 MRO 中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.spam'</span>)
        <span class="hljs-built_in">super</span>().spam()
</code></pre>
<p>如果你试着直接使用这个类就会出错：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = A()
<span class="hljs-meta">&gt;&gt;&gt; </span>a.spam()
A.spam
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> spam
AttributeError: <span class="hljs-string">'super'</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">'spam'</span>
&gt;&gt;&gt;
</code></pre>
<p>但是，如果你使用多继承的话看看会发生什么：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self</span>):
<span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.spam'</span>)
...
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(A,B):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span>
...
<span class="hljs-meta">&gt;&gt;&gt; </span>c = C()
<span class="hljs-meta">&gt;&gt;&gt; </span>c.spam()
A.spam
B.spam
&gt;&gt;&gt;
</code></pre>
<p>你可以看到在类 A 中使用 <code>super().spam()</code> 实际上调用的是跟类 A 毫无关系的类 B 中的 <code>spam()</code> 方法。 这个用类 C 的 MRO 列表就可以完全解释清楚了：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>C.__mro__
(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.C'</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.A'</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.B'</span>&gt;,
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'object'</span>&gt;)
&gt;&gt;&gt;
</code></pre>
<p>在定义混入类的时候这样使用<code>super()</code> 是很普遍的。可以参考8.13和8.18小节。</p>
<p>然而，由于<code>super()</code> 可能会调用不是你想要的方法，你应该遵循一些通用原则。 首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。 这样可以确保 <code>super()</code> 调用一个非直接父类方法时不会出错。 其次，最好确保最顶层的类提供了这个方法的实现，这样的话在 MRO 上面的查找链肯定可以找到某个确定的方法。</p>
<p>在 Python 社区中对于<code>super()</code> 的使用有时候会引来一些争议。 尽管如此，如果一切顺利的话，你应该在你最新代码中使用它。 Raymond Hettinger 为此写了一篇非常好的文章 <a href="http://rhettinger.wordpress.com/2011/05/26/super-considered-super" target="_blank">“Python’s super() Considered Super!”</a> ， 通过大量的例子向我们解释了为什么<code>super()</code> 是极好的。</p>
<h1 id="88-子类中扩展-property">8.8 子类中扩展 property</h1>
<h2 id="问题">问题</h2>
<p>在子类中，你想要扩展定义在父类中的 property 的功能。</p>
<h2 id="解决方案">解决方案</h2>
<p>考虑如下的代码，它定义了一个 property：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

    <span class="hljs-comment"># Getter function</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._name

    <span class="hljs-comment"># Setter function</span>
<span class="hljs-meta">    @name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
        <span class="hljs-variable language_">self</span>._name = value

    <span class="hljs-comment"># Deleter function</span>
<span class="hljs-meta">    @name.deleter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">"Can't delete attribute"</span>)
</code></pre>
<p>下面是一个示例类，它继承自 Person 并扩展了 <code>name</code>属性的功能：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubPerson</span>(<span class="hljs-title class_ inherited__">Person</span>):
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting name'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().name

<span class="hljs-meta">    @name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Setting name to'</span>, value)
        <span class="hljs-built_in">super</span>(SubPerson, SubPerson).name.__set__(<span class="hljs-variable language_">self</span>, value)

<span class="hljs-meta">    @name.deleter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Deleting name'</span>)
        <span class="hljs-built_in">super</span>(SubPerson, SubPerson).name.__delete__(<span class="hljs-variable language_">self</span>)
</code></pre>
<p>接下来使用这个新类：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = SubPerson(<span class="hljs-string">'Guido'</span>)
Setting name to Guido
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name
Getting name
<span class="hljs-string">'Guido'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">'Larry'</span>
Setting name to Larry
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-number">42</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> name
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
TypeError: Expected a string
&gt;&gt;&gt;
</code></pre>
<p>如果你仅仅只想扩展 property 的某一个方法，那么可以像下面这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubPerson</span>(<span class="hljs-title class_ inherited__">Person</span>):
<span class="hljs-meta">    @Person.name.getter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting name'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().name
</code></pre>
<p>或者，你只想修改 setter 方法，就这么写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubPerson</span>(<span class="hljs-title class_ inherited__">Person</span>):
<span class="hljs-meta">    @Person.name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Setting name to'</span>, value)
        <span class="hljs-built_in">super</span>(SubPerson, SubPerson).name.__set__(<span class="hljs-variable language_">self</span>, value)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>在子类中扩展一个 property 可能会引起很多不易察觉的问题， 因为一个 property 其实是<code>getter</code>、<code>setter</code> 和 <code>deleter</code>方法的集合，而不是单个方法。 因此，但你扩展一个property的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中某一个。</p>
<p>在第一个例子中，所有的 property 方法都被重新定义。 在每一个方法中，使用了 <code>super()</code>来调用父类的实现。 在 <code>setter</code> 函数中使用<code>super(SubPerson, SubPerson).name.__set__(self, value)</code>的语句是没有错的。 为了委托给之前定义的 setter 方法，需要将控制权传递给之前定义的 name 属性的<code>__set__()</code>方法。 不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它。 这也是为什么我们要使用 <code>super(SubPerson, SubPerson)</code> 的原因。</p>
<p>如果你只想重定义其中一个方法，那只使用 @property 本身是不够的。比如，下面的代码就无法工作：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubPerson</span>(<span class="hljs-title class_ inherited__">Person</span>):
<span class="hljs-meta">    @property  </span><span class="hljs-comment"># Doesn't work</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting name'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().name
</code></pre>
<p>如果你试着运行会发现 setter 函数整个消失了：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = SubPerson(<span class="hljs-string">'Guido'</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">5</span>, <span class="hljs-keyword">in</span> __init__
        <span class="hljs-variable language_">self</span>.name = name
AttributeError: can<span class="hljs-string">'t set attribute
&gt;&gt;&gt;
</span></code></pre>
<p>你应该像之前说过的那样修改代码：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubPerson</span>(<span class="hljs-title class_ inherited__">Person</span>):
<span class="hljs-meta">    @Person.getter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting name'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().name
</code></pre>
<p>这么写后，property 之前已经定义过的方法会被复制过来，而 getter 函数被替换。然后它就能按照期望的工作了：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = SubPerson(<span class="hljs-string">'Guido'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name
Getting name
<span class="hljs-string">'Guido'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">'Larry'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name
Getting name
<span class="hljs-string">'Larry'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-number">42</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> name
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
TypeError: Expected a string
&gt;&gt;&gt;
</code></pre>
<p>在这个特别的解决方案中，我们没办法使用更加通用的方式去替换硬编码的<code>Person</code>类名。 如果你不知道到底是哪个基类定义了 property， 那你只能通过重新定义所有 property 并使用 <code>super()</code>来将控制权传递给前面的实现。</p>
<p>值的注意的是上面演示的第一种技术还可以被用来扩展一个描述器(在8.9小节我们有专门的介绍)。比如：</p>
<pre><code class="lang-python"><span class="hljs-comment"># A descriptor</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">return</span> instance.__dict__[<span class="hljs-variable language_">self</span>.name]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected a string'</span>)
        instance.__dict__[<span class="hljs-variable language_">self</span>.name] = value

<span class="hljs-comment"># A class with a descriptor</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    name = String(<span class="hljs-string">'name'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

<span class="hljs-comment"># Extending a descriptor with a property</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubPerson</span>(<span class="hljs-title class_ inherited__">Person</span>):
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting name'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().name

<span class="hljs-meta">    @name.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Setting name to'</span>, value)
        <span class="hljs-built_in">super</span>(SubPerson, SubPerson).name.__set__(<span class="hljs-variable language_">self</span>, value)

<span class="hljs-meta">    @name.deleter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Deleting name'</span>)
        <span class="hljs-built_in">super</span>(SubPerson, SubPerson).name.__delete__(<span class="hljs-variable language_">self</span>)
</code></pre>
<p>最后值的注意的是，读到这里时，你应该会发现子类化 <code>setter</code> 和 <code>deleter</code>方法其实是很简单的。 这里演示的解决方案同样适用，但是在 <a href="Python%20的%20issue%20页面">http://bugs.python.org/issue14965</a>报告的一个 bug，或许会使得将来的 Python 版本中出现一个更加简洁的方法。</p>
<h1 id="89-创建新的类或实例属性">8.9 创建新的类或实例属性</h1>
<h2 id="问题">问题</h2>
<p>你想创建一个新的拥有一些额外功能的实例属性类型，比如类型检查。</p>
<h2 id="解决方案">解决方案</h2>
<p>如果你想创建一个全新的实例属性，可以通过一个描述器类的形式来定义它的功能。下面是一个例子：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Descriptor attribute for an integer type-checked attribute</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> instance.__dict__[<span class="hljs-variable language_">self</span>.name]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected an int'</span>)
        instance.__dict__[<span class="hljs-variable language_">self</span>.name] = value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):
        <span class="hljs-keyword">del</span> instance.__dict__[<span class="hljs-variable language_">self</span>.name]
</code></pre>
<p>一个描述器就是一个实现了三个核心的属性访问操作(get, set, delete)的类， 分别为<code>__get__()</code> 、<code>__set__()</code> 和 <code>__delete__()</code> 这三个特殊的方法。 这些方法接受一个实例作为输入，之后相应的操作实例底层的字典。</p>
<p>为了使用一个描述器，需将这个描述器的实例作为类属性放到一个类的定义中。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:
    x = Integer(<span class="hljs-string">'x'</span>)
    y = Integer(<span class="hljs-string">'y'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-variable language_">self</span>.x = x
        <span class="hljs-variable language_">self</span>.y = y
</code></pre>
<p>当你这样做后，所有队描述器属性(比如 x 或 y)的访问会被 <code>__get__()</code>、<code>__set__()</code> 和<code>__delete__()</code>方法捕获到。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>p.x <span class="hljs-comment"># Calls Point.x.__get__(p,Point)</span>
<span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p.y = <span class="hljs-number">5</span> <span class="hljs-comment"># Calls Point.y.__set__(p, 5)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>p.x = <span class="hljs-number">2.3</span> <span class="hljs-comment"># Calls Point.x.__set__(p, 2.3)</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"descrip.py"</span>, line <span class="hljs-number">12</span>, <span class="hljs-keyword">in</span> __set__
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected an int'</span>)
TypeError: Expected an <span class="hljs-built_in">int</span>
&gt;&gt;&gt;
</code></pre>
<p>作为输入，描述器的每一个方法会接受一个操作实例。 为了实现请求操作，会相应的操作实例底层的字典(<strong>dict</strong>属性)。 描述器的 <code>self.name</code> 属性存储了在实例字典中被实际使用到的 key。</p>
<h2 id="讨论">讨论</h2>
<p>描述器可实现大部分Python类特性中的底层魔法， 包括<code>@classmethod</code> 、<code>@staticmethod</code> 、<code>@property</code> ，甚至是<code>__slots__</code>特性。</p>
<p>通过定义一个描述器，你可以在底层捕获核心的实例操作(get, set, delete)，并且可完全自定义它们的行为。 这是一个强大的工具，有了它你可以实现很多高级功能，并且它也是很多高级库和框架中的重要工具之一。</p>
<p>描述器的一个比较困惑的地方是它只能在类级别被定义，而不能为每个实例单独定义。因此，下面的代码是无法工作的：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Does NOT work</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-variable language_">self</span>.x = Integer(<span class="hljs-string">'x'</span>) <span class="hljs-comment"># No! Must be a class variable</span>
        <span class="hljs-variable language_">self</span>.y = Integer(<span class="hljs-string">'y'</span>)
        <span class="hljs-variable language_">self</span>.x = x
        <span class="hljs-variable language_">self</span>.y = y
</code></pre>
<p>同时，<code>__get__()</code>方法实现起来比看上去要复杂得多：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Descriptor attribute for an integer type-checked attribute</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> instance.__dict__[<span class="hljs-variable language_">self</span>.name]
</code></pre>
<p><code>__get__()</code> 看上去有点复杂的原因归结于实例变量和类变量的不同。 如果一个描述器被当做一个类变量来访问，那么 <code>instance</code> 参数被设置成 <code>None</code> 。 这种情况下，标准做法就是简单的返回这个描述器本身即可(尽管你还可以添加其他的自定义操作)。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>p.x <span class="hljs-comment"># Calls Point.x.__get__(p, Point)</span>
<span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>Point.x <span class="hljs-comment"># Calls Point.x.__get__(None, Point)</span>
&lt;__main__.Integer <span class="hljs-built_in">object</span> at <span class="hljs-number">0x100671890</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>描述器通常是那些使用到装饰器或元类的大型框架中的一个组件。同时它们的使用也被隐藏在后面。 举个例子，下面是一些更高级的基于描述器的代码，并涉及到一个类装饰器：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Descriptor for a type-checked attribute</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Typed</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, expected_type</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.expected_type = expected_type
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> instance.__dict__[<span class="hljs-variable language_">self</span>.name]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-variable language_">self</span>.expected_type):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.expected_type))
        instance.__dict__[<span class="hljs-variable language_">self</span>.name] = value
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):
        <span class="hljs-keyword">del</span> instance.__dict__[<span class="hljs-variable language_">self</span>.name]

<span class="hljs-comment"># Class decorator that applies it to selected attributes</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">typeassert</span>(<span class="hljs-params">**kwargs</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">cls</span>):
        <span class="hljs-keyword">for</span> name, expected_type <span class="hljs-keyword">in</span> kwargs.items():
            <span class="hljs-comment"># Attach a Typed descriptor to the class</span>
            <span class="hljs-built_in">setattr</span>(cls, name, Typed(name, expected_type))
        <span class="hljs-keyword">return</span> cls
    <span class="hljs-keyword">return</span> decorate

<span class="hljs-comment"># Example use</span>
<span class="hljs-meta">@typeassert(<span class="hljs-params">name=<span class="hljs-built_in">str</span>, shares=<span class="hljs-built_in">int</span>, price=<span class="hljs-built_in">float</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, shares, price</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.shares = shares
        <span class="hljs-variable language_">self</span>.price = price
</code></pre>
<p>最后要指出的一点是，如果你只是想简单的自定义某个类的单个属性访问的话就不用去写描述器了。 这种情况下使用8.6小节介绍的 property 技术会更加容易。 当程序中有很多重复代码的时候描述器就很有用了 (比如你想在你代码的很多地方使用描述器提供的功能或者将它作为一个函数库特性)。</p>
<h1 id="810-使用延迟计算属性">8.10 使用延迟计算属性</h1>
<h2 id="问题">问题</h2>
<p>你想将一个只读属性定义成一个 property，并且只在访问的时候才会计算结果。 但是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算。</p>
<h2 id="解决方案">解决方案</h2>
<p>定义一个延迟属性的一种高效方法是通过使用一个描述器类，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">lazyproperty</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):
        <span class="hljs-variable language_">self</span>.func = func

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):
        <span class="hljs-keyword">if</span> instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
        <span class="hljs-keyword">else</span>:
            value = <span class="hljs-variable language_">self</span>.func(instance)
            <span class="hljs-built_in">setattr</span>(instance, <span class="hljs-variable language_">self</span>.func.__name__, value)
            <span class="hljs-keyword">return</span> value
</code></pre>
<p>你需要像下面这样在一个类中使用它：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> math

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):
        <span class="hljs-variable language_">self</span>.radius = radius

<span class="hljs-meta">    @lazyproperty</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Computing area'</span>)
        <span class="hljs-keyword">return</span> math.pi * <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span>

<span class="hljs-meta">    @lazyproperty</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">perimeter</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Computing perimeter'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.pi * <span class="hljs-variable language_">self</span>.radius
</code></pre>
<p>下面在一个交互环境中演示它的使用：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = Circle(<span class="hljs-number">4.0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c.radius
<span class="hljs-number">4.0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
Computing area
<span class="hljs-number">50.26548245743669</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
<span class="hljs-number">50.26548245743669</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.perimeter
Computing perimeter
<span class="hljs-number">25.132741228718345</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.perimeter
<span class="hljs-number">25.132741228718345</span>
&gt;&gt;&gt;
</code></pre>
<p>仔细观察你会发现消息 <code>Computing area</code> 和 <code>Computing perimeter</code> 仅仅出现一次。</p>
<h2 id="讨论">讨论</h2>
<p>很多时候，构造一个延迟计算属性的主要目的是为了提升性能。 例如，你可以避免计算这些属性值，除非你真的需要它们。 这里演示的方案就是用来实现这样的效果的， 只不过它是通过以非常高效的方式使用描述器的一个精妙特性来达到这种效果的。</p>
<p>正如在其他小节(如8.9小节)所讲的那样，当一个描述器被放入一个类的定义时， 每次访问属性时它的 <code>__get__()</code>、<code>__set__()</code> 和<code>__delete__()</code>方法就会被触发。 不过，如果一个描述器仅仅只定义了一个<code>__get__()</code> 方法的话，它比通常的具有更弱的绑定。 特别地，只有当被访问属性不在实例底层的字典中时<code>__get__()</code>方法才会被触发。</p>
<p><code>lazyproperty</code>类利用这一点，使用 <code>__get__()</code> 方法在实例中存储计算出来的值， 这个实例使用相同的名字作为它的 property。 这样一来，结果值被存储在实例字典中并且以后就不需要再去计算这个 property 了。 你可以尝试更深入的例子来观察结果：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = Circle(<span class="hljs-number">4.0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Get instance variables</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">vars</span>(c)
{<span class="hljs-string">'radius'</span>: <span class="hljs-number">4.0</span>}

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Compute area and observe variables afterward</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
Computing area
<span class="hljs-number">50.26548245743669</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">vars</span>(c)
{<span class="hljs-string">'area'</span>: <span class="hljs-number">50.26548245743669</span>, <span class="hljs-string">'radius'</span>: <span class="hljs-number">4.0</span>}

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Notice access doesn't invoke property anymore</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
<span class="hljs-number">50.26548245743669</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Delete the variable and see property trigger again</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> c.area
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">vars</span>(c)
{<span class="hljs-string">'radius'</span>: <span class="hljs-number">4.0</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
Computing area
<span class="hljs-number">50.26548245743669</span>
&gt;&gt;&gt;
</code></pre>
<p>这种方案有一个小缺陷就是计算出的值被创建后是可以被修改的。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c.area
Computing area
<span class="hljs-number">50.26548245743669</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area = <span class="hljs-number">25</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
<span class="hljs-number">25</span>
&gt;&gt;&gt;
</code></pre>
<p>如果你担心这个问题，那么可以使用一种稍微没那么高效的实现，就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lazyproperty</span>(<span class="hljs-params">func</span>):
    name = <span class="hljs-string">'_lazy_'</span> + func.__name__
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lazy</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(<span class="hljs-variable language_">self</span>, name):
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, name)
        <span class="hljs-keyword">else</span>:
            value = func(<span class="hljs-variable language_">self</span>)
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, value)
            <span class="hljs-keyword">return</span> value
    <span class="hljs-keyword">return</span> lazy
</code></pre>
<p>如果你使用这个版本，就会发现现在修改操作已经不被允许了：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = Circle(<span class="hljs-number">4.0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
Computing area
<span class="hljs-number">50.26548245743669</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area
<span class="hljs-number">50.26548245743669</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.area = <span class="hljs-number">25</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
AttributeError: can<span class="hljs-string">'t set attribute
&gt;&gt;&gt;
</span></code></pre>
<p>然而，这种方案有一个缺点就是所有get操作都必须被定向到属性的<code>getter</code> 函数上去。 这个跟之前简单的在实例字典中查找值的方案相比效率要低一点。 如果想获取更多关于 property 和可管理属性的信息，可以参考8.6小节。而描述器的相关内容可以在8.9小节找到。</p>
<h1 id="811-简化数据结构的初始化">8.11 简化数据结构的初始化</h1>
<h2 id="问题">问题</h2>
<p>你写了很多仅仅用作数据结构的类，不想写太多烦人的 <code>__init__()</code>函数</p>
<h2 id="解决方案">解决方案</h2>
<p>可以在一个基类中写一个公用的 <code>__init__()</code> 函数：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> math

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure1</span>:
    <span class="hljs-comment"># Class variable that specifies expected fields</span>
    _fields = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected {} arguments'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields)))
        <span class="hljs-comment"># Set the arguments</span>
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-variable language_">self</span>._fields, args):
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, value)
</code></pre>
<p>然后使你的类继承自这个基类:</p>
<pre><code class="lang-python"><span class="hljs-comment"># Example class definitions</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Structure1</span>):
    _fields = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(<span class="hljs-title class_ inherited__">Structure1</span>):
    _fields = [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-title class_ inherited__">Structure1</span>):
    _fields = [<span class="hljs-string">'radius'</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> math.pi * <span class="hljs-variable language_">self</span>.radius ** <span class="hljs-number">2</span>
</code></pre>
<p>使用这些类的示例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c = Circle(<span class="hljs-number">4.5</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>s2 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"structure.py"</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> __init__
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected {} arguments'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields)))
TypeError: Expected <span class="hljs-number">3</span> arguments
</code></pre>
<p>如果还想支持关键字参数，可以将关键字参数设置为实例属性：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure2</span>:
    _fields = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &gt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected {} arguments'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields)))

        <span class="hljs-comment"># Set all of the positional arguments</span>
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-variable language_">self</span>._fields, args):
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, value)

        <span class="hljs-comment"># Set the remaining keyword arguments</span>
        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._fields[<span class="hljs-built_in">len</span>(args):]:
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, kwargs.pop(name))

        <span class="hljs-comment"># Check for any remaining unknown arguments</span>
        <span class="hljs-keyword">if</span> kwargs:
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Invalid argument(s): {}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">','</span>.join(kwargs)))
<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Structure2</span>):
        _fields = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>]

    s1 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>)
    s2 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, price=<span class="hljs-number">91.1</span>)
    s3 = Stock(<span class="hljs-string">'ACME'</span>, shares=<span class="hljs-number">50</span>, price=<span class="hljs-number">91.1</span>)
    <span class="hljs-comment"># s3 = Stock('ACME', shares=50, price=91.1, aa=1)</span>
</code></pre>
<p>你还能将不在 <code>_fields</code> 中的名称加入到属性中去：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure3</span>:
    <span class="hljs-comment"># Class variable that specifies expected fields</span>
    _fields = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected {} arguments'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields)))

        <span class="hljs-comment"># Set the arguments</span>
        <span class="hljs-keyword">for</span> name, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-variable language_">self</span>._fields, args):
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, value)

        <span class="hljs-comment"># Set the additional arguments (if any)</span>
        extra_args = kwargs.keys() - <span class="hljs-variable language_">self</span>._fields
        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> extra_args:
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, name, kwargs.pop(name))

        <span class="hljs-keyword">if</span> kwargs:
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Duplicate values for {}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">','</span>.join(kwargs)))

<span class="hljs-comment"># Example use</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Structure3</span>):
        _fields = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'shares'</span>, <span class="hljs-string">'price'</span>]

    s1 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>)
    s2 = Stock(<span class="hljs-string">'ACME'</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.1</span>, date=<span class="hljs-string">'8/2/2012'</span>)
</code></pre>
<h2 id="讨论">讨论</h2>
<p>当你需要使用大量很小的数据结构类的时候， 相比手工一个个定义 <code>__init__()</code>方法而已，使用这种方式可以大大简化代码。</p>
<p>在上面的实现中我们使用了<code>setattr()</code> 函数类设置属性值， 你可能不想用这种方式，而是想直接更新实例字典，就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Structure</span>:
    <span class="hljs-comment"># Class variable that specifies expected fields</span>
    _fields= []
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) != <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected {} arguments'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._fields)))

        <span class="hljs-comment"># Set the arguments (alternate)</span>
        <span class="hljs-variable language_">self</span>.__dict__.update(<span class="hljs-built_in">zip</span>(<span class="hljs-variable language_">self</span>._fields,args))
</code></pre>
<p>尽管这也可以正常工作，但是当定义子类的时候问题就来了。 当一个子类定义了 <code>__slots__</code>或者通过 property(或描述器)来包装某个属性， 那么直接访问实例字典就不起作用了。我们上面使用<code>setattr()</code>会显得更通用些，因为它也适用于子类情况。</p>
<p>这种方法唯一不好的地方就是对某些 IDE 而已，在显示帮助函数时可能不太友好。比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(Stock)
Help on <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> <span class="hljs-keyword">in</span> module __main__:
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>(<span class="hljs-title class_ inherited__">Structure</span>)
...
| Methods inherited <span class="hljs-keyword">from</span> Structure:
|
| __init__(<span class="hljs-variable language_">self</span>, *args, **kwargs)
|
...
&gt;&gt;&gt;
</code></pre>
<p>可以参考9.16小节来强制在<code>__init__()</code> 方法中指定参数的类型签名。</p>
<h1 id="812-定义接口或者抽象基类">8.12 定义接口或者抽象基类</h1>
<h2 id="问题">问题</h2>
<p>你想定义一个接口或抽象类，并且通过执行类型检查来确保子类实现了某些特定的方法</p>
<h2 id="解决方案">解决方案</h2>
<p>使用<code>abc</code>模块可以很轻松的定义抽象基类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod

<span class="hljs-keyword">class</span> <span class="hljs-title class_">IStream</span>(metaclass=ABCMeta):
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, maxbytes=-<span class="hljs-number">1</span></span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>抽象类的一个特点是它不能直接被实例化，比如你想像下面这样做是不行的：</p>
<pre><code class="lang-python">a = IStream() <span class="hljs-comment"># TypeError: Can't instantiate abstract class</span>
                <span class="hljs-comment"># IStream with abstract methods read, write</span>
</code></pre>
<p>抽象类的目的就是让别的类继承它并实现特定的抽象方法：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketStream</span>(<span class="hljs-title class_ inherited__">IStream</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, maxbytes=-<span class="hljs-number">1</span></span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">obj, stream</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(stream, IStream):
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'Expected an IStream'</span>)
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>除了继承这种方式外，还可以通过注册方式来让某个类实现抽象基类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> io

<span class="hljs-comment"># Register the built-in I/O classes as supporting our interface</span>
IStream.register(io.IOBase)

<span class="hljs-comment"># Open a normal file and type check</span>
f = <span class="hljs-built_in">open</span>(<span class="hljs-string">'foo.txt'</span>)
<span class="hljs-built_in">isinstance</span>(f, IStream) <span class="hljs-comment"># Returns True</span>
</code></pre>
<p><code>@abstractmethod</code>还能注解静态方法、类方法和 <code>properties</code> 。 你只需保证这个注解紧靠在函数定义前即可：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(metaclass=ABCMeta):
<span class="hljs-meta">    @property</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @name.setter</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @classmethod</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params">cls</span>):
        <span class="hljs-keyword">pass</span>

<span class="hljs-meta">    @staticmethod</span>
<span class="hljs-meta">    @abstractmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">method2</span>():
        <span class="hljs-keyword">pass</span>
</code></pre>
<h2 id="讨论">讨论</h2>
<p>标准库中有很多用到抽象基类的地方。<code>collections</code>模块定义了很多跟容器和迭代器(序列、映射、集合等)有关的抽象基类。 <code>numbers</code>库定义了跟数字对象(整数、浮点数、有理数等)有关的基类。<code>io</code> 库定义了很多跟 I/O 操作相关的基类。</p>
<p>你可以使用预定义的抽象类来执行更通用的类型检查，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> collections

<span class="hljs-comment"># Check if x is a sequence</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, collections.<span class="hljs-type">Sequence</span>):
...

<span class="hljs-comment"># Check if x is iterable</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, collections.Iterable):
...

<span class="hljs-comment"># Check if x has a size</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, collections.Sized):
...

<span class="hljs-comment"># Check if x is a mapping</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(x, collections.Mapping):
</code></pre>
<p>尽管 ABCs 可以让我们很方便的做类型检查，但是我们在代码中最好不要过多的使用它。 因为 Python 的本质是一门动态编程语言，其目的就是给你更多灵活性， 强制类型检查或让你代码变得更复杂，这样做无异于舍本求末。</p>
<h1 id="813-实现数据模型的类型约束">8.13 实现数据模型的类型约束</h1>
<h2 id="问题">问题</h2>
<p>你想定义某些在属性赋值上面有限制的数据结构。</p>
<h2 id="解决方案">解决方案</h2>
<p>在这个问题中，你需要在对某些实例属性赋值时进行检查。 所以你要自定义属性赋值函数，这种情况下最好使用描述器。</p>
<p>下面的代码使用描述器实现了一个系统类型和赋值验证框架：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Base class. Uses a descriptor to set a value</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Descriptor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-literal">None</span>, **opts</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> opts.items():
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, key, value)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        instance.__dict__[<span class="hljs-variable language_">self</span>.name] = value


<span class="hljs-comment"># Descriptor for enforcing types</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Typed</span>(<span class="hljs-title class_ inherited__">Descriptor</span>):
    expected_type = <span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-variable language_">self</span>.expected_type):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'expected '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.expected_type))
        <span class="hljs-built_in">super</span>().__set__(instance, value)


<span class="hljs-comment"># Descriptor for enforcing values</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Unsigned</span>(<span class="hljs-title class_ inherited__">Descriptor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Expected &gt;= 0'</span>)
        <span class="hljs-built_in">super</span>().__set__(instance, value)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxSized</span>(<span class="hljs-title class_ inherited__">Descriptor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-literal">None</span>, **opts</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-string">'size'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> opts:
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'missing size option'</span>)
        <span class="hljs-built_in">super</span>().__init__(name, **opts)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(value) &gt;= <span class="hljs-variable language_">self</span>.size:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'size must be &lt; '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.size))
        <span class="hljs-built_in">super</span>().__set__(instance, value)
</code></pre>
<p>这些类就是你要创建的数据模型或类型系统的基础构建模块。 下面就是我们实际定义的各种不同的数据类型：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-title class_ inherited__">Typed</span>):
    expected_type = <span class="hljs-built_in">int</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsignedInteger</span>(Integer, Unsigned):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Float</span>(<span class="hljs-title class_ inherited__">Typed</span>):
    expected_type = <span class="hljs-built_in">float</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsignedFloat</span>(Float, Unsigned):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>(<span class="hljs-title class_ inherited__">Typed</span>):
    expected_type = <span class="hljs-built_in">str</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SizedString</span>(String, MaxSized):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>然后使用这些自定义数据类型，我们定义一个类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>:
    <span class="hljs-comment"># Specify constraints</span>
    name = SizedString(<span class="hljs-string">'name'</span>, size=<span class="hljs-number">8</span>)
    shares = UnsignedInteger(<span class="hljs-string">'shares'</span>)
    price = UnsignedFloat(<span class="hljs-string">'price'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, shares, price</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.shares = shares
        <span class="hljs-variable language_">self</span>.price = price
</code></pre>
<p>然后测试这个类的属性赋值约束，可发现对某些属性的赋值违法了约束是不合法的：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s.name
<span class="hljs-string">'ACME'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.shares = <span class="hljs-number">75</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.shares = -<span class="hljs-number">10</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">17</span>, <span class="hljs-keyword">in</span> __set__
        <span class="hljs-built_in">super</span>().__set__(instance, value)
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">23</span>, <span class="hljs-keyword">in</span> __set__
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Expected &gt;= 0'</span>)
ValueError: Expected &gt;= <span class="hljs-number">0</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>s.price = <span class="hljs-string">'a lot'</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">16</span>, <span class="hljs-keyword">in</span> __set__
        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'expected '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.expected_type))
TypeError: expected &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'float'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">'ABRACADABRA'</span>
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">17</span>, <span class="hljs-keyword">in</span> __set__
        <span class="hljs-built_in">super</span>().__set__(instance, value)
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">35</span>, <span class="hljs-keyword">in</span> __set__
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'size must be &lt; '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.size))
ValueError: size must be &lt; <span class="hljs-number">8</span>
&gt;&gt;&gt;
</code></pre>
<p>还有一些技术可以简化上面的代码，其中一种是使用类装饰器：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Class decorator to apply constraints</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">check_attributes</span>(<span class="hljs-params">**kwargs</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">cls</span>):
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> kwargs.items():
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, Descriptor):
                value.name = key
                <span class="hljs-built_in">setattr</span>(cls, key, value)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-built_in">setattr</span>(cls, key, value(key))
        <span class="hljs-keyword">return</span> cls

    <span class="hljs-keyword">return</span> decorate

<span class="hljs-comment"># Example</span>
<span class="hljs-meta">@check_attributes(<span class="hljs-params">name=SizedString(<span class="hljs-params">size=<span class="hljs-number">8</span></span>),
                  shares=UnsignedInteger,
                  price=UnsignedFloat</span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, shares, price</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.shares = shares
        <span class="hljs-variable language_">self</span>.price = price
</code></pre>
<p>另外一种方式是使用元类：</p>
<pre><code class="lang-python"><span class="hljs-comment"># A metaclass that applies checking</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">checkedmeta</span>(<span class="hljs-title class_ inherited__">type</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, clsname, bases, methods</span>):
        <span class="hljs-comment"># Attach attribute names to the descriptors</span>
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> methods.items():
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, Descriptor):
                value.name = key
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>.__new__(cls, clsname, bases, methods)

<span class="hljs-comment"># Example</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock2</span>(metaclass=checkedmeta):
    name = SizedString(size=<span class="hljs-number">8</span>)
    shares = UnsignedInteger()
    price = UnsignedFloat()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, shares, price</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.shares = shares
        <span class="hljs-variable language_">self</span>.price = price
</code></pre>
<h2 id="讨论">讨论</h2>
<p>本节使用了很多高级技术，包括描述器、混入类、<code>super()</code> 的使用、类装饰器和元类。 不可能在这里一一详细展开来讲，但是可以在8.9、8.18、9.19小节找到更多例子。 但是，我在这里还是要提一下几个需要注意的点。</p>
<p>首先，在 <code>Descriptor</code>基类中你会看到有个 <code>__set__()</code>方法，却没有相应的 <code>__get__()</code>方法。 如果一个描述仅仅是从底层实例字典中获取某个属性值的话，那么没必要去定义<code>__get__()</code> 方法。</p>
<p>所有描述器类都是基于混入类来实现的。比如 <code>Unsigned</code> 和 <code>MaxSized</code>要跟其他继承自<code>Typed</code>类混入。 这里利用多继承来实现相应的功能。</p>
<p>混入类的一个比较难理解的地方是，调用 <code>super()</code> 函数时，你并不知道究竟要调用哪个具体类。 你需要跟其他类结合后才能正确的使用，也就是必须合作才能产生效果。</p>
<p>使用类装饰器和元类通常可以简化代码。上面两个例子中你会发现你只需要输入一次属性名即可了。</p>
<pre><code class="lang-python"><span class="hljs-comment"># Normal</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:
    x = Integer(<span class="hljs-string">'x'</span>)
    y = Integer(<span class="hljs-string">'y'</span>)

<span class="hljs-comment"># Metaclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>(metaclass=checkedmeta):
    x = Integer()
    y = Integer()
</code></pre>
<p>所有方法中，类装饰器方案应该是最灵活和最高明的。 首先，它并不依赖任何其他新的技术，比如元类。其次，装饰器可以很容易的添加或删除。</p>
<p>最后，装饰器还能作为混入类的替代技术来实现同样的效果;</p>
<pre><code class="lang-python"><span class="hljs-comment"># Decorator for applying type checking</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">Typed</span>(<span class="hljs-params">expected_type, cls=<span class="hljs-literal">None</span></span>):
    <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> cls: Typed(expected_type, cls)
    super_set = cls.__set__

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, expected_type):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'expected '</span> + <span class="hljs-built_in">str</span>(expected_type))
        super_set(<span class="hljs-variable language_">self</span>, instance, value)

    cls.__set__ = __set__
    <span class="hljs-keyword">return</span> cls


<span class="hljs-comment"># Decorator for unsigned values</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">Unsigned</span>(<span class="hljs-params">cls</span>):
    super_set = cls.__set__

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Expected &gt;= 0'</span>)
        super_set(<span class="hljs-variable language_">self</span>, instance, value)

    cls.__set__ = __set__
    <span class="hljs-keyword">return</span> cls


<span class="hljs-comment"># Decorator for allowing sized values</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">MaxSized</span>(<span class="hljs-params">cls</span>):
    super_init = cls.__init__

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-literal">None</span>, **opts</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-string">'size'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> opts:
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'missing size option'</span>)
        super_init(<span class="hljs-variable language_">self</span>, name, **opts)

    cls.__init__ = __init__

    super_set = cls.__set__

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(value) &gt;= <span class="hljs-variable language_">self</span>.size:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'size must be &lt; '</span> + <span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.size))
        super_set(<span class="hljs-variable language_">self</span>, instance, value)

    cls.__set__ = __set__
    <span class="hljs-keyword">return</span> cls


<span class="hljs-comment"># Specialized descriptors</span>
<span class="hljs-meta">@Typed(<span class="hljs-params"><span class="hljs-built_in">int</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-title class_ inherited__">Descriptor</span>):
    <span class="hljs-keyword">pass</span>


<span class="hljs-meta">@Unsigned</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsignedInteger</span>(<span class="hljs-title class_ inherited__">Integer</span>):
    <span class="hljs-keyword">pass</span>


<span class="hljs-meta">@Typed(<span class="hljs-params"><span class="hljs-built_in">float</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Float</span>(<span class="hljs-title class_ inherited__">Descriptor</span>):
    <span class="hljs-keyword">pass</span>


<span class="hljs-meta">@Unsigned</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsignedFloat</span>(<span class="hljs-title class_ inherited__">Float</span>):
    <span class="hljs-keyword">pass</span>


<span class="hljs-meta">@Typed(<span class="hljs-params"><span class="hljs-built_in">str</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>(<span class="hljs-title class_ inherited__">Descriptor</span>):
    <span class="hljs-keyword">pass</span>


<span class="hljs-meta">@MaxSized</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SizedString</span>(<span class="hljs-title class_ inherited__">String</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>这种方式定义的类跟之前的效果一样，而且执行速度会更快。 设置一个简单的类型属性的值，装饰器方式要比之前的混入类的方式几乎快100%。 现在你应该庆幸自己读完了本节全部内容了吧？^_^</p>
<h1 id="814-实现自定义容器">8.14 实现自定义容器</h1>
<h2 id="问题">问题</h2>
<p>你想实现一个自定义的类来模拟内置的容器类功能，比如列表和字典。但是你不确定到底要实现哪些方法。</p>
<h2 id="解决方案">解决方案</h2>
<p><code>collections</code>定义了很多抽象基类，当你想自定义容器类的时候它们会非常有用。 比如你想让你的类支持迭代，那就让你的类继承 <code>collections.Iterable</code> 即可：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> collections
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(collections.Iterable):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>不过你需要实现 <code>collections.Iterable</code>所有的抽象方法，否则会报错:</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = A()
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: Can<span class="hljs-string">'t instantiate abstract class A with abstract methods __iter__
&gt;&gt;&gt;
</span></code></pre>
<p>你只要实现<code>__iter__()</code>方法就不会报错了(参考4.2和4.7小节)。</p>
<p>你可以先试着去实例化一个对象，在错误提示中可以找到需要实现哪些方法：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> collections
<span class="hljs-meta">&gt;&gt;&gt; </span>collections.<span class="hljs-type">Sequence</span>()
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: Can<span class="hljs-string">'t instantiate abstract class Sequence with abstract methods \
__getitem__, __len__
&gt;&gt;&gt;
</span></code></pre>
<p>下面是一个简单的示例，继承自上面 Sequence 抽象类，并且实现元素按照顺序存储：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortedItems</span>(collections.<span class="hljs-type">Sequence</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initial=<span class="hljs-literal">None</span></span>):
        <span class="hljs-variable language_">self</span>._items = <span class="hljs-built_in">sorted</span>(initial) <span class="hljs-keyword">if</span> initial <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> []

    <span class="hljs-comment"># Required sequence methods</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._items[index]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._items)

    <span class="hljs-comment"># Method for adding an item in the right location</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, item</span>):
        bisect.insort(<span class="hljs-variable language_">self</span>._items, item)


items = SortedItems([<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>])
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(items))
<span class="hljs-built_in">print</span>(items[<span class="hljs-number">0</span>], items[-<span class="hljs-number">1</span>])
items.add(<span class="hljs-number">2</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(items))
</code></pre>
<p>可以看到，SortedItems 跟普通的序列没什么两样，支持所有常用操作，包括索引、迭代、包含判断，甚至是切片操作。</p>
<p>这里面使用到了<code>bisect</code>模块，它是一个在排序列表中插入元素的高效方式。可以保证元素插入后还保持顺序。</p>
<h2 id="讨论">讨论</h2>
<p>使用 <code>collections</code>中的抽象基类可以确保你自定义的容器实现了所有必要的方法。并且还能简化类型检查。 你的自定义容器会满足大部分类型检查需要，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>items = SortedItems()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> collections
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(items, collections.Iterable)
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(items, collections.<span class="hljs-type">Sequence</span>)
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(items, collections.Container)
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(items, collections.Sized)
<span class="hljs-literal">True</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(items, collections.Mapping)
<span class="hljs-literal">False</span>
&gt;&gt;&gt;
</code></pre>
<p><code>collections</code>中很多抽象类会为一些常见容器操作提供默认的实现， 这样一来你只需要实现那些你最感兴趣的方法即可。假设你的类继承自 <code>collections.MutableSequence</code> ，如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Items</span>(collections.MutableSequence):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, initial=<span class="hljs-literal">None</span></span>):
        <span class="hljs-variable language_">self</span>._items = <span class="hljs-built_in">list</span>(initial) <span class="hljs-keyword">if</span> initial <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> []

    <span class="hljs-comment"># Required sequence methods</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting:'</span>, index)
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._items[index]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, index, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Setting:'</span>, index, value)
        <span class="hljs-variable language_">self</span>._items[index] = value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, index</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Deleting:'</span>, index)
        <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>._items[index]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, index, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Inserting:'</span>, index, value)
        <span class="hljs-variable language_">self</span>._items.insert(index, value)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Len'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._items)
</code></pre>
<p>如果你创建 <code>Items</code>的实例，你会发现它支持几乎所有的核心列表方法(如 append()、remove()、count()等)。 下面是使用演示：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Items([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(a)
Len
<span class="hljs-number">3</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-number">4</span>)
Len
Inserting: <span class="hljs-number">3</span> <span class="hljs-number">4</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-number">2</span>)
Len
Inserting: <span class="hljs-number">4</span> <span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.count(<span class="hljs-number">2</span>)
Getting: <span class="hljs-number">0</span>
Getting: <span class="hljs-number">1</span>
Getting: <span class="hljs-number">2</span>
Getting: <span class="hljs-number">3</span>
Getting: <span class="hljs-number">4</span>
Getting: <span class="hljs-number">5</span>
<span class="hljs-number">2</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>a.remove(<span class="hljs-number">3</span>)
Getting: <span class="hljs-number">0</span>
Getting: <span class="hljs-number">1</span>
Getting: <span class="hljs-number">2</span>
Deleting: <span class="hljs-number">2</span>
&gt;&gt;&gt;
</code></pre>
<p>本小节只是对 Python 抽象类功能的抛砖引玉。<code>numbers</code>模块提供了一个类似的跟整数类型相关的抽象类型集合。 可以参考8.12小节来构造更多自定义抽象基类。</p>
<h1 id="815-属性的代理访问">8.15 属性的代理访问</h1>
<h2 id="问题">问题</h2>
<p>你想将某个实例的属性访问代理到内部另一个实例中去，目的可能是作为继承的一个替代方法或者实现代理模式。</p>
<h2 id="解决方案">解决方案</h2>
<p>简单来说，代理是一种编程模式，它将某个操作转移给另外一个对象来实现。 最简单的形式可能是像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span>:
    <span class="hljs-string">"""简单的代理"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._a = A()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-comment"># Delegate to the internal self._a instance</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._a.spam(x)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):
        <span class="hljs-comment"># Delegate to the internal self._a instance</span>
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._a.foo()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>如果仅仅就两个方法需要代理，那么像这样写就足够了。但是，如果有大量的方法需要代理， 那么使用<code>__getattr__()</code> 方法或许或更好些：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B2</span>:
    <span class="hljs-string">"""使用__getattr__的代理，代理方法比较多时候"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._a = A()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">pass</span>

    <span class="hljs-comment"># Expose all of the methods defined on class A</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-string">"""这个方法在访问的attribute不存在的时候被调用
        the __getattr__() method is actually a fallback method
        that only gets called when an attribute is not found"""</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>._a, name)
</code></pre>
<p><code>__getattr__</code>方法是在访问 attribute 不存在的时候被调用，使用演示：</p>
<pre><code class="lang-python">b = B()
b.bar() <span class="hljs-comment"># Calls B.bar() (exists on B)</span>
b.spam(<span class="hljs-number">42</span>) <span class="hljs-comment"># Calls B.__getattr__('spam') and delegates to A.spam</span>
</code></pre>
<p>另外一个代理例子是实现代理模式，例如：</p>
<pre><code class="lang-python"><span class="hljs-comment"># A proxy class that wraps around another object, but</span>
<span class="hljs-comment"># exposes its public attributes</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, obj</span>):
        <span class="hljs-variable language_">self</span>._obj = obj

    <span class="hljs-comment"># Delegate attribute lookup to internal obj</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'getattr:'</span>, name)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>._obj, name)

    <span class="hljs-comment"># Delegate attribute assignment</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):
        <span class="hljs-keyword">if</span> name.startswith(<span class="hljs-string">'_'</span>):
            <span class="hljs-built_in">super</span>().__setattr__(name, value)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'setattr:'</span>, name, value)
            <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>._obj, name, value)

    <span class="hljs-comment"># Delegate attribute deletion</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">if</span> name.startswith(<span class="hljs-string">'_'</span>):
            <span class="hljs-built_in">super</span>().__delattr__(name)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'delattr:'</span>, name)
            <span class="hljs-built_in">delattr</span>(<span class="hljs-variable language_">self</span>._obj, name)
</code></pre>
<p>使用这个代理类时，你只需要用它来包装下其他类即可：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-variable language_">self</span>.x = x

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self, y</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Spam.bar:'</span>, <span class="hljs-variable language_">self</span>.x, y)

<span class="hljs-comment"># Create an instance</span>
s = Spam(<span class="hljs-number">2</span>)
<span class="hljs-comment"># Create a proxy around it</span>
p = Proxy(s)
<span class="hljs-comment"># Access the proxy</span>
<span class="hljs-built_in">print</span>(p.x)  <span class="hljs-comment"># Outputs 2</span>
p.bar(<span class="hljs-number">3</span>)  <span class="hljs-comment"># Outputs "Spam.bar: 2 3"</span>
p.x = <span class="hljs-number">37</span>  <span class="hljs-comment"># Changes s.x to 37</span>
</code></pre>
<p>通过自定义属性访问方法，你可以用不同方式自定义代理类行为(比如加入日志功能、只读访问等)。</p>
<h2 id="讨论">讨论</h2>
<p>代理类有时候可以作为继承的替代方案。例如，一个简单的继承如下：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.spam'</span>, x)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.foo'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.spam'</span>)
        <span class="hljs-built_in">super</span>().spam(x)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.bar'</span>)
</code></pre>
<p>使用代理的话，就是下面这样：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.spam'</span>, x)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'A.foo'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._a = A()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.spam'</span>, x)
        <span class="hljs-variable language_">self</span>._a.spam(x)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'B.bar'</span>)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>._a, name)
</code></pre>
<p>当实现代理模式时，还有些细节需要注意。 首先，<code>__getattr__()</code> 实际是一个后备方法，只有在属性不存在时才会调用。 因此，如果代理类实例本身有这个属性的话，那么不会触发这个方法的。 另外，<code>__setattr__()</code> 和<code>__delattr__()</code> 需要额外的魔法来区分代理实例和被代理实例 <code>_obj</code>的属性。 一个通常的约定是只代理那些不以下划线<code>_</code>开头的属性(代理类只暴露被代理类的公共属性)。</p>
<p>还有一点需要注意的是，<code>__getattr__()</code> 对于大部分以双下划线(__)开始和结尾的属性并不适用。 比如，考虑如下的类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListLike</span>:
    <span class="hljs-string">"""__getattr__对于双下划线开始和结尾的方法是不能用的，需要一个个去重定义"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._items = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>._items, name)
</code></pre>
<p>如果是创建一个 ListLike 对象，会发现它支持普通的列表方法，如 append()和 insert()， 但是却不支持 len()、元素查找等。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = ListLike()
<span class="hljs-meta">&gt;&gt;&gt; </span>a.append(<span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a.insert(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a.sort()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(a)
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: <span class="hljs-built_in">object</span> of <span class="hljs-built_in">type</span> <span class="hljs-string">'ListLike'</span> has no <span class="hljs-built_in">len</span>()
<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>]
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
TypeError: <span class="hljs-string">'ListLike'</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support indexing
&gt;&gt;&gt;
</code></pre>
<p>为了让它支持这些方法，你必须手动的实现这些方法代理：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListLike</span>:
    <span class="hljs-string">"""__getattr__对于双下划线开始和结尾的方法是不能用的，需要一个个去重定义"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._items = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>._items, name)

    <span class="hljs-comment"># Added special methods to support certain list operations</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._items)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._items[index]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, index, value</span>):
        <span class="hljs-variable language_">self</span>._items[index] = value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, index</span>):
        <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>._items[index]
</code></pre>
<p>11.8小节还有一个在远程方法调用环境中使用代理的例子。</p>
<h1 id="816-在类中定义多个构造器">8.16 在类中定义多个构造器</h1>
<h2 id="问题">问题</h2>
<p>你想实现一个类，除了使用 <code>__init__()</code>方法外，还有其他方式可以初始化它。</p>
<h2 id="解决方案">解决方案</h2>
<p>为了实现多个构造器，你需要使用到类方法。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> time

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-string">"""方法一：使用类方法"""</span>
    <span class="hljs-comment"># Primary constructor</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        <span class="hljs-variable language_">self</span>.year = year
        <span class="hljs-variable language_">self</span>.month = month
        <span class="hljs-variable language_">self</span>.day = day

    <span class="hljs-comment"># Alternate constructor</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">today</span>(<span class="hljs-params">cls</span>):
        t = time.localtime()
        <span class="hljs-keyword">return</span> cls(t.tm_year, t.tm_mon, t.tm_mday)
</code></pre>
<p>直接调用类方法即可，下面是使用示例：</p>
<pre><code class="lang-python">a = Date(<span class="hljs-number">2012</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>) <span class="hljs-comment"># Primary</span>
b = Date.today() <span class="hljs-comment"># Alternate</span>
</code></pre>
<h2 id="讨论">讨论</h2>
<p>类方法的一个主要用途就是定义多个构造器。它接受一个 <code>class</code>作为第一个参数(cls)。 你应该注意到了这个类被用来创建并返回最终的实例。在继承时也能工作的很好：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewDate</span>(<span class="hljs-title class_ inherited__">Date</span>):
    <span class="hljs-keyword">pass</span>

c = Date.today() <span class="hljs-comment"># Creates an instance of Date (cls=Date)</span>
d = NewDate.today() <span class="hljs-comment"># Creates an instance of NewDate (cls=NewDate)</span>
</code></pre>
<h1 id="817-创建不调用-init-方法的实例">8.17 创建不调用 init 方法的实例</h1>
<h2 id="问题">问题</h2>
<p>你想创建一个实例，但是希望绕过执行 <code>__init__()</code> 方法。</p>
<h2 id="解决方案">解决方案</h2>
<p>可以通过 <code>__new__()</code> 方法创建一个未初始化的实例。例如考虑如下这个类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        <span class="hljs-variable language_">self</span>.year = year
        <span class="hljs-variable language_">self</span>.month = month
        <span class="hljs-variable language_">self</span>.day = day
</code></pre>
<p>下面演示如何不调用 <code>__init__()</code> 方法来创建这个 Date 实例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = Date.__new__(Date)
<span class="hljs-meta">&gt;&gt;&gt; </span>d
&lt;__main__.Date <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006716d0</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>d.year
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
AttributeError: <span class="hljs-string">'Date'</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">'year'</span>
&gt;&gt;&gt;
</code></pre>
<p>结果可以看到，这个 Date 实例的属性 year 还不存在，所以你需要手动初始化：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>data = {<span class="hljs-string">'year'</span>:<span class="hljs-number">2012</span>, <span class="hljs-string">'month'</span>:<span class="hljs-number">8</span>, <span class="hljs-string">'day'</span>:<span class="hljs-number">29</span>}
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> data.items():
<span class="hljs-meta">... </span>    <span class="hljs-built_in">setattr</span>(d, key, value)
...
<span class="hljs-meta">&gt;&gt;&gt; </span>d.year
<span class="hljs-number">2012</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>d.month
<span class="hljs-number">8</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>当我们在反序列对象或者实现某个类方法构造函数时需要绕过 <code>__init__()</code>方法来创建对象。 例如，对于上面的 Date 来来讲，有时候你可能会像下面这样定义一个新的构造函数 <code>today()</code> ：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> localtime

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, year, month, day</span>):
        <span class="hljs-variable language_">self</span>.year = year
        <span class="hljs-variable language_">self</span>.month = month
        <span class="hljs-variable language_">self</span>.day = day

<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">today</span>(<span class="hljs-params">cls</span>):
        d = cls.__new__(cls)
        t = localtime()
        d.year = t.tm_year
        d.month = t.tm_mon
        d.day = t.tm_mday
        <span class="hljs-keyword">return</span> d
</code></pre>
<p>同样，在你反序列化 JSON 数据时产生一个如下的字典对象：</p>
<pre><code class="lang-python">data = { <span class="hljs-string">'year'</span>: <span class="hljs-number">2012</span>, <span class="hljs-string">'month'</span>: <span class="hljs-number">8</span>, <span class="hljs-string">'day'</span>: <span class="hljs-number">29</span> }
</code></pre>
<p>如果你想将它转换成一个 Date 类型实例，可以使用上面的技术。</p>
<p>当你通过这种非常规方式来创建实例的时候，最好不要直接去访问底层实例字典，除非你真的清楚所有细节。 否则的话，如果这个类使用了 <code>__slots__</code>、properties 、descriptors 或其他高级技术的时候代码就会失效。 而这时候使用 <code>setattr()</code>方法会让你的代码变得更加通用。</p>
<h1 id="818-利用-mixins-扩展类功能">8.18 利用 Mixins 扩展类功能</h1>
<h2 id="问题">问题</h2>
<p>你有很多有用的方法，想使用它们来扩展其他类的功能。但是这些类并没有任何继承的关系。 因此你不能简单的将这些方法放入一个基类，然后被其他类继承。</p>
<h2 id="解决方案">解决方案</h2>
<p>通常当你想自定义类的时候会碰上这些问题。可能是某个库提供了一些基础类， 你可以利用它们来构造你自己的类。</p>
<p>假设你想扩展映射对象，给它们添加日志、唯一性设置、类型检查等等功能。下面是一些混入类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggedMappingMixin</span>:
    <span class="hljs-string">"""
    Add logging to get/set/delete operations for debugging.
    """</span>
    __slots__ = ()  <span class="hljs-comment"># 混入类都没有实例变量，因为直接实例化混入类没有任何意义</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting '</span> + <span class="hljs-built_in">str</span>(key))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getitem__(key)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Setting {} = {!r}'</span>.<span class="hljs-built_in">format</span>(key, value))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__setitem__(key, value)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Deleting '</span> + <span class="hljs-built_in">str</span>(key))
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__delitem__(key)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">SetOnceMappingMixin</span>:
    <span class="hljs-string">'''
    Only allow a key to be set once.
    '''</span>
    __slots__ = ()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):
        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>:
            <span class="hljs-keyword">raise</span> KeyError(<span class="hljs-built_in">str</span>(key) + <span class="hljs-string">' already set'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__setitem__(key, value)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringKeysMappingMixin</span>:
    <span class="hljs-string">'''
    Restrict keys to strings only
    '''</span>
    __slots__ = ()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">str</span>):
            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'keys must be strings'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__setitem__(key, value)
</code></pre>
<p>这些类单独使用起来没有任何意义，事实上如果你去实例化任何一个类，除了产生异常外没任何作用。 它们是用来通过多继承来和其他映射对象混入使用的。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggedDict</span>(LoggedMappingMixin, <span class="hljs-built_in">dict</span>):
    <span class="hljs-keyword">pass</span>

d = LoggedDict()
d[<span class="hljs-string">'x'</span>] = <span class="hljs-number">23</span>
<span class="hljs-built_in">print</span>(d[<span class="hljs-string">'x'</span>])
<span class="hljs-keyword">del</span> d[<span class="hljs-string">'x'</span>]

<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SetOnceDefaultDict</span>(SetOnceMappingMixin, defaultdict):
    <span class="hljs-keyword">pass</span>


d = SetOnceDefaultDict(<span class="hljs-built_in">list</span>)
d[<span class="hljs-string">'x'</span>].append(<span class="hljs-number">2</span>)
d[<span class="hljs-string">'x'</span>].append(<span class="hljs-number">3</span>)
<span class="hljs-comment"># d['x'] = 23  # KeyError: 'x already set'</span>
</code></pre>
<p>这个例子中，可以看到混入类跟其他已存在的类(比如 dict、defaultdict 和 OrderedDict)结合起来使用，一个接一个。 结合后就能发挥正常功效了。</p>
<h2 id="讨论">讨论</h2>
<p>混入类在标志库中很多地方都出现过，通常都是用来像上面那样扩展某些类的功能。 它们也是多继承的一个主要用途。比如，当你编写网络代码时候， 你会经常使用 <code>socketserver</code> 模块中的 <code>ThreadingMixIn</code> 来给其他网络相关类增加多线程支持。 例如，下面是一个多线程的 XML-RPC 服务：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> xmlrpc.server <span class="hljs-keyword">import</span> SimpleXMLRPCServer
<span class="hljs-keyword">from</span> socketserver <span class="hljs-keyword">import</span> ThreadingMixIn
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadedXMLRPCServer</span>(ThreadingMixIn, SimpleXMLRPCServer):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>同时在一些大型库和框架中也会发现混入类的使用，用途同样是增强已存在的类的功能和一些可选特征。</p>
<p>对于混入类，有几点需要记住。首先是，混入类不能直接被实例化使用。 其次，混入类没有自己的状态信息，也就是说它们并没有定义 <code>__init__()</code> 方法，并且没有实例属性。 这也是为什么我们在上面明确定义了 <code>__slots__ = ()</code>。</p>
<p>还有一种实现混入类的方式就是使用类装饰器，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">LoggedMapping</span>(<span class="hljs-params">cls</span>):
    <span class="hljs-string">"""第二种方式：使用类装饰器"""</span>
    cls_getitem = cls.__getitem__
    cls_setitem = cls.__setitem__
    cls_delitem = cls.__delitem__

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Getting '</span> + <span class="hljs-built_in">str</span>(key))
        <span class="hljs-keyword">return</span> cls_getitem(<span class="hljs-variable language_">self</span>, key)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Setting {} = {!r}'</span>.<span class="hljs-built_in">format</span>(key, value))
        <span class="hljs-keyword">return</span> cls_setitem(<span class="hljs-variable language_">self</span>, key, value)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Deleting '</span> + <span class="hljs-built_in">str</span>(key))
        <span class="hljs-keyword">return</span> cls_delitem(<span class="hljs-variable language_">self</span>, key)

    cls.__getitem__ = __getitem__
    cls.__setitem__ = __setitem__
    cls.__delitem__ = __delitem__
    <span class="hljs-keyword">return</span> cls


<span class="hljs-meta">@LoggedMapping</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggedDict</span>(<span class="hljs-title class_ inherited__">dict</span>):
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>这个效果跟之前的是一样的，而且不再需要使用多继承了。参考9.12小节获取更多类装饰器的信息， 参考8.13小节查看更多混入类和类装饰器的例子。</p>
<h1 id="819-实现状态对象或者状态机">8.19 实现状态对象或者状态机</h1>
<h2 id="问题">问题</h2>
<p>你想实现一个状态机或者是在不同状态下执行操作的对象，但是又不想在代码中出现太多的条件判断语句。</p>
<h2 id="解决方案">解决方案</h2>
<p>在很多程序中，有些对象会根据状态的不同来执行不同的操作。比如考虑如下的一个连接对象：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connection</span>:
    <span class="hljs-string">"""普通方案，好多个判断语句，效率低下~~"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.state = <span class="hljs-string">'CLOSED'</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.state != <span class="hljs-string">'OPEN'</span>:
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Not open'</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'reading'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.state != <span class="hljs-string">'OPEN'</span>:
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Not open'</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'writing'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.state == <span class="hljs-string">'OPEN'</span>:
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Already open'</span>)
        <span class="hljs-variable language_">self</span>.state = <span class="hljs-string">'OPEN'</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.state == <span class="hljs-string">'CLOSED'</span>:
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Already closed'</span>)
        <span class="hljs-variable language_">self</span>.state = <span class="hljs-string">'CLOSED'</span>
</code></pre>
<p>这样写有很多缺点，首先是代码太复杂了，好多的条件判断。其次是执行效率变低， 因为一些常见的操作比如 read()、write()每次执行前都需要执行检查。</p>
<p>一个更好的办法是为每个状态定义一个对象：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connection1</span>:
    <span class="hljs-string">"""新方案——对每个状态定义一个类"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.new_state(ClosedConnectionState)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">new_state</span>(<span class="hljs-params">self, newstate</span>):
        <span class="hljs-variable language_">self</span>._state = newstate
        <span class="hljs-comment"># Delegate to the state class</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._state.read(<span class="hljs-variable language_">self</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._state.write(<span class="hljs-variable language_">self</span>, data)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._state.<span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._state.close(<span class="hljs-variable language_">self</span>)


<span class="hljs-comment"># Connection state base class</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionState</span>:
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">conn</span>):
        <span class="hljs-keyword">raise</span> NotImplementedError()

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">conn, data</span>):
        <span class="hljs-keyword">raise</span> NotImplementedError()

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">conn</span>):
        <span class="hljs-keyword">raise</span> NotImplementedError()

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">conn</span>):
        <span class="hljs-keyword">raise</span> NotImplementedError()


<span class="hljs-comment"># Implementation of different states</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosedConnectionState</span>(<span class="hljs-title class_ inherited__">ConnectionState</span>):
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">conn</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Not open'</span>)

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">conn, data</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Not open'</span>)

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">conn</span>):
        conn.new_state(OpenConnectionState)

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">conn</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Already closed'</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenConnectionState</span>(<span class="hljs-title class_ inherited__">ConnectionState</span>):
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">conn</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'reading'</span>)

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">conn, data</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'writing'</span>)

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">conn</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Already open'</span>)

<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">conn</span>):
        conn.new_state(ClosedConnectionState)
</code></pre>
<p>下面是使用演示：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>c = Connection()
<span class="hljs-meta">&gt;&gt;&gt; </span>c._state
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.ClosedConnectionState'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>c.read()
Traceback (most recent call last):
    File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">10</span>, <span class="hljs-keyword">in</span> read
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._state.read(<span class="hljs-variable language_">self</span>)
    File <span class="hljs-string">"example.py"</span>, line <span class="hljs-number">43</span>, <span class="hljs-keyword">in</span> read
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'Not open'</span>)
RuntimeError: Not <span class="hljs-built_in">open</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c.<span class="hljs-built_in">open</span>()
<span class="hljs-meta">&gt;&gt;&gt; </span>c._state
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.OpenConnectionState'</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span>c.read()
reading
<span class="hljs-meta">&gt;&gt;&gt; </span>c.write(<span class="hljs-string">'hello'</span>)
writing
<span class="hljs-meta">&gt;&gt;&gt; </span>c.close()
<span class="hljs-meta">&gt;&gt;&gt; </span>c._state
&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'__main__.ClosedConnectionState'</span>&gt;
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>如果代码中出现太多的条件判断语句的话，代码就会变得难以维护和阅读。 这里的解决方案是将每个状态抽取出来定义成一个类。</p>
<p>这里看上去有点奇怪，每个状态对象都只有静态方法，并没有存储任何的实例属性数据。 实际上，所有状态信息都只存储在<code>Connection</code> 实例中。 在基类中定义的 <code>NotImplementedError</code> 是为了确保子类实现了相应的方法。 这里你或许还想使用8.12小节讲解的抽象基类方式。</p>
<p>设计模式中有一种模式叫状态模式，这一小节算是一个初步入门！</p>
<h1 id="820-通过字符串调用对象方法">8.20 通过字符串调用对象方法</h1>
<h2 id="问题">问题</h2>
<p>你有一个字符串形式的方法名称，想通过它调用某个对象的对应方法。</p>
<h2 id="解决方案">解决方案</h2>
<p>最简单的情况，可以使用 <code>getattr()</code> ：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> math

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-variable language_">self</span>.x = x
        <span class="hljs-variable language_">self</span>.y = y

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Point({!r:},{!r:})'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.x, <span class="hljs-variable language_">self</span>.y)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distance</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-keyword">return</span> math.hypot(<span class="hljs-variable language_">self</span>.x - x, <span class="hljs-variable language_">self</span>.y - y)


p = Point(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
d = <span class="hljs-built_in">getattr</span>(p, <span class="hljs-string">'distance'</span>)(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># Calls p.distance(0, 0)</span>
</code></pre>
<p>另外一种方法是使用 <code>operator.methodcaller()</code>，例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> operator
operator.methodcaller(<span class="hljs-string">'distance'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)(p)
</code></pre>
<p>当你需要通过相同的参数多次调用某个方法时，使用 <code>operator.methodcaller</code> 就很方便了。 比如你需要排序一系列的点，就可以这样做：</p>
<pre><code class="lang-python">points = [
    Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
    Point(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>),
    Point(<span class="hljs-number">10</span>, -<span class="hljs-number">3</span>),
    Point(-<span class="hljs-number">5</span>, -<span class="hljs-number">7</span>),
    Point(-<span class="hljs-number">1</span>, <span class="hljs-number">8</span>),
    Point(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)
]
<span class="hljs-comment"># Sort by distance from origin (0, 0)</span>
points.sort(key=operator.methodcaller(<span class="hljs-string">'distance'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))
</code></pre>
<h2 id="讨论">讨论</h2>
<p>调用一个方法实际上是两部独立操作，第一步是查找属性，第二步是函数调用。 因此，为了调用某个方法，你可以首先通过 <code>getattr()</code> 来查找到这个属性，然后再去以函数方式调用它即可。</p>
<p><code>operator.methodcaller()</code> 创建一个可调用对象，并同时提供所有必要参数， 然后调用的时候只需要将实例对象传递给它即可，比如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>d = operator.methodcaller(<span class="hljs-string">'distance'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>d(p)
<span class="hljs-number">5.0</span>
&gt;&gt;&gt;
</code></pre>
<p>通过方法名称字符串来调用方法通常出现在需要模拟 <code>case</code>语句或实现访问者模式的时候。 参考下一小节获取更多高级例子。</p>
<h1 id="821-实现访问者模式">8.21 实现访问者模式</h1>
<h2 id="问题">问题</h2>
<p>你要处理由大量不同类型的对象组成的复杂数据结构，每一个对象都需要需要进行不同的处理。 比如，遍历一个树形结构，然后根据每个节点的相应状态执行不同的操作。</p>
<h2 id="解决方案">解决方案</h2>
<p>这里遇到的问题在编程领域中是很普遍的，有时候会构建一个由大量不同对象组成的数据结构。 假设你要写一个表示数学表达式的程序，那么你可能需要定义如下的类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperator</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, operand</span>):
        <span class="hljs-variable language_">self</span>.operand = operand

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryOperator</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, left, right</span>):
        <span class="hljs-variable language_">self</span>.left = left
        <span class="hljs-variable language_">self</span>.right = right

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mul</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Div</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Negate</span>(<span class="hljs-title class_ inherited__">UnaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-variable language_">self</span>.value = value
</code></pre>
<p>然后利用这些类构建嵌套数据结构，如下所示：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Representation of 1 + 2 * (3 - 4) / 5</span>
t1 = Sub(Number(<span class="hljs-number">3</span>), Number(<span class="hljs-number">4</span>))
t2 = Mul(Number(<span class="hljs-number">2</span>), t1)
t3 = Div(t2, Number(<span class="hljs-number">5</span>))
t4 = Add(Number(<span class="hljs-number">1</span>), t3)
</code></pre>
<p>这样做的问题是对于每个表达式，每次都要重新定义一遍，有没有一种更通用的方式让它支持所有的数字和操作符呢。 这里我们使用访问者模式可以达到这样的目的：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeVisitor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">self, node</span>):
        methname = <span class="hljs-string">'visit_'</span> + <span class="hljs-built_in">type</span>(node).__name__
        meth = <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, methname, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> meth <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            meth = <span class="hljs-variable language_">self</span>.generic_visit
        <span class="hljs-keyword">return</span> meth(node)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generic_visit</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'No {} method'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">'visit_'</span> + <span class="hljs-built_in">type</span>(node).__name__))
</code></pre>
<p>为了使用这个类，可以定义一个类继承它并且实现各种 <code>visit_Name()</code> 方法，其中 Name 是 node 类型。 例如，如果你想求表达式的值，可以这样写：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Evaluator</span>(<span class="hljs-title class_ inherited__">NodeVisitor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Number</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> node.value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Add</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) + <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Sub</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) - <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Mul</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) * <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Div</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) / <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Negate</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> -node.operand
</code></pre>
<p>使用示例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>e = Evaluator()
<span class="hljs-meta">&gt;&gt;&gt; </span>e.visit(t4)
<span class="hljs-number">0.6</span>
&gt;&gt;&gt;
</code></pre>
<p>作为一个不同的例子，下面定义一个类在一个栈上面将一个表达式转换成多个操作序列：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackCode</span>(<span class="hljs-title class_ inherited__">NodeVisitor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_code</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>.instructions = []
        <span class="hljs-variable language_">self</span>.visit(node)
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.instructions

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Number</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>.instructions.append((<span class="hljs-string">'PUSH'</span>, node.value))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">binop</span>(<span class="hljs-params">self, node, instruction</span>):
        <span class="hljs-variable language_">self</span>.visit(node.left)
        <span class="hljs-variable language_">self</span>.visit(node.right)
        <span class="hljs-variable language_">self</span>.instructions.append((instruction,))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Add</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>.binop(node, <span class="hljs-string">'ADD'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Sub</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>.binop(node, <span class="hljs-string">'SUB'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Mul</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>.binop(node, <span class="hljs-string">'MUL'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Div</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>.binop(node, <span class="hljs-string">'DIV'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unaryop</span>(<span class="hljs-params">self, node, instruction</span>):
        <span class="hljs-variable language_">self</span>.visit(node.operand)
        <span class="hljs-variable language_">self</span>.instructions.append((instruction,))

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Negate</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>.unaryop(node, <span class="hljs-string">'NEG'</span>)
</code></pre>
<p>使用示例：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = StackCode()
<span class="hljs-meta">&gt;&gt;&gt; </span>s.generate_code(t4)
[(<span class="hljs-string">'PUSH'</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">'PUSH'</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">'PUSH'</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">'PUSH'</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">'SUB'</span>,),
(<span class="hljs-string">'MUL'</span>,), (<span class="hljs-string">'PUSH'</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">'DIV'</span>,), (<span class="hljs-string">'ADD'</span>,)]
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>刚开始的时候你可能会写大量的 if/else 语句来实现， 这里访问者模式的好处就是通过 <code>getattr()</code>来获取相应的方法，并利用递归来遍历所有的节点：</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">binop</span>(<span class="hljs-params">self, node, instruction</span>):
    <span class="hljs-variable language_">self</span>.visit(node.left)
    <span class="hljs-variable language_">self</span>.visit(node.right)
    <span class="hljs-variable language_">self</span>.instructions.append((instruction,))
</code></pre>
<p>还有一点需要指出的是，这种技术也是实现其他语言中 switch 或 case 语句的方式。 比如，如果你正在写一个 HTTP 框架，你可能会写这样一个请求分发的控制器：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HTTPHandler</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">self, request</span>):
        methname = <span class="hljs-string">'do_'</span> + request.request_method
        <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, methname)(request)
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_GET</span>(<span class="hljs-params">self, request</span>):
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_POST</span>(<span class="hljs-params">self, request</span>):
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_HEAD</span>(<span class="hljs-params">self, request</span>):
        <span class="hljs-keyword">pass</span>
</code></pre>
<p>访问者模式一个缺点就是它严重依赖递归，如果数据结构嵌套层次太深可能会有问题， 有时候会超过 Python 的递归深度限制(参考 <code>sys.getrecursionlimit()</code> )。</p>
<p>可以参照8.22小节，利用生成器或迭代器来实现非递归遍历算法。</p>
<p>在跟解析和编译相关的编程中使用访问者模式是非常常见的。 Python 本身的 <code>ast</code> 模块值的关注下，可以去看看源码。 9.24小节演示了一个利用<code>ast</code>模块来处理 Python 源代码的例子。</p>
<h1 id="822-不用递归实现访问者模式">8.22 不用递归实现访问者模式</h1>
<h2 id="问题">问题</h2>
<p>你使用访问者模式遍历一个很深的嵌套树形数据结构，并且因为超过嵌套层级限制而失败。 你想消除递归，并同时保持访问者编程模式。</p>
<h2 id="解决方案">解决方案</h2>
<p>通过巧妙的使用生成器可以在树遍历或搜索算法中消除递归。 在8.21小节中，我们给出了一个访问者类。 下面我们利用一个栈和生成器重新实现这个类：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> types

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NodeVisitor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">self, node</span>):
        stack = [node]
        last_result = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">while</span> stack:
            <span class="hljs-keyword">try</span>:
                last = stack[-<span class="hljs-number">1</span>]
                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(last, types.GeneratorType):
                    stack.append(last.send(last_result))
                    last_result = <span class="hljs-literal">None</span>
                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(last, Node):
                    stack.append(<span class="hljs-variable language_">self</span>._visit(stack.pop()))
                <span class="hljs-keyword">else</span>:
                    last_result = stack.pop()
            <span class="hljs-keyword">except</span> StopIteration:
                stack.pop()

        <span class="hljs-keyword">return</span> last_result

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_visit</span>(<span class="hljs-params">self, node</span>):
        methname = <span class="hljs-string">'visit_'</span> + <span class="hljs-built_in">type</span>(node).__name__
        meth = <span class="hljs-built_in">getattr</span>(<span class="hljs-variable language_">self</span>, methname, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> meth <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            meth = <span class="hljs-variable language_">self</span>.generic_visit
        <span class="hljs-keyword">return</span> meth(node)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generic_visit</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'No {} method'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">'visit_'</span> + <span class="hljs-built_in">type</span>(node).__name__))
</code></pre>
<p>如果你使用这个类，也能达到相同的效果。事实上你完全可以将它作为上一节中的访问者模式的替代实现。 考虑如下代码，遍历一个表达式的树：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperator</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, operand</span>):
        <span class="hljs-variable language_">self</span>.operand = operand

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryOperator</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, left, right</span>):
        <span class="hljs-variable language_">self</span>.left = left
        <span class="hljs-variable language_">self</span>.right = right

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mul</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Div</span>(<span class="hljs-title class_ inherited__">BinaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Negate</span>(<span class="hljs-title class_ inherited__">UnaryOperator</span>):
    <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Number</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-variable language_">self</span>.value = value

<span class="hljs-comment"># A sample visitor class that evaluates expressions</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Evaluator</span>(<span class="hljs-title class_ inherited__">NodeVisitor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Number</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> node.value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Add</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) + <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Sub</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) - <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Mul</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) * <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Div</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) / <span class="hljs-variable language_">self</span>.visit(node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Negate</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> -<span class="hljs-variable language_">self</span>.visit(node.operand)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># 1 + 2*(3-4) / 5</span>
    t1 = Sub(Number(<span class="hljs-number">3</span>), Number(<span class="hljs-number">4</span>))
    t2 = Mul(Number(<span class="hljs-number">2</span>), t1)
    t3 = Div(t2, Number(<span class="hljs-number">5</span>))
    t4 = Add(Number(<span class="hljs-number">1</span>), t3)
    <span class="hljs-comment"># Evaluate it</span>
    e = Evaluator()
    <span class="hljs-built_in">print</span>(e.visit(t4))  <span class="hljs-comment"># Outputs 0.6</span>
</code></pre>
<p>如果嵌套层次太深那么上述的 Evaluator 就会失效：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100000</span>):
<span class="hljs-meta">... </span>a = Add(a, Number(n))
...
<span class="hljs-meta">&gt;&gt;&gt; </span>e = Evaluator()
<span class="hljs-meta">&gt;&gt;&gt; </span>e.visit(a)
Traceback (most recent call last):
...
    File <span class="hljs-string">"visitor.py"</span>, line <span class="hljs-number">29</span>, <span class="hljs-keyword">in</span> _visit
<span class="hljs-keyword">return</span> meth(node)
    File <span class="hljs-string">"visitor.py"</span>, line <span class="hljs-number">67</span>, <span class="hljs-keyword">in</span> visit_Add
<span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.visit(node.left) + <span class="hljs-variable language_">self</span>.visit(node.right)
RuntimeError: maximum recursion depth exceeded
&gt;&gt;&gt;
</code></pre>
<p>现在我们稍微修改下上面的 Evaluator：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Evaluator</span>(<span class="hljs-title class_ inherited__">NodeVisitor</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Number</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">return</span> node.value

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Add</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">yield</span> (<span class="hljs-keyword">yield</span> node.left) + (<span class="hljs-keyword">yield</span> node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Sub</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">yield</span> (<span class="hljs-keyword">yield</span> node.left) - (<span class="hljs-keyword">yield</span> node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Mul</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">yield</span> (<span class="hljs-keyword">yield</span> node.left) * (<span class="hljs-keyword">yield</span> node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Div</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">yield</span> (<span class="hljs-keyword">yield</span> node.left) / (<span class="hljs-keyword">yield</span> node.right)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Negate</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-keyword">yield</span> - (<span class="hljs-keyword">yield</span> node.operand)
</code></pre>
<p>再次运行，就不会报错了：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Number(<span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100000</span>):
<span class="hljs-meta">... </span>    a = Add(a, Number(n))
...
<span class="hljs-meta">&gt;&gt;&gt; </span>e = Evaluator()
<span class="hljs-meta">&gt;&gt;&gt; </span>e.visit(a)
<span class="hljs-number">4999950000</span>
&gt;&gt;&gt;
</code></pre>
<p>如果你还想添加其他自定义逻辑也没问题：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Evaluator</span>(<span class="hljs-title class_ inherited__">NodeVisitor</span>):
    ...
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit_Add</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Add:'</span>, node)
        lhs = <span class="hljs-keyword">yield</span> node.left
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'left='</span>, lhs)
        rhs = <span class="hljs-keyword">yield</span> node.right
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'right='</span>, rhs)
        <span class="hljs-keyword">yield</span> lhs + rhs
    ...
</code></pre>
<p>下面是简单的测试：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>e = Evaluator()
<span class="hljs-meta">&gt;&gt;&gt; </span>e.visit(t4)
Add: &lt;__main__.Add <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1006a8d90</span>&gt;
left= <span class="hljs-number">1</span>
right= -<span class="hljs-number">0.4</span>
<span class="hljs-number">0.6</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>这一小节我们演示了生成器和协程在程序控制流方面的强大功能。 避免递归的一个通常方法是使用一个栈或队列的数据结构。 例如，深度优先的遍历算法，第一次碰到一个节点时将其压入栈中，处理完后弹出栈。<code>visit()</code>方法的核心思路就是这样。</p>
<p>另外一个需要理解的就是生成器中 yield 语句。当碰到 yield 语句时，生成器会返回一个数据并暂时挂起。 上面的例子使用这个技术来代替了递归。例如，之前我们是这样写递归：</p>
<pre><code class="lang-python">value = <span class="hljs-variable language_">self</span>.visit(node.left)
</code></pre>
<p>现在换成 yield 语句：</p>
<pre><code class="lang-python">value = <span class="hljs-keyword">yield</span> node.left
</code></pre>
<p>它会将 <code>node.left</code> 返回给 <code>visti()</code> 方法，然后<code>visti()</code>方法调用那个节点相应的 <code>vist_Name()</code>方法。 yield 暂时将程序控制器让出给调用者，当执行完后，结果会赋值给value，</p>
<p>看完这一小节，你也许想去寻找其它没有 yield 语句的方案。但是这么做没有必要，你必须处理很多棘手的问题。 例如，为了消除递归，你必须要维护一个栈结构，如果不使用生成器，代码会变得很臃肿，到处都是栈操作语句、回调函数等。 实际上，使用yield语句可以让你写出非常漂亮的代码，它消除了递归但是看上去又很像递归实现，代码很简洁。</p>
<h1 id="823-循环引用数据结构的内存管理">8.23 循环引用数据结构的内存管理</h1>
<h2 id="问题">问题</h2>
<p>你的程序创建了很多循环引用数据结构(比如树、图、观察者模式等)，你碰到了内存管理难题。</p>
<h2 id="解决方案">解决方案</h2>
<p>一个简单的循环引用数据结构例子就是一个树形结构，双亲节点有指针指向孩子节点，孩子节点又返回来指向双亲节点。 这种情况下，可以考虑使用 <code>weakref</code> 库中的弱引用。例如：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> weakref

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):
        <span class="hljs-variable language_">self</span>.value = value
        <span class="hljs-variable language_">self</span>._parent = <span class="hljs-literal">None</span>
        <span class="hljs-variable language_">self</span>.children = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Node({!r:})'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.value)

    <span class="hljs-comment"># property that manages the parent as a weak-reference</span>
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-variable language_">self</span>._parent()

<span class="hljs-meta">    @parent.setter</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params">self, node</span>):
        <span class="hljs-variable language_">self</span>._parent = weakref.ref(node)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_child</span>(<span class="hljs-params">self, child</span>):
        <span class="hljs-variable language_">self</span>.children.append(child)
        child.parent = <span class="hljs-variable language_">self</span>
</code></pre>
<p>这种是想方式允许 parent 静默终止。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>root = Node(<span class="hljs-string">'parent'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c1 = Node(<span class="hljs-string">'child'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>root.add_child(c1)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1.parent)
Node(<span class="hljs-string">'parent'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> root
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(c1.parent)
<span class="hljs-literal">None</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>循环引用的数据结构在 Python 中是一个很棘手的问题，因为正常的垃圾回收机制不能适用于这种情形。 例如考虑如下代码：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Class just to illustrate when deletion occurs</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Data.__del__'</span>)

<span class="hljs-comment"># Node class involving a cycle</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.data = Data()
        <span class="hljs-variable language_">self</span>.parent = <span class="hljs-literal">None</span>
        <span class="hljs-variable language_">self</span>.children = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_child</span>(<span class="hljs-params">self, child</span>):
        <span class="hljs-variable language_">self</span>.children.append(child)
        child.parent = <span class="hljs-variable language_">self</span>
</code></pre>
<p>下面我们使用这个代码来做一些垃圾回收试验：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Data()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a <span class="hljs-comment"># Immediately deleted</span>
Data.__del__
<span class="hljs-meta">&gt;&gt;&gt; </span>a = Node()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a <span class="hljs-comment"># Immediately deleted</span>
Data.__del__
<span class="hljs-meta">&gt;&gt;&gt; </span>a = Node()
<span class="hljs-meta">&gt;&gt;&gt; </span>a.add_child(Node())
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a <span class="hljs-comment"># Not deleted (no message)</span>
&gt;&gt;&gt;
</code></pre>
<p>可以看到，最后一个的删除时打印语句没有出现。原因是 Python 的垃圾回收机制是基于简单的引用计数。 当一个对象的引用数变成0的时候才会立即删除掉。而对于循环引用这个条件永远不会成立。 因此，在上面例子中最后部分，父节点和孩子节点互相拥有对方的引用，导致每个对象的引用计数都不可能变成0。</p>
<p>Python 有另外的垃圾回收器来专门针对循环引用的，但是你永远不知道它什么时候会触发。 另外你还可以手动的触发它，但是代码看上去很挫：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> gc
<span class="hljs-meta">&gt;&gt;&gt; </span>gc.collect() <span class="hljs-comment"># Force collection</span>
Data.__del__
Data.__del__
&gt;&gt;&gt;
</code></pre>
<p>如果循环引用的对象自己还定义了自己的 <code>__del__()</code> 方法，那么会让情况变得更糟糕。 假设你像下面这样给 Node 定义自己的 <code>__del__()</code>方法：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Node class involving a cycle</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.data = Data()
        <span class="hljs-variable language_">self</span>.parent = <span class="hljs-literal">None</span>
        <span class="hljs-variable language_">self</span>.children = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_child</span>(<span class="hljs-params">self, child</span>):
        <span class="hljs-variable language_">self</span>.children.append(child)
        child.parent = <span class="hljs-variable language_">self</span>

    <span class="hljs-comment"># NEVER DEFINE LIKE THIS.</span>
    <span class="hljs-comment"># Only here to illustrate pathological behavior</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.data
        <span class="hljs-keyword">del</span>.parent
        <span class="hljs-keyword">del</span>.children
</code></pre>
<p>这种情况下，垃圾回收永远都不会去回收这个对象的，还会导致内存泄露。 如果你试着去运行它会发现，<code>Data.__del__</code>消息永远不会出现了,甚至在你强制内存回收时：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Node()
<span class="hljs-meta">&gt;&gt;&gt; </span>a.add_child(Node()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a <span class="hljs-comment"># No message (not collected)</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> gc
<span class="hljs-meta">&gt;&gt;&gt; </span>gc.collect() <span class="hljs-comment"># No message (not collected)</span>
&gt;&gt;&gt;
</code></pre>
<p>弱引用消除了引用循环的这个问题，本质来讲，弱引用就是一个对象指针，它不会增加它的引用计数。 你可以通过 <code>weakref</code> 来创建弱引用。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> weakref
<span class="hljs-meta">&gt;&gt;&gt; </span>a = Node()
<span class="hljs-meta">&gt;&gt;&gt; </span>a_ref = weakref.ref(a)
<span class="hljs-meta">&gt;&gt;&gt; </span>a_ref
&lt;weakref at <span class="hljs-number">0x100581f70</span>; to <span class="hljs-string">'Node'</span> at <span class="hljs-number">0x1005c5410</span>&gt;
&gt;&gt;&gt;
</code></pre>
<p>为了访问弱引用所引用的对象，你可以像函数一样去调用它即可。如果那个对象还存在就会返回它，否则就返回一个 None。 由于原始对象的引用计数没有增加，那么就可以去删除它了。例如;</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a_ref())
&lt;__main__.Node <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1005c5410</span>&gt;
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a
Data.__del__
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a_ref())
<span class="hljs-literal">None</span>
&gt;&gt;&gt;
</code></pre>
<p>通过这里演示的弱引用技术，你会发现不再有循环引用问题了，一旦某个节点不被使用了，垃圾回收器立即回收它。 你还能参考8.25小节关于弱引用的另外一个例子。</p>
<h1 id="824-让类支持比较操作">8.24 让类支持比较操作</h1>
<h2 id="问题">问题</h2>
<p>你想让某个类的实例支持标准的比较运算(比如&gt;=,!=,&lt;=,&lt;等)，但是又不想去实现那一大丢的特殊方法。</p>
<h2 id="解决方案">解决方案</h2>
<p>Python 类对每个比较操作都需要实现一个特殊方法来支持。 例如为了支持&gt;=操作符，你需要定义一个 <code>__ge__()</code> 方法。 尽管定义一个方法没什么问题，但如果要你实现所有可能的比较方法那就有点烦人了。</p>
<p>装饰器 <code>functools.total_ordering</code>就是用来简化这个处理的。 使用它来装饰一个来，你只需定义一个<code>__eq__()</code> 方法， 外加其他方法(<strong>lt</strong>, <strong>le</strong>, <strong>gt</strong>, or <strong>ge</strong>)中的一个即可。 然后装饰器会自动为你填充其它比较方法。</p>
<p>作为例子，我们构建一些房子，然后给它们增加一些房间，最后通过房子大小来比较它们：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> total_ordering

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, length, width</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.length = length
        <span class="hljs-variable language_">self</span>.width = width
        <span class="hljs-variable language_">self</span>.square_feet = <span class="hljs-variable language_">self</span>.length * <span class="hljs-variable language_">self</span>.width

<span class="hljs-meta">@total_ordering</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, style</span>):
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-variable language_">self</span>.style = style
        <span class="hljs-variable language_">self</span>.rooms = <span class="hljs-built_in">list</span>()

<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">living_space_footage</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(r.square_feet <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.rooms)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_room</span>(<span class="hljs-params">self, room</span>):
        <span class="hljs-variable language_">self</span>.rooms.append(room)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'{}: {} square foot {}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.name,
                <span class="hljs-variable language_">self</span>.living_space_footage,
                <span class="hljs-variable language_">self</span>.style)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.living_space_footage == other.living_space_footage

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.living_space_footage &lt; other.living_space_footage
</code></pre>
<p>这里我们只是给 House 类定义了两个方法：<code>__eq__()</code> 和 <code>__lt__()</code>，它就能支持所有的比较操作：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Build a few houses, and add rooms to them</span>
h1 = House(<span class="hljs-string">'h1'</span>, <span class="hljs-string">'Cape'</span>)
h1.add_room(Room(<span class="hljs-string">'Master Bedroom'</span>, <span class="hljs-number">14</span>, <span class="hljs-number">21</span>))
h1.add_room(Room(<span class="hljs-string">'Living Room'</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>))
h1.add_room(Room(<span class="hljs-string">'Kitchen'</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>))
h1.add_room(Room(<span class="hljs-string">'Office'</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>))
h2 = House(<span class="hljs-string">'h2'</span>, <span class="hljs-string">'Ranch'</span>)
h2.add_room(Room(<span class="hljs-string">'Master Bedroom'</span>, <span class="hljs-number">14</span>, <span class="hljs-number">21</span>))
h2.add_room(Room(<span class="hljs-string">'Living Room'</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>))
h2.add_room(Room(<span class="hljs-string">'Kitchen'</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>))
h3 = House(<span class="hljs-string">'h3'</span>, <span class="hljs-string">'Split'</span>)
h3.add_room(Room(<span class="hljs-string">'Master Bedroom'</span>, <span class="hljs-number">14</span>, <span class="hljs-number">21</span>))
h3.add_room(Room(<span class="hljs-string">'Living Room'</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>))
h3.add_room(Room(<span class="hljs-string">'Office'</span>, <span class="hljs-number">12</span>, <span class="hljs-number">16</span>))
h3.add_room(Room(<span class="hljs-string">'Kitchen'</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>))
houses = [h1, h2, h3]
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Is h1 bigger than h2?'</span>, h1 &gt; h2) <span class="hljs-comment"># prints True</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Is h2 smaller than h3?'</span>, h2 &lt; h3) <span class="hljs-comment"># prints True</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Is h2 greater than or equal to h1?'</span>, h2 &gt;= h1) <span class="hljs-comment"># Prints False</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Which one is biggest?'</span>, <span class="hljs-built_in">max</span>(houses)) <span class="hljs-comment"># Prints 'h3: 1101-square-foot Split'</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Which is smallest?'</span>, <span class="hljs-built_in">min</span>(houses)) <span class="hljs-comment"># Prints 'h2: 846-square-foot Ranch'</span>
</code></pre>
<h2 id="讨论">讨论</h2>
<p>其实 <code>total_ordering</code>装饰器也没那么神秘。 它就是定义了一个从每个比较支持方法到所有需要定义的其他方法的一个映射而已。 比如你定义了 <code>__le__()</code> 方法，那么它就被用来构建所有其他的需要定义的那些特殊方法。 实际上就是在类里面像下面这样定义了一些特殊方法：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">pass</span>
    <span class="hljs-comment"># Methods created by @total_ordering</span>
    __le__ = <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>, other: <span class="hljs-variable language_">self</span> &lt; other <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span> == other
    __gt__ = <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>, other: <span class="hljs-keyword">not</span> (<span class="hljs-variable language_">self</span> &lt; other <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span> == other)
    __ge__ = <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>, other: <span class="hljs-keyword">not</span> (<span class="hljs-variable language_">self</span> &lt; other)
    __ne__ = <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>, other: <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span> == other
</code></pre>
<p>当然，你自己去写也很容易，但是使用 <code>@total_ordering</code>可以简化代码，何乐而不为呢。</p>
<h1 id="825-创建缓存实例">8.25 创建缓存实例</h1>
<h2 id="问题">问题</h2>
<p>在创建一个类的对象时，如果之前使用同样参数创建过这个对象， 你想返回它的缓存引用。</p>
<h2 id="解决方案">解决方案</h2>
<p>这种通常是因为你希望相同参数创建的对象时单例的。 在很多库中都有实际的例子，比如 <code>logging</code> 模块，使用相同的名称创建的 <code>logger</code> 实例永远只有一个。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> logging
<span class="hljs-meta">&gt;&gt;&gt; </span>a = logging.getLogger(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b = logging.getLogger(<span class="hljs-string">'bar'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c = logging.getLogger(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> c
<span class="hljs-literal">True</span>
&gt;&gt;&gt;
</code></pre>
<p>为了达到这样的效果，你需要使用一个和类本身分开的工厂函数，例如：</p>
<pre><code class="lang-python"><span class="hljs-comment"># The class in question</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

<span class="hljs-comment"># Caching support</span>
<span class="hljs-keyword">import</span> weakref
_spam_cache = weakref.WeakValueDictionary()
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_spam</span>(<span class="hljs-params">name</span>):
    <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _spam_cache:
        s = Spam(name)
        _spam_cache[name] = s
    <span class="hljs-keyword">else</span>:
        s = _spam_cache[name]
    <span class="hljs-keyword">return</span> s
</code></pre>
<p>然后做一个测试，你会发现跟之前那个日志对象的创建行为是一致的：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = get_spam(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b = get_spam(<span class="hljs-string">'bar'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>c = get_spam(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> c
<span class="hljs-literal">True</span>
&gt;&gt;&gt;
</code></pre>
<h2 id="讨论">讨论</h2>
<p>编写一个工厂函数来修改普通的实例创建行为通常是一个比较简单的方法。 但是我们还能否找到更优雅的解决方案呢？</p>
<p>例如，你可能会考虑重新定义类的 <code>__new__()</code>方法，就像下面这样：</p>
<pre><code class="lang-python"><span class="hljs-comment"># Note: This code doesn't quite work</span>
<span class="hljs-keyword">import</span> weakref

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
    _spam_cache = weakref.WeakValueDictionary()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name</span>):
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> cls._spam_cache:
            <span class="hljs-keyword">return</span> cls._spam_cache[name]
        <span class="hljs-keyword">else</span>:
            <span class="hljs-variable language_">self</span> = <span class="hljs-built_in">super</span>().__new__(cls)
            cls._spam_cache[name] = <span class="hljs-variable language_">self</span>
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Initializing Spam'</span>)
        <span class="hljs-variable language_">self</span>.name = name
</code></pre>
<p>初看起来好像可以达到预期效果，但是问题是 <code>__init__()</code> 每次都会被调用，不管这个实例是否被缓存了。例如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Spam(<span class="hljs-string">'Dave'</span>)
Initializing Spam
<span class="hljs-meta">&gt;&gt;&gt; </span>t = Spam(<span class="hljs-string">'Dave'</span>)
Initializing Spam
<span class="hljs-meta">&gt;&gt;&gt; </span>s <span class="hljs-keyword">is</span> t
<span class="hljs-literal">True</span>
&gt;&gt;&gt;
</code></pre>
<p>这个或许不是你想要的效果，因此这种方法并不可取。</p>
<p>上面我们使用到了弱引用计数，对于垃圾回收来讲是很有帮助的，关于这个我们在8.23小节已经讲过了。 当我们保持实例缓存时，你可能只想在程序中使用到它们时才保存。 一个 <code>WeakValueDictionary</code> 实例只会保存那些在其它地方还在被使用的实例。 否则的话，只要实例不再被使用了，它就从字典中被移除了。观察下下面的测试结果：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = get_spam(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b = get_spam(<span class="hljs-string">'bar'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>c = get_spam(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(_spam_cache)
[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> a
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> c
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(_spam_cache)
[<span class="hljs-string">'bar'</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> b
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(_spam_cache)
[]
&gt;&gt;&gt;
</code></pre>
<p>对于大部分程序而已，这里代码已经够用了。不过还是有一些更高级的实现值得了解下。</p>
<p>首先是这里使用到了一个全局变量，并且工厂函数跟类放在一块。我们可以通过将缓存代码放到一个单独的缓存管理器中：</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> weakref

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedSpamManager</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._cache = weakref.WeakValueDictionary()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_spam</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._cache:
            s = Spam(name)
            <span class="hljs-variable language_">self</span>._cache[name] = s
        <span class="hljs-keyword">else</span>:
            s = <span class="hljs-variable language_">self</span>._cache[name]
        <span class="hljs-keyword">return</span> s

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):
            <span class="hljs-variable language_">self</span>._cache.clear()

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
    manager = CachedSpamManager()
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-variable language_">self</span>.name = name

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_spam</span>(<span class="hljs-params">name</span>):
        <span class="hljs-keyword">return</span> Spam.manager.get_spam(name)
</code></pre>
<p>这样的话代码更清晰，并且也更灵活，我们可以增加更多的缓存管理机制，只需要替代 manager 即可。</p>
<p>还有一点就是，我们暴露了类的实例化给用户，用户很容易去直接实例化这个类，而不是使用工厂方法，如：</p>
<pre><code class="lang-python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = Spam(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>b = Spam(<span class="hljs-string">'foo'</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b
<span class="hljs-literal">False</span>
&gt;&gt;&gt;
</code></pre>
<p>有几种方式可以防止用户这样做，第一个是将类的名字修改为以下划线(<em>)开头，提示用户别直接调用它。 第二种就是让这个类的 `<em>_init</em></em>()` 方法抛出一个异常，让它不能被初始化：</p>
<pre><code class="lang-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">"Can't instantiate directly"</span>)

    <span class="hljs-comment"># Alternate constructor</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">cls, name</span>):
        <span class="hljs-variable language_">self</span> = cls.__new__(cls)
        <span class="hljs-variable language_">self</span>.name = name
</code></pre>
<p>然后修改缓存管理器代码，使用 <code>Spam._new()</code> 来创建实例，而不是直接调用 <code>Spam()</code>构造函数：</p>
<pre><code class="lang-python"><span class="hljs-comment"># ------------------------最后的修正方案------------------------</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedSpamManager2</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>._cache = weakref.WeakValueDictionary()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_spam</span>(<span class="hljs-params">self, name</span>):
        <span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._cache:
            temp = Spam3._new(name)  <span class="hljs-comment"># Modified creation</span>
            <span class="hljs-variable language_">self</span>._cache[name] = temp
        <span class="hljs-keyword">else</span>:
            temp = <span class="hljs-variable language_">self</span>._cache[name]
        <span class="hljs-keyword">return</span> temp

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params">self</span>):
            <span class="hljs-variable language_">self</span>._cache.clear()

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spam3</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">"Can't instantiate directly"</span>)

    <span class="hljs-comment"># Alternate constructor</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">cls, name</span>):
        <span class="hljs-variable language_">self</span> = cls.__new__(cls)
        <span class="hljs-variable language_">self</span>.name = name
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>
</code></pre>
<p>最后这样的方案就已经足够好了。 缓存和其他构造模式还可以使用9.13小节中的元类实现的更优雅一点(使用了更高级的技术)。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="functions.html" class="navigation navigation-prev " aria-label="Previous page: 第七章：函数">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="metaprogramming.html" class="navigation navigation-next " aria-label="Next page: 第九章：元编程">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第八章：类与对象","level":"1.9","depth":1,"next":{"title":"第九章：元编程","level":"1.10","depth":1,"path":"metaprogramming.md","ref":"metaprogramming.md","articles":[]},"previous":{"title":"第七章：函数","level":"1.8","depth":1,"path":"functions.md","ref":"functions.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"classes-and-objects.md","mtime":"2025-01-05T18:01:57.042Z","type":"markdown"},"gitbook":{"version":"6.0.2","time":"2025-01-05T18:02:08.648Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

